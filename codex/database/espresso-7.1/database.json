{
    "postahc": {
        "input": {
            "ahc_dir": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "Directory where the binary files are located",
                "id": "idm246684014976",
                "info": "Directory where the binary files are located."
            },
            "nk": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Number of k points",
                "id": "idm246684013184",
                "info": "Number of k points. Must be identical to that of the preceding SCF or NSCF run."
            },
            "nbnd": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Number of bands",
                "id": "idm246684011440",
                "info": "Number of bands. Must be identical to nbnd of the preceding SCF or NSCF run."
            },
            "nat": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Number of atoms",
                "id": "idm246684009680",
                "info": "Number of atoms. Must be identical to nat of the preceding pw.x and ph.x runs."
            },
            "nq": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Number of q points",
                "id": "idm246684007936",
                "info": "Number of q points. Must be identical to that of the preceding ph.x run with electron_phonon='ahc'."
            },
            "ahc_nbnd": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Number of bands for which the electron self",
                "id": "idm246684006096",
                "info": "Number of bands for which the electron self-energy is to be computed. Must be identical to ahc_nbnd of the ph.x run with electron_phonon='ahc'."
            },
            "ahc_nbndskip": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "Number of bands to exclude when computing the self",
                "id": "idm246684004144",
                "info": "Number of bands to exclude when computing the self-energy. Must be identical to ahc_nbndskip of the ph.x run with electron_phonon='ahc'."
            },
            "flvec": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "File containing the normalized phonon displacements written by matdyn",
                "id": "idm246684002224",
                "info": "File containing the normalized phonon displacements written by matdyn.x."
            },
            "eta": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Magnitude of the small imaginary component included to smooth the energy denominators, in Ry",
                "id": "idm246684000464",
                "info": "Magnitude of the small imaginary component included to smooth the energy denominators, in Ry."
            },
            "temp_kelvin": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Temperature in Kelvins at which the electron self",
                "id": "idm246683998704",
                "info": "Temperature in Kelvins at which the electron self-energy is calculated."
            },
            "efermi": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Fermi energy of the electrons in Ry",
                "id": "idm246683996944",
                "info": "Fermi energy of the electrons in Ry."
            },
            "amass_amu": {
                "datatype": "realarray (nat)",
                "default": "",
                "options": {},
                "summary": "Mass for each atom in atomic mass unit",
                "id": "idm246683995200",
                "info": "Mass for each atom in atomic mass unit. In postahc.x, amass_amu must be set for each atom, not for each atom type as in other programs."
            },
            "skip_upperfan": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm246683992496",
                "info": "If .true., skip calculation of the upper Fan self-energy. If .false., ahc_upfan_iq#.bin files must be present in ahc_dir."
            },
            "skip_dw": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm246683990288",
                "info": "If .true., skip calculation of the Debye-Waller self-energy. If .false., ahc_dw.bin file must be present in ahc_dir."
            }
        }
    },
    "band_interpolation": {
        "interpolation": {
            "method": {
                "datatype": "string",
                "default": "fourier-diff",
                "options": {
                    "fourier-diff": "band energies, as functions of k, are expanded in reciprocal space using a Star function basis set (algorithm from Pickett W. E., Krakauer H., Allen P. B., Phys. Rev. B, vol. 38, issue 4, page 2721, 1988,",
                    "fourier": "band energies, as functions of k, are expanded in reciprocal space using a Star function basis set (algorithm from D. D. Koelling, J. H. Wood, J. Comput. Phys., 67, 253-262 (1986).",
                    "idw": "inverse distance weighting interpolation with Shepard metric (ACM 68: Proceedings of the 1968 23rd ACM national conference, January 1968, Pages 517\u00e2\u0080\u0093524,",
                    "idw-sphere": "inverse distance weighting interpolation inside a sphere of given radius. WARNING: The pwscf.xml file must be generated with nosym == .true. . WARNING: This method is REALLY simple and provides only a very rough estimate of the band structure."
                },
                "summary": "Available options are",
                "id": "idm293040515376",
                "info": "Available options are:"
            },
            "miller_max": {
                "datatype": "integer",
                "default": "6",
                "options": {},
                "summary": "The maximum Miller index used to automatically generate the set of symmetry inequivalent Star vectors                   ",
                "id": "idm293040505904",
                "info": "The maximum Miller index used to automatically generate the set of symmetry inequivalent Star vectors                   (only for method == 'fourier-diff' or 'fourier')"
            },
            "check_periodicity": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm293040503664",
                "info": "If .TRUE. a (time consuming) step is performed, to check whether all the Star functions have                   the correct lattice periodicity (only for method == 'fourier-diff' or 'fourier') .                    For automatically generated Star functions this should never occur by construction, and the program                   will stop and exit in case one Star function with wrong periodicity is found (useful for                   debugging and program sanity check).                    If additional user-defined Star vectors are specified (see optional card USER_STARS),                   the program will print a WARNING in case one Star function with wrong periodicity is found."
            },
            "p_metric": {
                "datatype": "integer",
                "default": "2",
                "options": {},
                "summary": "The exponent of the distance in the IDW method ",
                "id": "idm293040500032",
                "info": "The exponent of the distance in the IDW method ( only for method == 'idw' or 'idw-sphere')"
            },
            "scale_sphere": {
                "datatype": "integer",
                "default": "4.0d0",
                "options": {},
                "summary": "The search radius for method == 'idw",
                "id": "idm293040497824",
                "info": "The search radius for method == 'idw-sphere', is Rmin * scale_sphere, where Rmin is the                   minimum distance found between the uniform grid of k-points.                    If scale_sphere is too small, some k-points of the path might not see enough uniform grid points                   to average energies, whereas for large values the method becomes equal to method == 'idw'."
            }
        }
    },
    "cppp": {
        "inputpp": {
            "prefix": {
                "datatype": "string",
                "default": "cp",
                "options": {},
                "summary": "basename prepended to cp",
                "id": "idm365459359184",
                "info": "basename prepended to cp.x output filenames: cp.evp, cp.pos ...."
            },
            "fileout": {
                "datatype": "string",
                "default": "out",
                "options": {},
                "summary": "basename of the cppp",
                "id": "idm365459357408",
                "info": "basename of the cppp.x output files"
            },
            "output": {
                "datatype": "string",
                "default": "xsf",
                "options": {},
                "summary": "a string describing the output format to be performed, allowed values",
                "id": "idm365459355680",
                "info": "a string describing the output format to be performed, allowed values: 'xsf', 'xyz'      xsf     xcrysden format     xyz     XMOL format"
            },
            "outdir": {
                "datatype": "string",
                "default": "./",
                "options": {},
                "summary": "directory containing the CP trajectory files ",
                "id": "idm365459353840",
                "info": "directory containing the CP trajectory files (.evp .pos .cel ...) and restart files ( .save ) to be processed"
            },
            "lcharge": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "OBSOLETE ",
                "id": "idm365459352048",
                "info": "OBSOLETE - no longer implemented. Use \"pp.x\" instead."
            },
            "lforces": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "This logical flag control the processing of forces",
                "id": "idm365459350288",
                "info": "This logical flag control the processing of forces.      .TRUE.  extract forces from trajectory files and write             them to xcrysden file      .FALSE. do not process forces"
            },
            "ldynamics": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "This logical flag control the processing of atoms trajectory",
                "id": "idm365459348432",
                "info": "This logical flag control the processing of atoms trajectory.      .TRUE.  process CP trajectory files and generate a trajectory             file for xcrysden (.axsf)      .FALSE. do not process trajectory"
            },
            "lpdb": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "This logical flag control the generation of a pdb file",
                "id": "idm365459346544",
                "info": "This logical flag control the generation of a pdb file.      .TRUE.  generate a pdb file containing positions and cell             of the simulated system      .FALSE. do not generate pdb file"
            },
            "lrotation": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "This logical flag control the rotation of the cell      ",
                "id": "idm365459344672",
                "info": "This logical flag control the rotation of the cell      .TRUE.  rotate the system cell in space in order to have             the a lattice parameter laying on the x axis,             the b lattice parameter laying on the xy plane      .FALSE. do not rotate cell"
            },
            "np1": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Number of replicas of atomic positions along cell parameters",
                "id": "idm365459342224",
                "info": "Number of replicas of atomic positions along cell parameters. CURRENTLY DISABLED  If np1, np2, np3 are 1 or not specified, cppp.x does not replicate atomic positions in space.  If np1, np2, np3 are > 1 cppp.x replicates the atomic positions used in the simulation np1 times along \"a\", np2 times along \"b\", np3 times along \"c\"."
            },
            "np2": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Number of replicas of atomic positions along cell parameters",
                "id": "idm365459341616",
                "info": "Number of replicas of atomic positions along cell parameters. CURRENTLY DISABLED  If np1, np2, np3 are 1 or not specified, cppp.x does not replicate atomic positions in space.  If np1, np2, np3 are > 1 cppp.x replicates the atomic positions used in the simulation np1 times along \"a\", np2 times along \"b\", np3 times along \"c\"."
            },
            "np3": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Number of replicas of atomic positions along cell parameters",
                "id": "idm365459341008",
                "info": "Number of replicas of atomic positions along cell parameters. CURRENTLY DISABLED  If np1, np2, np3 are 1 or not specified, cppp.x does not replicate atomic positions in space.  If np1, np2, np3 are > 1 cppp.x replicates the atomic positions used in the simulation np1 times along \"a\", np2 times along \"b\", np3 times along \"c\"."
            },
            "nframes": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "number of MD step to be read to build the trajectory CURRENTLY MUST BE > 1",
                "id": "idm365459339040",
                "info": "number of MD step to be read to build the trajectory CURRENTLY MUST BE > 1"
            },
            "ndr": {
                "datatype": "integer",
                "default": "51",
                "options": {},
                "summary": "CP restart file number to post process",
                "id": "idm365459337232",
                "info": "CP restart file number to post process"
            },
            "atomic_number": {
                "datatype": "integerarray (ntyp)",
                "default": "1",
                "options": {},
                "summary": "Specify the atomic number of the species in CP trajectory and restart file",
                "id": "idm365459335536",
                "info": "Specify the atomic number of the species in CP trajectory and restart file.  atomic_number(1)  specify the atomic number of the first specie atomic_number(2)  specify the atomic number of the second specie ...."
            }
        }
    },
    "pw2bgw": {
        "input_pw2bgw": {
            "prefix": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "prefix of files saved by program pw",
                "id": "idm336384442912",
                "info": "prefix of files saved by program pw.x"
            },
            "outdir": {
                "datatype": "string",
                "default": "./",
                "options": {},
                "summary": "the scratch directory where the massive data",
                "id": "idm336384441216",
                "info": "the scratch directory where the massive data-files are written"
            },
            "real_or_complex": {
                "datatype": "integer",
                "default": "2",
                "options": {},
                "summary": "1 | 2 1 for real flavor of BerkeleyGW ",
                "id": "idm336384439472",
                "info": "1 | 2 1 for real flavor of BerkeleyGW (for systems with inversion symmetry and time-reversal symmetry) or 2 for complex flavor of BerkeleyGW (for systems without inversion symmetry and time-reversal symmetry)"
            },
            "symm_type": {
                "datatype": "string",
                "default": "cubic",
                "options": {
                    "cubic": "",
                    "hexagonal": ""
                },
                "summary": "Options are",
                "id": "idm336384436752",
                "info": "Options are:"
            },
            "wfng_flag": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "write wavefunctions in G",
                "id": "idm336384431600",
                "info": "write wavefunctions in G-space to BerkeleyGW WFN file"
            },
            "wfng_file": {
                "datatype": "string",
                "default": "WFN",
                "options": {},
                "summary": "name of BerkeleyGW WFN output file",
                "id": "idm336384429856",
                "info": "name of BerkeleyGW WFN output file. Not used if wfng_flag = .FALSE."
            },
            "wfng_kgrid": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "overwrite k",
                "id": "idm336384427680",
                "info": "overwrite k-grid parameters in BerkeleyGW WFN file. If pw.x input file contains an explicit list of k-points, the k-grid parameters in the output of pw.x will be set to zero. Since sigma and absorption in BerkeleyGW both need to know the k-grid dimensions, we patch these parameters into BerkeleyGW WFN file"
            },
            "wfng_nk1": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "number of k",
                "id": "idm336384425696",
                "info": "number of k-points along b_1 reciprocal lattice vector. Not used if wfng_kgrid = .FALSE."
            },
            "wfng_nk2": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "number of k",
                "id": "idm336384423536",
                "info": "number of k-points along b_2 reciprocal lattice vector. Not used if wfng_kgrid = .FALSE."
            },
            "wfng_nk3": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "number of k",
                "id": "idm336384421376",
                "info": "number of k-points along b_3 reciprocal lattice vector. Not used if wfng_kgrid = .FALSE."
            },
            "wfng_dk1": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "k",
                "id": "idm336384419216",
                "info": "k-grid offset (0.0 unshifted, 0.5 shifted by half a grid step) along b_1 reciprocal lattice vector. Not used if wfng_kgrid = .FALSE."
            },
            "wfng_dk2": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "k",
                "id": "idm336384417008",
                "info": "k-grid offset (0.0 unshifted, 0.5 shifted by half a grid step) along b_2 reciprocal lattice vector. Not used if wfng_kgrid = .FALSE."
            },
            "wfng_dk3": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "k",
                "id": "idm336384414800",
                "info": "k-grid offset (0.0 unshifted, 0.5 shifted by half a grid step) along b_3 reciprocal lattice vector. Not used if wfng_kgrid = .FALSE."
            },
            "wfng_occupation": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "overwrite occupations in BerkeleyGW WFN file",
                "id": "idm336384412592",
                "info": "overwrite occupations in BerkeleyGW WFN file"
            },
            "wfng_nvmin": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "index of the lowest occupied band ",
                "id": "idm336384410864",
                "info": "index of the lowest occupied band (normally = 1). Not used if wfng_occupation = .FALSE."
            },
            "wfng_nvmax": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "index of the highest occupied band ",
                "id": "idm336384408720",
                "info": "index of the highest occupied band (normally = number of occupied bands). Not used if wfng_occupation = .FALSE."
            },
            "rhog_flag": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "write charge density in G",
                "id": "idm336384406544",
                "info": "write charge density in G-space to BerkeleyGW RHO file. Only used for the GPP model in sigma code in BerkeleyGW"
            },
            "rhog_file": {
                "datatype": "string",
                "default": "RHO",
                "options": {},
                "summary": "name of BerkeleyGW RHO output file",
                "id": "idm336384404752",
                "info": "name of BerkeleyGW RHO output file. Only used for the GPP model in sigma code in BerkeleyGW. Not used if rhog_flag = .FALSE."
            },
            "rhog_nvmin": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "index of the lowest band used for calculation of charge density",
                "id": "idm336384402528",
                "info": "index of the lowest band used for calculation of charge density. This is needed if one wants to exclude semicore states from charge density used for the GPP model in sigma code in BerkeleyGW. Make sure to include the same k-points as in scf calculation. Self-consistent charge density is used if rhog_nvmin = 0 and rhog_nvmax = 0. Not used if rhog_flag = .FALSE. BEWARE: this feature is highly experimental and may not work at all in parallel, with pools, with spins, etc."
            },
            "rhog_nvmax": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "index of the highest band used for calculation of charge density",
                "id": "idm336384399584",
                "info": "index of the highest band used for calculation of charge density. See description of rhog_nvmin for more details"
            },
            "vxcg_flag": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "write local part of exchange",
                "id": "idm336384397808",
                "info": "write local part of exchange-correlation potential in G-space to BerkeleyGW VXC file. Only used in sigma code in BerkeleyGW, it is recommended to use vxc_flag instead"
            },
            "vxcg_file": {
                "datatype": "string",
                "default": "VXC",
                "options": {},
                "summary": "name of BerkeleyGW VXC output file",
                "id": "idm336384395552",
                "info": "name of BerkeleyGW VXC output file. Only used in sigma code in BerkeleyGW, it is recommended to use vxc_flag instead. Not used if vxcg_flag = .FALSE."
            },
            "vxc0_flag": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "write Vxc",
                "id": "idm336384392896",
                "info": "write Vxc(G = 0) to text file. Only for testing, not required for BerkeleyGW"
            },
            "vxc0_file": {
                "datatype": "string",
                "default": "vxc0.dat",
                "options": {},
                "summary": "name of output text file for Vxc",
                "id": "idm336384391136",
                "info": "name of output text file for Vxc(G = 0). Only for testing, not required for BerkeleyGW. Not used if vxc0_flag = .FALSE."
            },
            "vxc_flag": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "write matrix elements of exchange",
                "id": "idm336384388928",
                "info": "write matrix elements of exchange-correlation potential to text file. Only used in sigma code in BerkeleyGW"
            },
            "vxc_file": {
                "datatype": "string",
                "default": "vxc.dat",
                "options": {},
                "summary": "name of output text file for Vxc matrix elements",
                "id": "idm336384387136",
                "info": "name of output text file for Vxc matrix elements. Only used in sigma code in BerkeleyGW. Not used if vxc_flag = .FALSE."
            },
            "vxc_integral": {
                "datatype": "string",
                "default": "g",
                "options": {},
                "summary": "'g' | 'r' 'g' to compute matrix elements of exchange",
                "id": "idm336384384928",
                "info": "'g' | 'r' 'g' to compute matrix elements of exchange-correlation potential in G-space. 'r' to compute matrix elements of the local part of exchange-correlation potential in R-space. It is recommended to use 'g'. Not used if vxc_flag = .FALSE."
            },
            "vxc_diag_nmin": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "minimum band index for diagonal Vxc matrix elements",
                "id": "idm336384382224",
                "info": "minimum band index for diagonal Vxc matrix elements. Not used if vxc_flag = .FALSE."
            },
            "vxc_diag_nmax": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "maximum band index for diagonal Vxc matrix elements",
                "id": "idm336384380064",
                "info": "maximum band index for diagonal Vxc matrix elements. Not used if vxc_flag = .FALSE."
            },
            "vxc_offdiag_nmin": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "minimum band index for off",
                "id": "idm336384377904",
                "info": "minimum band index for off-diagonal Vxc matrix elements. Not used if vxc_flag = .FALSE."
            },
            "vxc_offdiag_nmax": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "maximum band index for off",
                "id": "idm336384375728",
                "info": "maximum band index for off-diagonal Vxc matrix elements. Not used if vxc_flag = .FALSE."
            },
            "vxc_zero_rho_core": {
                "datatype": "boolean",
                "default": ".TRUE.",
                "options": {},
                "summary": "set to ",
                "id": "idm336384373552",
                "info": "set to .TRUE. to zero out NLCC or to .FALSE. to keep NLCC when computing exchange-correlation potential. This flag has no effect for pseudopotentials without NLCC. BEWARE: setting vxc_zero_rho_core to .FALSE. will produce incorrect results. This functionality is only included for testing purposes and is not meant to be used in a production environment"
            },
            "vscg_flag": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "write local part of self",
                "id": "idm336384370688",
                "info": "write local part of self-consistent potential in G-space to BerkeleyGW VSC file. Only used in SAPO code in BerkeleyGW"
            },
            "vscg_file": {
                "datatype": "string",
                "default": "VSC",
                "options": {},
                "summary": "name of BerkeleyGW VSC output file",
                "id": "idm336384368880",
                "info": "name of BerkeleyGW VSC output file. Only used in SAPO code in BerkeleyGW. Not used if vscg_flag = .FALSE."
            },
            "vkbg_flag": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "write Kleinman",
                "id": "idm336384366672",
                "info": "write Kleinman-Bylander projectors in G-space to BerkeleyGW VKB file. Only used in SAPO code in BerkeleyGW"
            },
            "vkbg_file": {
                "datatype": "string",
                "default": "VKB",
                "options": {},
                "summary": "name of BerkeleyGW VKB output file",
                "id": "idm336384364880",
                "info": "name of BerkeleyGW VKB output file. Only used in SAPO code in BerkeleyGW. Not used if vkbg_flag = .FALSE."
            }
        }
    },
    "dos": {
        "dos": {
            "prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "prefix of input file produced by pw",
                "id": "idm271901213072",
                "info": "prefix of input file produced by pw.x (wavefunctions are not needed)"
            },
            "outdir": {
                "datatype": "string",
                "default": "value of the",
                "options": {},
                "summary": "directory containing the input data, i",
                "id": "idm271901211264",
                "info": "directory containing the input data, i.e. the same as in pw.x"
            },
            "bz_sum": {
                "datatype": "string",
                "default": "'smearing' if degauss is given in input;                         options read from the xml data file otherwise.",
                "options": {
                    "smearing": "integration using gaussian smearing. In fact currently any string not related to tetrahedra defaults to smearing;",
                    "tetrahedra": "Tetrahedron method, Bloechl's version: P.E. Bloechl, PRB 49, 16223 (1994) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.49.16223) Requires uniform grid of k-points, to be automatically generated in pw.x.",
                    "tetrahedra_lin": "Original linear tetrahedron method. To be used only as a reference; the optimized tetrahedron method is more efficient.",
                    "tetrahedra_opt": "Optimized tetrahedron method: see M. Kawamura, PRB 89, 094515 (2014) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.89.094515)."
                },
                "summary": "Keyword selecting  the method for BZ summation",
                "id": "idm271901209024",
                "info": "Keyword selecting  the method for BZ summation. Available options are:"
            },
            "ngauss": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "Type of gaussian broadening",
                "id": "idm271901202128",
                "info": "Type of gaussian broadening:      =  0  Simple Gaussian (default)      =  1  Methfessel-Paxton of order 1      = -1  \"cold smearing\" (Marzari-Vanderbilt-DeVita-Payne)      =-99  Fermi-Dirac function"
            },
            "degauss": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "gaussian broadening, Ry ",
                "id": "idm271901199824",
                "info": "gaussian broadening, Ry (not eV!) (see below)"
            },
            "Emin": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "min, max energy ",
                "id": "idm271901197984",
                "info": "min, max energy (eV) for DOS plot. If unspecified, the lower and/or upper band value, plus/minus 3 times the value of the gaussian smearing if present, will be used."
            },
            "Emax": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "min, max energy ",
                "id": "idm271901197360",
                "info": "min, max energy (eV) for DOS plot. If unspecified, the lower and/or upper band value, plus/minus 3 times the value of the gaussian smearing if present, will be used."
            },
            "DeltaE": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "energy grid step ",
                "id": "idm271901195616",
                "info": "energy grid step (eV)"
            },
            "fildos": {
                "datatype": "string",
                "default": "prefix.dos",
                "options": {},
                "summary": "output file containing DOS",
                "id": "idm271901194320",
                "info": "output file containing DOS(E)"
            }
        }
    },
    "eels": {
        "lr_input": {
            "prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "Sets the prefix for generated and read files",
                "id": "idm141592576624",
                "info": "Sets the prefix for generated and read files. The files generated by the ground state pw.x run must have this same prefix."
            },
            "outdir": {
                "datatype": "string",
                "default": "./",
                "options": {},
                "summary": "The directory that contains the run critical files, which include the files generated by ground state pw",
                "id": "idm141592574784",
                "info": "The directory that contains the run critical files, which include the files generated by ground state pw.x run."
            },
            "restart": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When set to ",
                "id": "idm141592572992",
                "info": "When set to .true., turbo_eels.x will attempt to restart from a previous interrupted calculation. (see restart_step variable). Beware, if set to .false. turbo_eels.x will OVERWRITE any previous runs."
            },
            "restart_step": {
                "datatype": "integer",
                "default": "itermax",
                "options": {},
                "summary": "The code writes restart files every restart_step iterations",
                "id": "idm141592570720",
                "info": "The code writes restart files every restart_step iterations. Restart files are automatically written at the end of itermax Lanczos steps."
            },
            "lr_verbosity": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "This integer variable controls the amount of information written to standard output",
                "id": "idm141592568896",
                "info": "This integer variable controls the amount of information written to standard output."
            },
            "disk_io": {
                "datatype": "string",
                "default": "default",
                "options": {},
                "summary": "Fine control of disk usage",
                "id": "idm141592567152",
                "info": "Fine control of disk usage. Currently only 'reduced' is supported where no restart files are written, apart from the 'default' mode."
            }
        },
        "lr_control": {
            "approximation": {
                "datatype": "string",
                "default": "TDDFT",
                "options": {
                    "TDDFT": "Time-Dependent Local Density Approximation or Time-Dependent Generalized Gradient Approximation (depending on the XC functional)",
                    "IPA": "Independent Particle Approximation (IPA)",
                    "RPA_with_CLFE": "Random Phase Approximation (RPA) with Crystal Local Field Effects (CLFE)"
                },
                "summary": "A string describing a level of theory",
                "id": "idm141592564528",
                "info": "A string describing a level of theory:"
            },
            "q1": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "The values of the transferred momentum q = ",
                "id": "idm141592559712",
                "info": "The values of the transferred momentum q = (q1, q2, q3) in Cartesian coordinates in units of 2pi/a, where \"a\" is the lattice parameter."
            },
            "q2": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "The values of the transferred momentum q = ",
                "id": "idm141592559104",
                "info": "The values of the transferred momentum q = (q1, q2, q3) in Cartesian coordinates in units of 2pi/a, where \"a\" is the lattice parameter."
            },
            "q3": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "The values of the transferred momentum q = ",
                "id": "idm141592558464",
                "info": "The values of the transferred momentum q = (q1, q2, q3) in Cartesian coordinates in units of 2pi/a, where \"a\" is the lattice parameter."
            },
            "calculator": {
                "datatype": "string",
                "default": "lanczos",
                "options": {
                    "lanczos": "corresponds to the Lanczos recursive algorithm",
                    "sternheimer": "corresponds to the Sternheimer algorithm"
                },
                "summary": "Variable that controls which algorithm is used to compute EELS spectra",
                "id": "idm141592556672",
                "info": "Variable that controls which algorithm is used to compute EELS spectra."
            },
            "itermax": {
                "datatype": "integer",
                "default": "500",
                "options": {},
                "summary": "When calculator = 'lanczos', itermax is the maximum number of Lanczos iterations that will be performed",
                "id": "idm141592553152",
                "info": "When calculator = 'lanczos', itermax is the maximum number of Lanczos iterations that will be performed. When calculator = 'sternheimer', itermax is the maximum number of iterations in a SCF step for each frequency."
            },
            "pseudo_hermitian": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "This variable is used only when calculator = 'lanczos'",
                "id": "idm141592549616",
                "info": "This variable is used only when calculator = 'lanczos'. When set to .true. the pseudo-Hermitian Lanczos algorithm is used. When set to .false. the non-Hermitian Lanczos biorthogonalization algorithm is used (which is two times slower)."
            },
            "alpha_mix(i)": {
                "datatype": "real",
                "default": "alpha_mix(1)=0.7",
                "options": {},
                "summary": "This variable is used only when calculator = 'sternheimer'",
                "id": "#",
                "info": "This variable is used only when calculator = 'sternheimer'. Mixing parameter (for the i-th iteration) for updating the response SCF potential using the modified Broyden method: D.D. Johnson, PRB 38, 12807 (1988) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.38.12807)."
            },
            "epsil": {
                "datatype": "real",
                "default": "0.02",
                "options": {},
                "summary": "This variable is used only when calculator = 'sternheimer'",
                "id": "idm141592543808",
                "info": "This variable is used only when calculator = 'sternheimer'. The broadening/damping term (in Rydberg units)."
            },
            "units": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "This variable is used only when calculator = 'sternheimer'",
                "id": "idm141592541504",
                "info": "This variable is used only when calculator = 'sternheimer'. The unit system used for the output, for start, end, and increment input parameters. 0 = Rydbergs, 1 = Electron volts."
            },
            "start": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "This variable is used only when calculator = 'sternheimer'",
                "id": "idm141592537904",
                "info": "This variable is used only when calculator = 'sternheimer'. start is the value of frequency starting from which the susceptibility and the loss function (-Im(1/eps)) will be computed. start is specified in units controlled by units."
            },
            "end": {
                "datatype": "real",
                "default": "2.5",
                "options": {},
                "summary": "This variable is used only when calculator = 'sternheimer'",
                "id": "idm141592533952",
                "info": "This variable is used only when calculator = 'sternheimer'. end is the value of frequency up to which the susceptibility and the loss function (-Im(1/eps)) will be computed. end is specified in units controlled by units."
            },
            "increment": {
                "datatype": "real",
                "default": "0.001",
                "options": {},
                "summary": "This variable is used only when calculator = 'sternheimer'",
                "id": "idm141592530064",
                "info": "This variable is used only when calculator = 'sternheimer'. increment is an incremental step used to define the mesh of frequencies between start and end. increment is specified in units controlled by units."
            },
            "ethr_nscf": {
                "datatype": "real",
                "default": "1.D-11",
                "options": {},
                "summary": "Threshold for the convergence of eigenvalues during the iterative diagonalization of the Hamiltonian in the non",
                "id": "idm141592525344",
                "info": "Threshold for the convergence of eigenvalues during the iterative diagonalization of the Hamiltonian in the non-self-consistent-field (NSCF) calculation at k and k+q points. Note, this quantity is NOT extensive."
            }
        }
    },
    "all_currents": {
        "energy_current": {
            "delta_t": {
                "datatype": "real",
                "default": "1.D0",
                "options": {},
                "summary": "Small timestep used to do the numerical derivative needed in order to compute some parts of the current",
                "id": "idm540605090832",
                "info": "Small timestep used to do the numerical derivative needed in order to compute some parts of the current. Note that is in the pw.x units."
            },
            "file_output": {
                "datatype": "string",
                "default": "current_hz",
                "options": {},
                "summary": "The program will write the output in file_output and file_output  + '",
                "id": "idm540605088960",
                "info": "The program will write the output in file_output and file_output  + '.dat'. In the latter file the format of the output is:     NSTEP t_ps J_x J_y J_z Jele_x Jele_y Jele_z v_cm(1)_x v_cm(1)_y v_cm(1)_z ...  where J_x, J_y, J_z are the three components of the DFT energy current, and can be easily post-processed by other external programs. Jele_* are the components of the electronic density current that may be used for decorrelation and better data analysis or for calculating the electric current. v_cm(1) ... v_cm(nsp) are the center of mass velocities for each atomic species.  If n_repeat_every_step > 1, an additional file file_output + '.stat' is written with the following format:     NSTEP t_ps mean(J_x) mean(J_y) mean(J_z) std(J_x) std(J_y) std(J_z)  only one line per step is printed in this case (in the other output files you will find every calculation, also repeated ones). std is the standard deviation."
            },
            "trajdir": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "Prefix of the cp",
                "id": "idm540605084944",
                "info": "Prefix of the cp.x trajectory. The program will try to open the files trajdir .pos and trajdir .vel The files, for n atoms, are formatted like this:     NSTEP1 t_ps1    x(1) y(1) z(2)    .    .    .    .    .    .    .    .    .    x(n) y(n) z(n)    NSTEP2 t_ps2    x(1) y(1) z(2)    .    .    .    .    .    .    .    .    .    x(n) y(n) z(n)    ...  the order of the atomic types must be the same of the one provided in the input file. If the files are not found, only the positions and the velocities from the input file will be used. Note that the units are specified by the input file. The units of the velocities are the same of the positions with time in atomic units. If a cp.x trajectory is provided (see vel_input_units ) a factor 2 can be used for the velocities."
            },
            "vel_input_units": {
                "datatype": "string",
                "default": "PW",
                "options": {
                    "CP": "assume velocities are given in cp.x time units (thus multiplying by 2 the velocities)",
                    "PW": "assume velocities are given in pw.x time units"
                },
                "summary": "This multiplies or not by a factor 2 the velocities given in the input",
                "id": "idm540605081296",
                "info": "This multiplies or not by a factor 2 the velocities given in the input.                       Available options are:"
            },
            "eta": {
                "datatype": "real",
                "default": "1.D0",
                "options": {},
                "summary": "Convergence parameter for Ewald",
                "id": "idm540605077616",
                "info": "Convergence parameter for Ewald-like sums"
            },
            "n_max": {
                "datatype": "integer",
                "default": "5",
                "options": {},
                "summary": "Number of images in each direction used to converge some sums",
                "id": "idm540605075920",
                "info": "Number of images in each direction used to converge some sums."
            },
            "first_step": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "The program will start with step  istep >= first_step",
                "id": "idm540605074192",
                "info": "The program will start with step  istep >= first_step. If greater than zero the input file's positions and velocities will be ignored. Note that this is not a sequential index but refers to the indexes reported in the input trajectory file. The index of 0 is assigned to the snapshot described in the input namelist file."
            },
            "last_step": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "The program will end with step  istep <= last_step",
                "id": "idm540605071408",
                "info": "The program will end with step  istep <= last_step. If 0, it will stop at the end of the trajectory file Note that this is not a sequential index but refers to the indexes reported in the input trajectory file."
            },
            "step_mul": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "The program will use the step only if MOD",
                "id": "idm540605069088",
                "info": "The program will use the step only if MOD(step, step_mul) == step_rem."
            },
            "step_rem": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "The program will use the step only if MOD",
                "id": "idm540605066544",
                "info": "The program will use the step only if MOD(step, step_mul) == step_rem."
            },
            "ethr_small_step": {
                "datatype": "real",
                "default": "1.D-7",
                "options": {},
                "summary": "Diagonalization threshold after the small delta_t numerical derivative step",
                "id": "idm540605064000",
                "info": "Diagonalization threshold after the small delta_t numerical derivative step. (the system changed a very little)"
            },
            "ethr_big_step": {
                "datatype": "real",
                "default": "1.D-3",
                "options": {},
                "summary": "Diagonalization threshold at the beginning of each step but the first, for wich the pw",
                "id": "idm540605061808",
                "info": "Diagonalization threshold at the beginning of each step but the first, for wich the pw.x input value is used."
            },
            "restart": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If true try to read file_output ",
                "id": "idm540605060016",
                "info": "If true try to read file_output .dat and try to set first_step to the last step in the file + 1"
            },
            "subtract_cm_vel": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If true subtract from the velocities of all atoms for every step the center of mass velocity for each atomic type",
                "id": "idm540605057440",
                "info": "If true subtract from the velocities of all atoms for every step the center of mass velocity for each atomic type. It help to decorrelate a little the mass flux from the energy flux"
            },
            "add_i_current_b": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If true adds to the energy current a part that is correctly implemented only for cubic cells",
                "id": "idm540605055568",
                "info": "If true adds to the energy current a part that is correctly implemented only for cubic cells. This part is in the form of a sum over the atomic types of a constant time the center of mass velocity of the atomic type. It does not change the value of the thermal conductivity when the formula for the multicomponent case with the inverse of the Schur complement is used, and in the single component or solid case this is a non-diffusive contribution."
            },
            "save_dvpsi": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If true allocate the space needed for saving the solution of the linear system betweew every calculation",
                "id": "idm540605053440",
                "info": "If true allocate the space needed for saving the solution of the linear system betweew every calculation. The iterative algorithm will always start from there. By default it starts always from scratch."
            },
            "re_init_wfc_1": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If true initializes, as specified in the ELECTRON namelist of the PW section, the wavefunctions before the first ground state calculation, then compute the charge density",
                "id": "idm540605051552",
                "info": "If true initializes, as specified in the ELECTRON namelist of the PW section, the wavefunctions before the first ground state calculation, then compute the charge density.  Otherwise use the last calculated wavefunctions."
            },
            "re_init_wfc_2": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If true initializes, as specified in the ELECTRON namelist of the PW section, the wavefunctions before the second ground state calculation, then compute the charge density",
                "id": "idm540605049648",
                "info": "If true initializes, as specified in the ELECTRON namelist of the PW section, the wavefunctions before the second ground state calculation, then compute the charge density. Otherwise use the last calculated wavefunctions. Note that if three_point_derivative is false, this has no effect."
            },
            "re_init_wfc_3": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If true initializes, as specified in the ELECTRON namelist of the PW section, the wavefunctions before the third ground state calculation, then compute the charge density",
                "id": "idm540605047280",
                "info": "If true initializes, as specified in the ELECTRON namelist of the PW section, the wavefunctions before the third ground state calculation, then compute the charge density. Otherwise use the last calculated wavefunctions."
            },
            "three_point_derivative": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "If true calculates three ground stated",
                "id": "idm540605045376",
                "info": "If true calculates three ground stated: one at t - delta_t /2, one at t and one at t + delta_t/2. Obviously it needs more computer time, but the derivative should be better."
            },
            "n_repeat_every_step": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "Number of repetition of the full current calculation for each step",
                "id": "idm540605042704",
                "info": "Number of repetition of the full current calculation for each step. If > 1, the file file_output + '.stat' is written with some statistics. Note that if you don't specify at least re_init_wfc_1 ,this may be useless. You may want to specify startingwfc = 'random' in the ELECTRONS namelist."
            },
            "n_workers": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "The calculation over all the trajectory is splitted in n_workers chunks",
                "id": "idm540605039792",
                "info": "The calculation over all the trajectory is splitted in n_workers chunks. Then to run the code over all the trajectory you must run n_workers input files each one with a different worker_id, from 0 to n_workers - 1 . Those inputs can run at the same time in the same folder. The worker_id will be appended to the outdir folder and to the file_output input variables, so you can safely run all the inputs in the same directory at the same time."
            },
            "worker_id": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "See n_workers variable",
                "id": "idm540605035280",
                "info": "See n_workers variable"
            },
            "continue_not_converged": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If it is not possible to find a ground state for a given frame of the trajectory, go to the next one",
                "id": "idm540605033184",
                "info": "If it is not possible to find a ground state for a given frame of the trajectory, go to the next one. You will not find this step in the output file(s)."
            }
        }
    },
    "importexport_binary": {
        "inputpp": {
            "prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "prefix of input file produced by pw",
                "id": "idm528181575808",
                "info": "prefix of input file produced by pw.x (wavefunctions are not needed)"
            },
            "outdir": {
                "datatype": "string",
                "default": "value of the",
                "options": {},
                "summary": "directory containing the input data, i",
                "id": "idm528181574016",
                "info": "directory containing the input data, i.e. the same as in pw.x"
            },
            "direction": {
                "datatype": "string",
                "default": "export",
                "options": {
                    "export": "for converting the charge density from the native binary format to text XML format",
                    "import": "for converting a previously exported folder from text XML format to binary format"
                },
                "summary": "Selects the direction",
                "id": "idm528181571776",
                "info": "Selects the direction:"
            },
            "newoutdir": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "directory into which the export data is going to be generated; after the 'import' phase, it can be then used as the outdir to restart for instance a pw",
                "id": "idm528181568160",
                "info": "directory into which the export data is going to be generated; after the 'import' phase, it can be then used as the outdir to restart for instance a pw.x NSCF calculation"
            }
        }
    },
    "molecularpdos": {
        "inputmopdos": {
            "xmlfile_full": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "xml files with atomic projections ",
                "id": "idm286455446912",
                "info": "xml files with atomic projections (produced by projwfc.x) for the full system and its molecular part"
            },
            "xmlfile_part": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "xml files with atomic projections ",
                "id": "idm286455446288",
                "info": "xml files with atomic projections (produced by projwfc.x) for the full system and its molecular part"
            },
            "i_atmwfc_beg_full": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "first atomic wavefunction of the full system considered for the projection",
                "id": "idm286455445008",
                "info": "first atomic wavefunction of the full system considered for the projection"
            },
            "i_atmwfc_end_full": {
                "datatype": "integer",
                "default": "0, i.e., all atomic wavefunctions",
                "options": {},
                "summary": "last atomic wavefunction of the full system considered for the projection",
                "id": "idm286455443248",
                "info": "last atomic wavefunction of the full system considered for the projection"
            },
            "i_atmwfc_beg_part": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "first atomic wavefunction of the molecular part considered for the projection",
                "id": "idm286455441456",
                "info": "first atomic wavefunction of the molecular part considered for the projection"
            },
            "i_atmwfc_end_part": {
                "datatype": "integer",
                "default": "0, i.e., all atomic wavefunctions",
                "options": {},
                "summary": "first atomic wavefunction of the molecular part considered for the projection",
                "id": "idm286455439696",
                "info": "first atomic wavefunction of the molecular part considered for the projection"
            },
            "i_bnd_beg_full": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "first eigenstate of the full system to be taken into account for the projection",
                "id": "idm286455437904",
                "info": "first eigenstate of the full system to be taken into account for the projection"
            },
            "i_bnd_end_full": {
                "datatype": "integer",
                "default": "0, i.e., all eigenstates",
                "options": {},
                "summary": "last eigenstate of the full system to be taken into account for the projection",
                "id": "idm286455436160",
                "info": "last eigenstate of the full system to be taken into account for the projection"
            },
            "i_bnd_beg_part": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "first eigenstate of the molecular part to be taken into account for the projection",
                "id": "idm286455434384",
                "info": "first eigenstate of the molecular part to be taken into account for the projection"
            },
            "i_bnd_end_part": {
                "datatype": "integer",
                "default": "0, i.e., all eigenstates",
                "options": {},
                "summary": "last eigenstate of the molecular part to be taken into account for the projection",
                "id": "idm286455432640",
                "info": "last eigenstate of the molecular part to be taken into account for the projection"
            },
            "fileout": {
                "datatype": "string",
                "default": "molecularpdos",
                "options": {},
                "summary": "prefix for output files containing molecular PDOS",
                "id": "idm286455430864",
                "info": "prefix for output files containing molecular PDOS(E)"
            },
            "ngauss": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "Type of gaussian broadening",
                "id": "idm286455429184",
                "info": "Type of gaussian broadening:     0 ... Simple Gaussian (default)     1 ... Methfessel-Paxton of order 1    -1 ... \"cold smearing\" (Marzari-Vanderbilt-DeVita-Payne)   -99 ... Fermi-Dirac function"
            },
            "degauss": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "gaussian broadening, Ry ",
                "id": "idm286455427296",
                "info": "gaussian broadening, Ry (not eV!)"
            },
            "Emin": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "min & max energy ",
                "id": "idm286455425104",
                "info": "min & max energy (eV) for DOS plot"
            },
            "Emax": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "min & max energy ",
                "id": "idm286455424480",
                "info": "min & max energy (eV) for DOS plot"
            },
            "DeltaE": {
                "datatype": "real",
                "default": "0.01",
                "options": {},
                "summary": "energy grid step ",
                "id": "idm286455422816",
                "info": "energy grid step (eV)"
            },
            "kresolveddos": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "if ",
                "id": "idm286455421120",
                "info": "if .true. the k-resolved DOS is computed: not summed over all k-points but written as a function of the k-point index. In this case all k-point weights are set to unity"
            }
        }
    },
    "ppacf": {
        "ppacf": {
            "prefix": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "prefix of files saved by program pw",
                "id": "idm204599404800",
                "info": "prefix of files saved by program pw.x prepended to input/output filenames: prefix.ecnl, prefix.tcnl, etc."
            },
            "outdir": {
                "datatype": "string",
                "default": "value of the",
                "options": {},
                "summary": "directory containing the output data from pw",
                "id": "idm204599403360",
                "info": "directory containing the output data from pw.x, i.e. the same as in pw.x"
            },
            "n_lambda": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "Number of fragments in coupling",
                "id": "idm204599401104",
                "info": "Number of fragments in coupling-constant scaling curve. In the default case, only $\\lambda=0$ and $\\lambda=1$ ends are calculated."
            },
            "lplot": {
                "datatype": "boolean",
                "default": ".False.",
                "options": {},
                "summary": "If ",
                "id": "idm204599399312",
                "info": "If .True. print out the spatial distribution of energy density. prefix.tclda             the LDA component of kinetic-correlation energy density. prefix.tcnl(prefix.tcgc) the non-local (gradient corrected) component of kinetic-correlation energy density. prefix.exlda             the LDA component of exchange energy density. prefix.eclda             the LDA component of correlation energy density. prefix.exgc              the gradient-corrected component of exchange energy density. prefix.ecnl(prefix.ecgc) the non-local(gradient-corrected) component of correlation energy density. prefix.vcnl                  If vdW-DF: the non-local correlation-potential variation (at nspin=1). prefix.vcnl1,2                 If spin-vdW-DF: spin-reolved non-local correlation-potential variations."
            },
            "lfock": {
                "datatype": "boolean",
                "default": ".False.",
                "options": {},
                "summary": "If ",
                "id": "idm204599393392",
                "info": "If .True. calculate the Fock exchange based on input Kohn-Sham orbitals."
            },
            "code_num": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "Select from which code to read output files",
                "id": "idm204599387584",
                "info": "Select from which code to read output files.   1 = Quantum ESPRESSO   2 = VASP       The codes will read vasprun.xml and CHGCAR from VASP       calculations.       Please note that in VASP-based analysis:       - Core charge is ignored.       - The ppacf-from-VASP-read-in only works for VASP         calculations done in PBE, revPBE, vdW-DF, vdW-DF2, or vdW-DF-cx       - The ppacf-from-VASP-read-in only always uses the full Ecnl kernel         for coupling-constant scaling analysis of vdW-DF versions.       - Wavefunction based analysis (Fock exchange energy and         Kohn-Sham kinetic energy) are not available from VASP       - When lplot = .True., the code will also print out         charge density in prefix.chg (prefix.chg1 and prefix.chg2         save the spin-up and spin-down components in case of         spin-polarized calculations), which can be processed by pp.x."
            },
            "vdW_analysis": {
                "datatype": "integer",
                "default": "o",
                "options": {},
                "summary": "Select type of vdw kernel table used in ppacf coupling",
                "id": "idm204599384240",
                "info": "Select type of vdw kernel table used in ppacf coupling-constant scaling analysis of nonlocal-correlations in vdW-DF versions: - vdW_analysis = 0: Full Ecnl kenel of vdW-DF method - vdW_analysis = 1: The cumulant- or susceptibility-Ecnl kernel component - vdW_analysis = 2: The pure-vdW-Ecnl kernel component See IOP JCPM (2020) for presentation of the latter two (non-default) options"
            }
        }
    },
    "dynmat": {
        "input": {
            "fildyn": {
                "datatype": "string",
                "default": "matdyn",
                "options": {},
                "summary": "input file containing the dynamical matrix",
                "id": "idm431494492064",
                "info": "input file containing the dynamical matrix"
            },
            "q": {
                "datatype": "realarray (3)",
                "default": "q = (0,0,0)",
                "options": {},
                "summary": "calculate LO modes ",
                "id": "idm431494490304",
                "info": "calculate LO modes (add non-analytic terms) along the direction q (Cartesian axis)"
            },
            "amass": {
                "datatype": "realarray (ntyp)",
                "default": "amass is read from file fildyn",
                "options": {},
                "summary": "mass for each atom type",
                "id": "idm431494488016",
                "info": "mass for each atom type"
            },
            "asr": {
                "datatype": "string",
                "default": "no",
                "options": {
                    "no": "no Acoustic Sum Rules imposed (default)",
                    "simple": "previous implementation of the asr used (3 translational asr imposed by correction of  the diagonal elements of the dynamical matrix)",
                    "crystal": "3 translational asr imposed by optimized correction of the dyn. matrix (projection)",
                    "one-dim": "3 translational asr + 1 rotational asr imposed by optimized correction of the dyn. mat. (the rotation axis is the direction of periodicity; it will work only if this axis considered is one of the Cartesian axis).",
                    "zero-dim": "3 translational asr + 3 rotational asr imposed by optimized correction of the dyn. mat."
                },
                "summary": "Indicates the type of Acoustic Sum Rule imposed",
                "id": "idm431494485440",
                "info": "Indicates the type of Acoustic Sum Rule imposed.  Allowed values:"
            },
            "remove_interaction_blocks": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm431494477872",
                "info": "If .true. lines and rows corresponding to atoms that are not displaced are set to 0. This can be used for ph.x calculations with nat_todo set in ph.x, to remove the interaction between the diplaced and fixed parts of the system."
            },
            "axis": {
                "datatype": "integer",
                "default": "3",
                "options": {},
                "summary": "indicates the rotation axis for a 1D system ",
                "id": "idm431494475952",
                "info": "indicates the rotation axis for a 1D system (1=Ox, 2=Oy, 3=Oz)"
            },
            "lperm": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "if ",
                "id": "idm431494474224",
                "info": "if .true. then calculate Gamma-point mode contributions to dielectric permittivity tensor"
            },
            "lplasma": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "if ",
                "id": "idm431494472448",
                "info": "if .true. then calculate Gamma-point mode effective plasma frequencies, automatically triggers lperm = .true."
            },
            "filout": {
                "datatype": "string",
                "default": "dynmat.out",
                "options": {},
                "summary": "output file containing phonon frequencies and normalized phonon displacements ",
                "id": "idm431494470240",
                "info": "output file containing phonon frequencies and normalized phonon displacements (i.e. eigenvectors divided by the square root of the mass and then normalized; they are not orthogonal)"
            },
            "fileig": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "output file containing phonon frequencies and eigenvectors of the dynamical matrix ",
                "id": "idm431494468368",
                "info": "output file containing phonon frequencies and eigenvectors of the dynamical matrix (they are orthogonal)"
            },
            "filmol": {
                "datatype": "string",
                "default": "dynmat.mold",
                "options": {},
                "summary": "as above, in a format suitable for molden",
                "id": "idm431494466576",
                "info": "as above, in a format suitable for molden"
            },
            "filxsf": {
                "datatype": "string",
                "default": "dynmat.axsf",
                "options": {},
                "summary": "as above, in axsf format suitable for xcrysden",
                "id": "idm431494464832",
                "info": "as above, in axsf format suitable for xcrysden"
            },
            "loto_2d": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "set to ",
                "id": "idm431494463088",
                "info": "set to .true. to activate two-dimensional treatment of LO-TO splitting."
            },
            "el_ph_nsig": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "The number of double",
                "id": "idm431494461328",
                "info": "The number of double-delta smearing values used in an electron-phonon coupling calculation."
            },
            "el_ph_sigma": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "The spacing of double",
                "id": "idm431494459968",
                "info": "The spacing of double-delta smearing values used in an electron-phonon coupling calculation."
            }
        }
    },
    "davidson": {
        "lr_input": {
            "prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "Sets the prefix for generated and read files",
                "id": "idm310656582240",
                "info": "Sets the prefix for generated and read files. The files generated by the ground state pw.x run should have this same prefix."
            },
            "outdir": {
                "datatype": "string",
                "default": "./",
                "options": {},
                "summary": "The directory that contains the run critical files, which include the files generated by ground state pw",
                "id": "idm310656580400",
                "info": "The directory that contains the run critical files, which include the files generated by ground state pw.x run."
            },
            "wfcdir": {
                "datatype": "string",
                "default": "./",
                "options": {},
                "summary": "The directory that contains the run critical files, which include the files generated by ground state pw",
                "id": "idm310656578608",
                "info": "The directory that contains the run critical files, which include the files generated by ground state pw.x run."
            },
            "max_seconds": {
                "datatype": "real",
                "default": "1.D+7, or 150 days, i.e. no time limit",
                "options": {},
                "summary": "jobs stops after max_seconds CPU time",
                "id": "idm310656576816",
                "info": "jobs stops after max_seconds CPU time. Use this option in conjunction with option restart if you need to split a job too long to complete into shorter jobs that fit into your batch queues."
            },
            "restart": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When set to ",
                "id": "idm310656574176",
                "info": "When set to .true., turbo_davidson.x will attempt to restart from a previous interrupted calculation if max_seconds was specified. Beware, if set to .false. turbo_davidson.x will OVERWRITE any previous runs."
            },
            "lr_verbosity": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "This integer variable controls the amount of information written to standard output",
                "id": "idm310656571888",
                "info": "This integer variable controls the amount of information written to standard output."
            },
            "disk_io": {
                "datatype": "string",
                "default": "default",
                "options": {},
                "summary": "Fine control of disk usage",
                "id": "idm310656570144",
                "info": "Fine control of disk usage. Currently only 'reduced' is supported where no restart files are written, apart from the 'default' mode."
            }
        },
        "lr_dav": {
            "num_eign": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "Number of eigenstates to be calculated",
                "id": "idm310656567520",
                "info": "Number of eigenstates to be calculated."
            },
            "num_init": {
                "datatype": "integer",
                "default": "2",
                "options": {},
                "summary": "Number of trial vectors",
                "id": "idm310656565808",
                "info": "Number of trial vectors. Usually it is twice as large as the number of eigenstates to be calculated (see num_eign)."
            },
            "if_random_init": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When set to ",
                "id": "idm310656563632",
                "info": "When set to .true. trial vectors are chosen randomly, otherwise they are guessed from the ground-state calculation. If p_nbnd_occ * p_nbnd_virt < num_init, this term is forced to be .true. The usage of random trial vectors should cause only a slower convergence, and do not affect the final results."
            },
            "num_basis_max": {
                "datatype": "integer",
                "default": "20",
                "options": {},
                "summary": "Maximum number of basis vectors allowed in the subspace",
                "id": "idm310656560464",
                "info": "Maximum number of basis vectors allowed in the subspace. When this number is reached, a discharging routine is called. The memory requirement of the Davidson algorithm is mainly determined by this variable (an estimation of the memory is reported at the beginning of the run)."
            },
            "residue_conv_thr": {
                "datatype": "real",
                "default": "1.0E-4",
                "options": {},
                "summary": "Threshold for the convergence",
                "id": "idm310656558528",
                "info": "Threshold for the convergence. When the square of the residue is smaller than this value, the convergence is achieved."
            },
            "precondition": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "If set to ",
                "id": "idm310656556704",
                "info": "If set to .true. a precondition is used. At this moment, one sees no reason why not to use the precondition."
            },
            "single_pole": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "A slightly better way to set the initial trial vectors, but the improvement is really small",
                "id": "idm310656554912",
                "info": "A slightly better way to set the initial trial vectors, but the improvement is really small. Currently this flag can be used only with LDA/PBE + NC PPs. So do not use it unless it is really necessary."
            },
            "if_dft_spectrum": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When set to ",
                "id": "idm310656553024",
                "info": "When set to .true. the independent particle approximation is used, i.e. the Hartree and exchange-correlation response contributions are neglected."
            },
            "reference": {
                "datatype": "real",
                "default": "0.0d0",
                "options": {},
                "summary": "Reference energy in units of Ry",
                "id": "idm310656551200",
                "info": "Reference energy in units of Ry. This variable is used to constrain the Davidson algorithm to converge the eigenstates having the energy closest to the reference energy. In this way one can calculate less eigenstates at once, and to perform multiple calculations with different reference energies (the post-processing code tddfpt_calculate_spectrum.x can be used for this purpose)."
            },
            "broadening": {
                "datatype": "real",
                "default": "0.005d0",
                "options": {},
                "summary": "Lorentzian broadening ",
                "id": "idm310656549136",
                "info": "Lorentzian broadening (Ry) to broaden the absorption spectrum."
            },
            "start": {
                "datatype": "real",
                "default": "0.0d0",
                "options": {},
                "summary": "The lower limit of the energy ",
                "id": "idm310656547392",
                "info": "The lower limit of the energy (Ry) scale for the spectrum calculation."
            },
            "finish": {
                "datatype": "real",
                "default": "1.0d0",
                "options": {},
                "summary": "The upper limit of the energy ",
                "id": "idm310656545632",
                "info": "The upper limit of the energy (Ry) scale for the spectrum calculation."
            },
            "step": {
                "datatype": "real",
                "default": "0.001d0",
                "options": {},
                "summary": "Energy step ",
                "id": "idm310656543872",
                "info": "Energy step (Ry) for the spectrum calculation."
            },
            "p_nbnd_occ": {
                "datatype": "integer",
                "default": "10",
                "options": {},
                "summary": "Number of occupied states selected from the total number of occupied states computed by PWscf",
                "id": "idm310656542144",
                "info": "Number of occupied states selected from the total number of occupied states computed by PWscf. This variable is useful if there are too many occupied states but your are interested in only some of them. In priciple this variable and p_nbnd_virt affect only the interpretation of the eigenstates, but do not effect their energy and the final absorption spectrum. Make sure that min(p_nbnd_occ,nbnd_occ)*min(p_nbnd_virt,nbnd_virt) is lager than the number of initial vectors (num_init), so you will not end up using random trial vectors which would slow down the convergence."
            },
            "p_nbnd_virt": {
                "datatype": "integer",
                "default": "10",
                "options": {},
                "summary": "Number of empty states selected from the total number of empty states computed by PWscf",
                "id": "idm310656539104",
                "info": "Number of empty states selected from the total number of empty states computed by PWscf. This variable is useful if there are too many empty states but your are interested in only some of them. In priciple this variable and p_nbnd_occ affect only the interpretation of the eigenstates, but do not effect their energy and the final absorption spectrum. Make sure that min(p_nbnd_occ,nbnd_occ)*min(p_nbnd_virt,nbnd_virt) is lager than the number of initial vectors (num_init), so you will not end up using random trial vectors which would slow down the convergence."
            },
            "poor_of_ram": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "Use this variable if you do not have enough RAM ",
                "id": "idm310656536064",
                "info": "Use this variable if you do not have enough RAM (only USPP), i.e. set it to .true. When this variable is set to .false., you double the memory used for the USPP calculation, but you increase a speed of the calculation by getting rid of applying many times of s_psi and cal_bec in the calculation, which takes a lot of time (sometimes more than a half of the whole calculation) when the size of the subspace is more than 100."
            },
            "poor_of_ram2": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "Use this variable if you do not have enough RAM ",
                "id": "idm310656533952",
                "info": "Use this variable if you do not have enough RAM (NCPP and USPP), i.e. set it to .true. When this variable is set to .false., you double the memory used for the calculation, but you increase a speed of the calculation by storing D_ and C_ basis: the calculation will be speeded up a lot when one is calculating many transitions at the same time."
            },
            "max_iter": {
                "datatype": "integer",
                "default": "100",
                "options": {},
                "summary": "Maximum number of Davidson iterations allowed",
                "id": "idm310656531920",
                "info": "Maximum number of Davidson iterations allowed. When the number of iterations arrives this number, the calculation will stop even if the convergence has not been achieved."
            },
            "no_hxc": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When set to ",
                "id": "idm310656530080",
                "info": "When set to .true. the change in the internal field (Hartree and exchange-correlation) is ignored in the calculation, resulting in the independent electron approximation."
            },
            "pseudo_hermitian": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "When set to ",
                "id": "idm310656528224",
                "info": "When set to .true. the pseudo-Hermitian Lanczos algorithm is used. When set to .false. the non-Hermitian Lanczos biorthogonalization algorithm is used (which is two times slower)."
            },
            "ltammd": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When set to ",
                "id": "idm310656526352",
                "info": "When set to .true. the Tamm-Dancoff approximation is used in constructing the Liouvillian."
            },
            "lplot_drho": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When set to ",
                "id": "idm310656524576",
                "info": "When set to .true. the turbo_davidson.x code will write files for each eigenstate \"drho-of-eign-$i\" which are needed to plot the response charge-density at each resonance. This implies a calculation using the pp.x post-processing program with the corresponding input file which must be prepared. See example \"H2O-PLOTRHO\"."
            },
            "d0psi_rs": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When set to ",
                "id": "idm310656522144",
                "info": "When set to .true. the dipole is computed in the real space. When set to .false. the dipole is computed in the reciprocal space by computing [H,r]. Note, currently the commutator does not contain a contribution for hybrids [V_EXX,r]. See also the variable lshift_d0psi. Important: Treatment of the dipole in the real space is allowed only if the system is finite."
            },
            "lshift_d0psi": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "This variable is used only when d0psi_rs = ",
                "id": "idm310656519696",
                "info": "This variable is used only when d0psi_rs = .true. a) If a molecule is placed in the corner of the supercell, there is a discontinuity problem for the position operator r, which is not periodic. By setting lshift_d0psi = .true. the discontinuity problem is solved by shifting the position operator r such that it is continuous and well defined. b) If a molecule is placed in the center of the supercell, there is no discontinuity problem for the position operator r, and thus you can set lshift_d0psi = .false. But if you still set it to .true., this will not harm, because the position operator will basically remain as it is, since it is always centered wrt the center of the molecule."
            }
        }
    },
    "bgw2pw": {
        "input_bgw2pw": {
            "prefix": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "prefix of files saved by program pw",
                "id": "idm170298389360",
                "info": "prefix of files saved by program pw.x"
            },
            "outdir": {
                "datatype": "string",
                "default": "./",
                "options": {},
                "summary": "the scratch directory where the massive data",
                "id": "idm170298387568",
                "info": "the scratch directory where the massive data-files are written"
            },
            "real_or_complex": {
                "datatype": "integer",
                "default": "2",
                "options": {},
                "summary": "1 | 2 1 for real flavor of BerkeleyGW ",
                "id": "idm170298385824",
                "info": "1 | 2 1 for real flavor of BerkeleyGW (for systems with inversion symmetry and time-reversal symmetry) or 2 for complex flavor of BerkeleyGW (for systems without inversion symmetry and time-reversal symmetry)"
            },
            "wfng_flag": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "read wavefunctions in G",
                "id": "idm170298383104",
                "info": "read wavefunctions in G-space from BerkeleyGW WFN file"
            },
            "wfng_file": {
                "datatype": "string",
                "default": "WFN",
                "options": {},
                "summary": "name of BerkeleyGW WFN input file",
                "id": "idm170298381360",
                "info": "name of BerkeleyGW WFN input file. Not used if wfng_flag = .FALSE."
            },
            "wfng_nband": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "number of bands to write ",
                "id": "idm170298379184",
                "info": "number of bands to write (0 = all). Not used if wfng_flag = .FALSE."
            },
            "rhog_flag": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "read charge density in G",
                "id": "idm170298377040",
                "info": "read charge density in G-space from BerkeleyGW RHO file"
            },
            "rhog_file": {
                "datatype": "string",
                "default": "RHO",
                "options": {},
                "summary": "name of BerkeleyGW RHO input file",
                "id": "idm170298375296",
                "info": "name of BerkeleyGW RHO input file. Not used if rhog_flag = .FALSE."
            }
        }
    },
    "matdyn": {
        "input": {
            "flfrc": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "File produced by q2r containing force constants ",
                "id": "idm499752581344",
                "info": "File produced by q2r containing force constants (needed) It is the same as in the input of q2r.x (+ the .xml extension if the dynamical matrices produced by ph.x were in xml format). No default value: must be specified."
            },
            "asr": {
                "datatype": "string",
                "default": "no",
                "options": {
                    "no": "no Acoustic Sum Rules imposed (default)",
                    "simple": "previous implementation of the asr used (3 translational asr imposed by correction of  the diagonal elements of the force constants matrix)",
                    "crystal": "3 translational asr imposed by optimized correction of the force constants (projection)",
                    "one-dim": "3 translational asr + 1 rotational asr imposed by optimized correction of the dyn. mat. (the rotation axis is the direction of periodicity; it will work only if this axis considered is one of the Cartesian axis).",
                    "zero-dim": "3 translational asr + 3 rotational asr imposed by optimized correction of the dyn. mat."
                },
                "summary": "Indicates the type of Acoustic Sum Rule imposed",
                "id": "idm499752578992",
                "info": "Indicates the type of Acoustic Sum Rule imposed.  Allowed values:"
            },
            "dos": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "if ",
                "id": "idm499752572368",
                "info": "if .true. calculate phonon Density of States (DOS) using tetrahedra and a uniform q-point grid (see below) NB: may not work properly in noncubic materials  if .false. calculate phonon bands from the list of q-points supplied in input (default)"
            },
            "nk1": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "uniform q",
                "id": "idm499752569136",
                "info": "uniform q-point grid for DOS calculation (includes q=0) (must be specified if dos = .true., ignored otherwise)"
            },
            "nk2": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "uniform q",
                "id": "idm499752568496",
                "info": "uniform q-point grid for DOS calculation (includes q=0) (must be specified if dos = .true., ignored otherwise)"
            },
            "nk3": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "uniform q",
                "id": "idm499752567888",
                "info": "uniform q-point grid for DOS calculation (includes q=0) (must be specified if dos = .true., ignored otherwise)"
            },
            "deltaE": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "energy step, in cm",
                "id": "idm499752566256",
                "info": "energy step, in cm"
            },
            "ndos": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "number of energy steps for DOS calculations ",
                "id": "idm499752564032",
                "info": "number of energy steps for DOS calculations (default: calculated from deltaE if not specified)"
            },
            "degauss": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "DOS broadening in cm",
                "id": "idm499752562672",
                "info": "DOS broadening in cm"
            },
            "fldos": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "output file for dos ",
                "id": "idm499752560960",
                "info": "output file for dos (default:"
            },
            "flfrq": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "output file for frequencies ",
                "id": "idm499752558752",
                "info": "output file for frequencies (default:"
            },
            "flvec": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "output file for normalized phonon displacements ",
                "id": "idm499752557040",
                "info": "output file for normalized phonon displacements (default:"
            },
            "fleig": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "output file for phonon eigenvectors ",
                "id": "idm499752555152",
                "info": "output file for phonon eigenvectors (default:"
            },
            "fldyn": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "output file for dynamical matrix ",
                "id": "idm499752553328",
                "info": "output file for dynamical matrix (default: ' ' i.e. not written)"
            },
            "at": {
                "datatype": "realarray (3,3)",
                "default": "",
                "options": {},
                "summary": "supercell lattice vectors ",
                "id": "idm499752551920",
                "info": "supercell lattice vectors - must form a superlattice of the original lattice (default: use original cell)"
            },
            "l1": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "supercell lattice vectors are original cell vectors times l1, l2, l3 respectively ",
                "id": "idm499752549360",
                "info": "supercell lattice vectors are original cell vectors times l1, l2, l3 respectively (default: 1, ignored if at specified)"
            },
            "l2": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "supercell lattice vectors are original cell vectors times l1, l2, l3 respectively ",
                "id": "idm499752548752",
                "info": "supercell lattice vectors are original cell vectors times l1, l2, l3 respectively (default: 1, ignored if at specified)"
            },
            "l3": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "supercell lattice vectors are original cell vectors times l1, l2, l3 respectively ",
                "id": "idm499752548144",
                "info": "supercell lattice vectors are original cell vectors times l1, l2, l3 respectively (default: 1, ignored if at specified)"
            },
            "ntyp": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "number of atom types in the supercell ",
                "id": "idm499752546496",
                "info": "number of atom types in the supercell (default: ntyp of the original cell)"
            },
            "amass": {
                "datatype": "realarray (ntyp)",
                "default": "",
                "options": {},
                "summary": "masses of atoms in the supercell ",
                "id": "idm499752544704",
                "info": "masses of atoms in the supercell (a.m.u.), one per atom type (default: use masses read from file"
            },
            "readtau": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "read  atomic positions of the supercell from input ",
                "id": "idm499752542448",
                "info": "read  atomic positions of the supercell from input (used to specify different masses) (default:"
            },
            "fltau": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "write atomic positions of the supercell to file",
                "id": "idm499752540688",
                "info": "write atomic positions of the supercell to file"
            },
            "la2F": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "if ",
                "id": "idm499752538480",
                "info": "if .true. interpolates also the el-ph coefficients"
            },
            "q_in_band_form": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "if ",
                "id": "idm499752536752",
                "info": "if .true. the q points are given in band form: only the first and last point of one or more lines are given. See below. (default:"
            },
            "q_in_cryst_coord": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "if ",
                "id": "idm499752534560",
                "info": "if .true. input q points are in crystalline coordinates (default:"
            },
            "eigen_similarity": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "use similarity of the displacements to order frequencies  ",
                "id": "idm499752532416",
                "info": "use similarity of the displacements to order frequencies  (default:"
            },
            "fd": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "if ",
                "id": "idm499752530208",
                "info": "if .true. the ifc come from the finite displacement calculation"
            },
            "na_ifc": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "add non analitic contributions to the interatomic force constants if finite displacement method is used ",
                "id": "idm499752528480",
                "info": "add non analitic contributions to the interatomic force constants if finite displacement method is used (as in Wang et al. PRB 85, 224303 (2012) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.85.224303)) [to be used in conjunction with fd.x]"
            },
            "nosym": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "if ",
                "id": "idm499752525904",
                "info": "if .true., no symmetry and no time reversal are imposed"
            },
            "loto_2d": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "set to ",
                "id": "idm499752524176",
                "info": "set to .true. to activate two-dimensional treatment of LO-TO splitting"
            },
            "loto_disable": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "if ",
                "id": "idm499752522432",
                "info": "if .true. do not apply LO-TO splitting for q=0 (default:"
            }
        }
    },
    "ph": {
        "inputph": {
            "amass": {
                "datatype": "realarray (ntyp)",
                "default": "0.0",
                "options": {},
                "summary": "Atomic mass [amu] of each atomic type",
                "id": "idm367707500288",
                "info": "Atomic mass [amu] of each atomic type. If not specified, masses are read from data file."
            },
            "outdir": {
                "datatype": "string",
                "default": "value of the",
                "options": {},
                "summary": "Directory containing input, output, and scratch files; must be the same as specified in the calculation of the unperturbed system",
                "id": "idm367707498032",
                "info": "Directory containing input, output, and scratch files; must be the same as specified in the calculation of the unperturbed system."
            },
            "prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "Prepended to input/output filenames; must be the same used in the calculation of unperturbed system",
                "id": "idm367707495344",
                "info": "Prepended to input/output filenames; must be the same used in the calculation of unperturbed system."
            },
            "niter_ph": {
                "datatype": "integer",
                "default": "maxter=100",
                "options": {},
                "summary": "Maximum number of iterations in a scf step",
                "id": "idm367707493568",
                "info": "Maximum number of iterations in a scf step. If you want more than 100, edit variable \"maxter\" in PH/phcom.f90"
            },
            "tr2_ph": {
                "datatype": "real",
                "default": "1e-12",
                "options": {},
                "summary": "Threshold for self",
                "id": "idm367707491760",
                "info": "Threshold for self-consistency."
            },
            "alpha_mix(niter)": {
                "datatype": "real",
                "default": "alpha_mix(1)=0.7",
                "options": {},
                "summary": "Mixing factor ",
                "id": "#",
                "info": "Mixing factor (for each iteration) for updating the scf potential:  vnew(in) = alpha_mix*vold(out) + (1-alpha_mix)*vold(in)"
            },
            "nmix_ph": {
                "datatype": "integer",
                "default": "4",
                "options": {},
                "summary": "Number of iterations used in potential mixing",
                "id": "idm367707488224",
                "info": "Number of iterations used in potential mixing. Using a larger value (8~20) can significantly speed up convergence, at the cost of using more memory."
            },
            "verbosity": {
                "datatype": "string",
                "default": "default",
                "options": {
                    "debug', 'high', 'medium": "verbose output",
                    "low', 'default', 'minimal": "short output"
                },
                "summary": "Options are",
                "id": "idm367707486416",
                "info": "Options are:"
            },
            "reduce_io": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "Reduce I/O to the strict minimum",
                "id": "idm367707482928",
                "info": "Reduce I/O to the strict minimum.  BEWARE: If the input flag reduce_io=.true. was used, it is not allowed to restart from an interrupted run."
            },
            "max_seconds": {
                "datatype": "real",
                "default": "1.d7",
                "options": {},
                "summary": "Maximum allowed run time before the job stops smoothly",
                "id": "idm367707480288",
                "info": "Maximum allowed run time before the job stops smoothly."
            },
            "fildyn": {
                "datatype": "string",
                "default": "matdyn",
                "options": {},
                "summary": "File where the dynamical matrix is written",
                "id": "idm367707478560",
                "info": "File where the dynamical matrix is written."
            },
            "fildrho": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "File where the charge density responses are written",
                "id": "idm367707476832",
                "info": "File where the charge density responses are written. Note that the file will actually be saved as ${outdir}/_ph0/${prefix}.${fildrho}1 where  ${outdir}, ${prefix} and ${fildrho} are the values of the corresponding input variables"
            },
            "fildvscf": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "File where the the potential variation is written ",
                "id": "idm367707473296",
                "info": "File where the the potential variation is written (for later use in electron-phonon calculation, see also fildrho)."
            },
            "epsil": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707471504",
                "info": "If .true. in a q=0 calculation for a non metal the macroscopic dielectric constant of the system is computed. Do not set epsil to .true. if you have a metallic system or q/=0: the code will complain and stop.  Note: the input value of epsil will be ignored if ldisp=.true. (the code will automatically set epsil to .false. for metals, to .true. for insulators: see routine PHonon/PH/prepare_q.f90)."
            },
            "lrpa": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707467808",
                "info": "If .true. the dielectric constant is calculated at the RPA level with DV_xc=0."
            },
            "lnoloc": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707466048",
                "info": "If .true. the dielectric constant is calculated without local fields, i.e. by setting DV_H=0 and DV_xc=0."
            },
            "trans": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "If ",
                "id": "idm367707464256",
                "info": "If .false. the phonons are not computed. If trans .and. epsil are both .true., the effective charges are calculated. If ldisp is .true., trans=.false. is overridden (except for the case of electron-phonon calculations)"
            },
            "lraman": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707460752",
                "info": "If .true. calculate non-resonant Raman coefficients using second-order response as in: M. Lazzeri and F. Mauri, PRL 90, 036401 (2003) (https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.90.036401)."
            },
            "eth_rps": {
                "datatype": "real",
                "default": "1.0d-9",
                "options": {},
                "summary": "Threshold for calculation of  Pc R |psi>",
                "id": "idm367707457504",
                "info": "Threshold for calculation of  Pc R |psi>."
            },
            "eth_ns": {
                "datatype": "real",
                "default": "1.0e-12",
                "options": {},
                "summary": "Threshold for non",
                "id": "idm367707455744",
                "info": "Threshold for non-scf wavefunction calculation."
            },
            "dek": {
                "datatype": "real",
                "default": "1.0e-3",
                "options": {},
                "summary": "Delta_xk used for wavefunction derivation wrt k",
                "id": "idm367707454016",
                "info": "Delta_xk used for wavefunction derivation wrt k."
            },
            "recover": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707452176",
                "info": "If .true. restart from an interrupted run."
            },
            "low_directory_check": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707450448",
                "info": "If .true. search in the phsave directory only the                  quantities requested in input."
            },
            "only_init": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707448656",
                "info": "If .true. only the bands and other initialization quantities are calculated. (used for GRID parallelization)"
            },
            "qplot": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707446864",
                "info": "If .true. a list of q points is read from input."
            },
            "q2d": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707445136",
                "info": "If .true. three q points and relative weights are read from input. The three q points define the rectangle q(:,1) + l (q(:,2)-q(:,1)) + m (q(:,3)-q(:,1)) where 0< l,m < 1. The weights are integer and those of points two and three are the number of points in the two directions."
            },
            "q_in_band_form": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "This flag is used only when qplot is ",
                "id": "idm367707442944",
                "info": "This flag is used only when qplot is .true. and q2d is .false.. When .true. each couple of q points q(:,i+1) and q(:,i) define the line from q(:,i) to q(:,i+1) and nq points are generated along that line. nq is the weigth of q(:,i). When .false. only the list of q points given as input is calculated. The weights are not used."
            },
            "electron_phonon": {
                "datatype": "string",
                "default": " ",
                "options": {
                    "simple": "Electron-phonon lambda coefficients are computed for a given q and a grid of k-points specified by the variables nk1, nk2, nk3, k1, k2, k3.",
                    "interpolated": "Electron-phonon is calculated by interpolation over the Brillouin Zone as in M. Wierzbowska, et al. arXiv:cond-mat/0504077 (https://arxiv.org/abs/cond-mat/0504077)",
                    "lambda_tetra": "The electron-phonon coefficient \\lambda_{q \\nu} is calculated with the optimized tetrahedron method.",
                    "gamma_tetra": "The phonon linewidth \\gamma_{q \\nu} is calculated from the electron-phonon interactions using the optimized tetrahedron method.",
                    "epa": "Electron-phonon coupling matrix elements are written to file prefix.epa.k for further processing by program epa.x which implements electron-phonon averaged (EPA) approximation as described in G. Samsonidze & B. Kozinsky, Adv. Energy Mater. 2018, 1800246 doi:10.1002/aenm.201800246 (https://doi.org/10.1002/aenm.201800246) arXiv:1511.08115 (https://arxiv.org/abs/1511.08115)",
                    "ahc": "Quantities required for the calculation of phonon-induced electron self-energy are computed and written to the directory ahc_dir. The output files can be read by postahc.x for the calculation of electron self-energy. Available for both metals and insulators. trans=.false. is required."
                },
                "summary": "Options are",
                "id": "idm367707440928",
                "info": "Options are:"
            },
            "el_ph_nsigma": {
                "datatype": "integer",
                "default": "10",
                "options": {},
                "summary": "The number of double",
                "id": "idm367707426512",
                "info": "The number of double-delta smearing values used in an electron-phonon coupling calculation."
            },
            "el_ph_sigma": {
                "datatype": "real",
                "default": "0.02",
                "options": {},
                "summary": "The spacing between double",
                "id": "idm367707424752",
                "info": "The spacing between double-delta smearing values used in an electron-phonon coupling calculation."
            },
            "ahc_dir": {
                "datatype": "string",
                "default": "outdir // 'ahc_dir/'",
                "options": {},
                "summary": "Directory where the output binary files are written",
                "id": "idm367707421888",
                "info": "Directory where the output binary files are written."
            },
            "ahc_nbnd": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Number of bands for which the electron self",
                "id": "idm367707420096",
                "info": "Number of bands for which the electron self-energy is to be computed."
            },
            "ahc_nbndskip": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "Number of bands to exclude when computing the self",
                "id": "idm367707418304",
                "info": "Number of bands to exclude when computing the self-energy. Self-energy is computed for bands with indices from ahc_nbndskip+1 to ahc_nbndskip+ahc_nbnd. ahc_nbndskip+ahc_nbnd cannot exceed nbnd of the preceding SCF or NSCF calculation."
            },
            "skip_upperfan": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707414368",
                "info": "If .true., skip calculation of the upper Fan self-energy, which involves solving the Sternheimer equation."
            },
            "lshift_q": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "Use a wave",
                "id": "idm367707412448",
                "info": "Use a wave-vector grid displaced by half a grid step in each direction - meaningful only when ldisp is .true. When this option is set, the q2r.x code cannot be used."
            },
            "zeu": {
                "datatype": "boolean",
                "default": "zeu=epsil",
                "options": {},
                "summary": "If ",
                "id": "idm367707410592",
                "info": "If .true. in a q=0 calculation for a non metal the effective charges are computed from the dielectric response. This is the default algorithm. If epsil=.true. and zeu=.false. only the dielectric tensor is calculated."
            },
            "zue": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707407536",
                "info": "If .true. in a q=0 calculation for a non metal the effective charges are computed from the phonon density responses. This is an alternative algorithm, different from the default one (if trans .and. epsil ) The results should be the same within numerical noise."
            },
            "elop": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707404768",
                "info": "If .true. calculate electro-optic tensor."
            },
            "fpol": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707403040",
                "info": "If .true. calculate dynamic polarizabilities Requires epsil=.true. ( experimental stage: see example09 for calculation of methane )."
            },
            "ldisp": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707400816",
                "info": "If .true. the run calculates phonons for a grid of q-points specified by nq1, nq2, nq3 - for direct calculation of the entire phonon dispersion."
            },
            "nogg": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707397776",
                "info": "If .true. disable the \"gamma_gamma\" trick used to speed up calculations at q=0 (phonon wavevector) if the sum over the Brillouin Zone includes k=0 only. The gamma_gamma trick exploits symmetry and acoustic sum rule to reduce the number of linear response calculations to the strict minimum, as it is done in code phcg.x."
            },
            "asr": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "Apply Acoustic Sum Rule to dynamical matrix, effective charges Works only in conjunction with \"gamma_gamma\" tricks ",
                "id": "idm367707395408",
                "info": "Apply Acoustic Sum Rule to dynamical matrix, effective charges Works only in conjunction with \"gamma_gamma\" tricks (see above)"
            },
            "ldiag": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707393552",
                "info": "If .true. forces the diagonalization of the dynamical matrix also when only a part of the dynamical matrix has been calculated. It is used together with start_irr and last_irr. If all modes corresponding to a given irreducible representation have been calculated, the phonon frequencies of that representation are correct. The others are zero or wrong. Use with care."
            },
            "lqdir": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707390704",
                "info": "If .true. ph.x creates inside outdir a separate subdirectory for each q vector. The flag is set to .true. when ldisp=.true. and fildvscf /= ' ' or when an electron-phonon calculation is performed. The induced potential is saved separately for each q inside the subdirectories."
            },
            "search_sym": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "Set it to ",
                "id": "idm367707387776",
                "info": "Set it to .false. if you want to disable the mode symmetry analysis."
            },
            "nq1": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Parameters of the Monkhorst",
                "id": "idm367707385504",
                "info": "Parameters of the Monkhorst-Pack grid (no offset) used when ldisp=.true. Same meaning as for nk1, nk2, nk3 in the input of pw.x."
            },
            "nq2": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Parameters of the Monkhorst",
                "id": "idm367707384896",
                "info": "Parameters of the Monkhorst-Pack grid (no offset) used when ldisp=.true. Same meaning as for nk1, nk2, nk3 in the input of pw.x."
            },
            "nq3": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Parameters of the Monkhorst",
                "id": "idm367707384288",
                "info": "Parameters of the Monkhorst-Pack grid (no offset) used when ldisp=.true. Same meaning as for nk1, nk2, nk3 in the input of pw.x."
            },
            "nk1": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "When these parameters are specified the phonon program runs a pw non",
                "id": "idm367707381712",
                "info": "When these parameters are specified the phonon program runs a pw non-self consistent calculation with a different k-point grid thant that used for the charge density. This occurs even in the Gamma case. nk1, nk2, nk3 are the parameters of the Monkhorst-Pack grid with offset determined by k1, k2, k3."
            },
            "nk2": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "When these parameters are specified the phonon program runs a pw non",
                "id": "idm367707381104",
                "info": "When these parameters are specified the phonon program runs a pw non-self consistent calculation with a different k-point grid thant that used for the charge density. This occurs even in the Gamma case. nk1, nk2, nk3 are the parameters of the Monkhorst-Pack grid with offset determined by k1, k2, k3."
            },
            "nk3": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "When these parameters are specified the phonon program runs a pw non",
                "id": "idm367707380496",
                "info": "When these parameters are specified the phonon program runs a pw non-self consistent calculation with a different k-point grid thant that used for the charge density. This occurs even in the Gamma case. nk1, nk2, nk3 are the parameters of the Monkhorst-Pack grid with offset determined by k1, k2, k3."
            },
            "k1": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "When these parameters are specified the phonon program runs a pw non",
                "id": "idm367707379888",
                "info": "When these parameters are specified the phonon program runs a pw non-self consistent calculation with a different k-point grid thant that used for the charge density. This occurs even in the Gamma case. nk1, nk2, nk3 are the parameters of the Monkhorst-Pack grid with offset determined by k1, k2, k3."
            },
            "k2": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "When these parameters are specified the phonon program runs a pw non",
                "id": "idm367707379280",
                "info": "When these parameters are specified the phonon program runs a pw non-self consistent calculation with a different k-point grid thant that used for the charge density. This occurs even in the Gamma case. nk1, nk2, nk3 are the parameters of the Monkhorst-Pack grid with offset determined by k1, k2, k3."
            },
            "k3": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "When these parameters are specified the phonon program runs a pw non",
                "id": "idm367707378672",
                "info": "When these parameters are specified the phonon program runs a pw non-self consistent calculation with a different k-point grid thant that used for the charge density. This occurs even in the Gamma case. nk1, nk2, nk3 are the parameters of the Monkhorst-Pack grid with offset determined by k1, k2, k3."
            },
            "diagonalization": {
                "datatype": "string",
                "default": "david",
                "options": {
                    "david": "Davidson iterative diagonalization with overlap matrix (default). Fast, may in some rare cases fail.",
                    "cg": "Conjugate-gradient-like band-by-band diagonalization. Slower than 'david' but uses less memory and is (a little bit) more robust."
                },
                "summary": "Diagonalization method for the non",
                "id": "idm367707374528",
                "info": "Diagonalization method for the non-SCF calculations."
            },
            "read_dns_bare": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707370608",
                "info": "If .true. the PH code tries to read three files in the DFPT+U calculation: dns_orth, dns_bare, d2ns_bare. dns_orth and dns_bare are the first-order variations of the occupation matrix, while d2ns_bare is the second-order variation of the occupation matrix. These matrices are computed only once during the DFPT+U calculation. However, their calculation (especially of d2ns_bare) is computationally expensive, this is why they are written to file and then can be read (e.g. for restart) in order to save time."
            },
            "ldvscf_interpolate": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707368416",
                "info": "If .true., use Fourier interpolation of phonon potential to compute the induced part of phonon potential at each q point. Results of a dvscf_q2r.x run is needed. Requires trans = .false.."
            },
            "wpot_dir": {
                "datatype": "string",
                "default": "outdir // 'w_pot/'",
                "options": {},
                "summary": "Directory where the w_pot binary files are written",
                "id": "idm367707365600",
                "info": "Directory where the w_pot binary files are written. Must be the same with wpot_dir used in dvscf_q2r.x. The real space potential files are stored in wpot_dir with names ${prefix}.wpot.irc${irc}//\"1\"."
            },
            "do_long_range": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707362848",
                "info": "If .true., add the long-range part of the potential to the Fourier interpolated potential as in: S. Ponce et al, J. Chem. Phys. 143, 102813 (2015). Reads dielectric matrix and Born effective charges from the ${wpot_dir}/tensors.dat file, written in dvscf_q2r.x. Currently, only the dipole (Frohlich) part is implemented. The quadrupole part is not implemented."
            },
            "do_charge_neutral": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm367707360800",
                "info": "If .true., impose charge neutrality on the Born effective charges. Used only if do_long_range = .true.."
            },
            "start_irr": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "Perform calculations only from start_irr to last_irr irreducible representations",
                "id": "idm367707357760",
                "info": "Perform calculations only from start_irr to last_irr irreducible representations.  IMPORTANT:    * start_irr must be <= 3*nat    * do not specify nat_todo together with      start_irr, last_irr"
            },
            "last_irr": {
                "datatype": "integer",
                "default": "3*nat",
                "options": {},
                "summary": "Perform calculations only from start_irr to last_irr irreducible representations",
                "id": "idm367707353040",
                "info": "Perform calculations only from start_irr to last_irr irreducible representations.  IMPORTANT:    * start_irr must be <= 3*nat    * do not specify nat_todo together with      start_irr, last_irr"
            },
            "nat_todo": {
                "datatype": "integer",
                "default": "0, i.e. displace all atoms",
                "options": {},
                "summary": "Choose the subset of atoms to be used in the linear response calculation",
                "id": "idm367707348304",
                "info": "Choose the subset of atoms to be used in the linear response calculation: nat_todo atoms, specified in input (see below) are displaced. Can be used to estimate modes for a molecule adsorbed over a surface without performing a full fledged calculation. Use with care, at your own risk, and be aware that this is an approximation and may not work. IMPORTANT:    * nat_todo <= nat    * if linear-response is calculated for a given atom, it      should also be done for all symmetry-equivalent atoms,      or else you will get incorrect results"
            },
            "modenum": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "For single",
                "id": "idm367707345072",
                "info": "For single-mode phonon calculation : modenum is the index of the irreducible representation (irrep) into which the reducible representation formed by the 3*nat atomic displacements are decomposed in order to perform the phonon calculation. Note that a single-mode calculation will not give you the frequency of a single phonon mode: in general, the selected \"modenum\" is not an eigenvector. What you get on output is a column of the dynamical matrix."
            },
            "start_q": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "Used only when ldisp=",
                "id": "idm367707341872",
                "info": "Used only when ldisp=.true.. Computes only the q points from start_q to last_q.  IMPORTANT:    * start_q must be <= nqs (number of q points found)    * do not specify nat_todo together with      start_q, last_q"
            },
            "last_q": {
                "datatype": "integer",
                "default": "number of q points",
                "options": {},
                "summary": "Used only when ldisp=",
                "id": "idm367707336784",
                "info": "Used only when ldisp=.true.. Computes only the q points from start_q to last_q.  IMPORTANT    * last_q must be <= nqs (number of q points)    * do not specify nat_todo together with      start_q, last_q"
            },
            "dvscf_star": {
                "datatype": "structure",
                "default": "disabled",
                "options": {},
                "summary": "It contains the following components",
                "id": "idm367707331264",
                "info": "It contains the following components:  dvscf_star%open  (logical, default: .false.) dvscf_star%dir   (character, default: outdir//\"Rotated_DVSCF\" or the                   ESPRESSO_FILDVSCF_DIR environment variable) dvscf_star%ext   (character, default: \"dvscf\") the extension to use                   for the name of the output files, see below dvscf_star%basis (character, default: \"cartesian\") the basis on which                   the rotated dvscf will be saved dvscf_star%pat   (logical, default: false) save an optional file with the                   displacement patterns and q vector for each dvscf file  IF dvscf_star%open is .true. use symmetry to compute and store the variation of the self-consistent potential on every q* in the star of the present q.  The rotated dvscf will then be stored in directory dvscf_star%dir with name prefix.dvscf_star%ext.q_name//\"1\". Where q_name is derived from the coordinates of the q-point, expressed as fractions in crystalline coordinates (notice that ph.x reads q-points in cartesian coordinates). E.g. q_cryst= (0, 0.5, -0.25) -> q_name = \"0_1o2_-1o4\"  The dvscf can be represented on a basis of cartesian 1-atom displacements (dvscf_star%basis='cartesian') or on the basis of the modes at the rotated q-point (dvscf_star%basis='modes'). Notice that the el-ph wannier code requires 'cartesian'. Each dvscf file comes with a corresponding pattern file with an additional \".pat\" suffix; this file contains information about the basis and the q-point of the dvscf.  Note: rotating dvscf can require a large amount of RAM memory and can be i/o       intensive; in its current implementation all the operations are done       on a single processor. Note2: this feature is currently untested with image parallelisation."
            },
            "drho_star": {
                "datatype": "structure",
                "default": "disabled",
                "options": {},
                "summary": "It contains the following components",
                "id": "idm367707326688",
                "info": "It contains the following components:  drho_star%open  (logical, default: .false.) drho_star%dir   (character, default: outdir//\"Rotated_DRHO\" or the                  ESPRESSO_FILDRHO_DIR environment variable) drho_star%ext   (character, default: \"drho\") the extension to use                  for the name of the output files, see below drho_star%basis (character, default: \"modes\") the basis on which                  the rotated drho will be saved drho_star%pat   (logical, default: true) save an optional file with the                  displacement patterns and q vector for each drho file  Like dvscf_star, but for the perturbation of the charge density. Notice that the defaults are different."
            }
        }
    },
    "kcw": {
        "control": {
            "prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "Prepended to input/output filenames; must be the same used in the previous PW calculations",
                "id": "idm6602063568",
                "info": "Prepended to input/output filenames; must be the same used in the previous PW calculations."
            },
            "outdir": {
                "datatype": "string",
                "default": "current directory ('./')",
                "options": {},
                "summary": "Directory containing input, output, and scratch files; must be the same as specified in the calculation of previous PW calculation",
                "id": "idm6602061728",
                "info": "Directory containing input, output, and scratch files; must be the same as specified in the calculation of previous PW calculation."
            },
            "calculation": {
                "datatype": "string",
                "default": " ",
                "options": {
                    "wann2kcw": "Pre-processing to prepare KCW calculation. Read previous PWSCF and possibly W90 outputs and prepare the KCW calculation",
                    "screen": "Performe the calculation of KCW screening coefficient using a LR approach as described here",
                    "ham": "Performe the calculation interpolation and diagonalization of of KI hamiltonian"
                },
                "summary": "Specify the KCW calculation to be done Possible choices",
                "id": "idm6602059904",
                "info": "Specify the KCW calculation to be done Possible choices:"
            },
            "kcw_iverbosity": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "= 0 ",
                "id": "idm6602054336",
                "info": "= 0 : minimal output = 1 : as above + performs additional checks. > 1 : as above + additional infos on all the steps."
            },
            "kcw_at_ks": {
                "datatype": "boolean",
                "default": ".TRUE.",
                "options": {},
                "summary": "If true the KS canonical orbitals are used instead of Wannier functions",
                "id": "idm6602052544",
                "info": "If true the KS canonical orbitals are used instead of Wannier functions. It makes sense for isolated system only."
            },
            "read_unitary_matrix": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If true read the Unitary matrix written by Wannier90",
                "id": "idm6602050752",
                "info": "If true read the Unitary matrix written by Wannier90. Implicitely means a previous wannier90 calculation was performed and a KCW calculation will be performed starting from MLWF. Requires 'write_hr = .true.' in wannier90."
            },
            "spread_thr": {
                "datatype": "real",
                "default": "0.001 Ry",
                "options": {},
                "summary": "NOT IMPLMENTED YET",
                "id": "idm6602048688",
                "info": "NOT IMPLMENTED YET. Two or more Wannier functions are considered identical if their spread (self-hartree) differ by less than spread_thr. Requires check_spread = .true."
            },
            "homo_only": {
                "datatype": "boolean",
                "default": "FALSE",
                "options": {},
                "summary": "If kcw_at_ks = ",
                "id": "idm6602046432",
                "info": "If kcw_at_ks = .TRUE. only the screening paramenter for the HOMO is calculated. Mainly for a perturbative calculation of the first Ionization Potential in isolated systems."
            },
            "l_vcut": {
                "datatype": "boolean",
                "default": "FALSE",
                "options": {},
                "summary": "If ",
                "id": "idm6602044176",
                "info": "If .TRUE. the Gygi-Baldereschi scheme is used to deal with the q->0 divergence of the Coulomb integral (bare and screened). Improves the convergence wrt k/q-point sampling. Requires to correctly set eps_inf for the calculation of the screened interaction.  Use it only for periodic system. For isoleted system use assume_isolated, instead."
            },
            "assume_isolated": {
                "datatype": "string",
                "default": "none",
                "options": {
                    "none": "(default): regular periodic calculation w/o any correction.",
                    "martyna-tuckerman', 'm-t', 'mt": "Martyna-Tuckerman correction to both total energy and scf potential. Adapted from: G.J. Martyna, and M.E. Tuckerman, \"A reciprocal space based method for treating long range interactions in ab-initio and force-field-based calculation in clusters\", J. Chem. Phys. 110, 2810 (1999), doi:10.1063/1.477923 (https://doi.org/10.1063/1.477923)."
                },
                "summary": "Used to perform calculation assuming the system to be isolated ",
                "id": "idm6602041024",
                "info": "Used to perform calculation assuming the system to be isolated (a molecule or a cluster in a 3D supercell).  Currently available choices:"
            },
            "spin_component": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "Which spin channel to calculate ",
                "id": "idm6602036016",
                "info": "Which spin channel to calculate (only collinear calculation). 1 = spin up channel 2 = spin down channel It has to be consistent with the previous Wannier90 calculation (see 'spin' keyword in Wannier90 documentation)"
            },
            "mp1": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Parameters of the Monkhorst",
                "id": "idm6602033488",
                "info": "Parameters of the Monkhorst-Pack grid (no offset). Same meaning as for nk1, nk2, nk3 in the input of pw.x. It has to coincide with the regular mesh used for the wannier90 calculation."
            },
            "mp2": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Parameters of the Monkhorst",
                "id": "idm6602032880",
                "info": "Parameters of the Monkhorst-Pack grid (no offset). Same meaning as for nk1, nk2, nk3 in the input of pw.x. It has to coincide with the regular mesh used for the wannier90 calculation."
            },
            "mp3": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Parameters of the Monkhorst",
                "id": "idm6602032240",
                "info": "Parameters of the Monkhorst-Pack grid (no offset). Same meaning as for nk1, nk2, nk3 in the input of pw.x. It has to coincide with the regular mesh used for the wannier90 calculation."
            },
            "lrpa": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm6602030496",
                "info": "If .true. the response function is computed neglecting xc effects both in the kernel and in the response function (RPA)."
            }
        },
        "wannier": {
            "seedname": {
                "datatype": "string",
                "default": "wann",
                "options": {},
                "summary": "The ",
                "id": "idm6602028064",
                "info": "The seedname of the previous Wannier90 calculation for occupied states. NOTA BENE: the code implicitely assumed that the seedname for empty state is the same as that for occupied state with \"_emp\" appended. Keep this in mind when set up the wannier90 inputs.  For example: wann.win         is the wannier90 input file for the occupied states. wann_emp.win     is the wannier90 input file for the empty states."
            },
            "num_wann_occ": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "The number of wannier function for the occupied manifold",
                "id": "idm6602026416",
                "info": "The number of wannier function for the occupied manifold. It has to coincide with the number of occupied KS orbitals. The whole KS manifold has to be wannierised (no 'exclude_band' option for occupied state, at the moment)."
            },
            "num_wann_emp": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "The number of wannier function for the empty manifold",
                "id": "idm6602024416",
                "info": "The number of wannier function for the empty manifold. It has to coincide with the number of empty wannier function from the previous wannier90 calculation"
            },
            "have_empty": {
                "datatype": "boolean",
                "default": "FALSE",
                "options": {},
                "summary": "If true empty state are computed",
                "id": "idm6602022592",
                "info": "If true empty state are computed. Require a previous wannier90 calculation for the empty manifold. The code search for the unitary matrices in the wannier90 file seedname_emp_u.mat"
            },
            "has_disentangle": {
                "datatype": "boolean",
                "default": "FALSE",
                "options": {},
                "summary": "Specify if a disentangle unitary matrix needs to be read",
                "id": "idm6602020736",
                "info": "Specify if a disentangle unitary matrix needs to be read. Requires a consisten calcuation from the previous wannier90 run."
            },
            "check_ks": {
                "datatype": "boolean",
                "default": "FALSE",
                "options": {},
                "summary": "Specify if a diagonalization of the KS matrix build using the wannier function in input has to be performed",
                "id": "idm6602018928",
                "info": "Specify if a diagonalization of the KS matrix build using the wannier function in input has to be performed. This is mainly for debugging purpose."
            }
        },
        "screen": {
            "niter": {
                "datatype": "integer",
                "default": "maxter=100",
                "options": {},
                "summary": "Maximum number of iterations in a scf step",
                "id": "idm6602016480",
                "info": "Maximum number of iterations in a scf step. If you want more than 100, edit variable \"maxter\" in PH/phcom.f90"
            },
            "nmix": {
                "datatype": "integer",
                "default": "4",
                "options": {},
                "summary": "Number of iterations used in potential mixing",
                "id": "idm6602014640",
                "info": "Number of iterations used in potential mixing."
            },
            "tr2": {
                "datatype": "real",
                "default": "1e-14",
                "options": {},
                "summary": "Threshold for self",
                "id": "idm6602012928",
                "info": "Threshold for self-consistency."
            },
            "i_orb": {
                "datatype": "integer",
                "default": "-1",
                "options": {},
                "summary": "Perform the screening calculation for a particular orbital",
                "id": "idm6602011232",
                "info": "Perform the screening calculation for a particular orbital. If i_orb = -1 (default) all the orbitals are computed. Assumes values between 1 and the total number of wannier functions."
            },
            "eps_inf": {
                "datatype": "real",
                "default": "1.d0",
                "options": {},
                "summary": "The macroscopic dielectric constant",
                "id": "idm6602009376",
                "info": "The macroscopic dielectric constant. Needed for the Gygi-Baldereschi scheme if l_vcut = .TRUE. Typically from exp or from a ph.x calculation. NOTA BENE: This would be equivalent to a Makov-Payne correction.            it is perfectly fine for cubic systems. Not so for            anisotropic dielectric matrices."
            },
            "check_spread": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm6602006992",
                "info": "If .TRUE. the spread (self-hartree) of the Wannier functions is checked and used to decide whether two or more Wannier functions can be considered \"identical\" or not. Two Wannier functions are considered identical if their spread (self-hartree) differ by less than 1e-4 Ry (Hard coded for now, see spread_thr)."
            }
        },
        "ham": {
            "do_bands": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm6602004000",
                "info": "If .true. the interpolated band structure is computed along a path secified with the K_POINTS card ( see PW documentation"
            },
            "use_ws_distance": {
                "datatype": "boolean",
                "default": ".TRUE.",
                "options": {},
                "summary": "If ",
                "id": "idm6602001744",
                "info": "If .true. the position of the Wannier function inside the cell is used to set the proper distance and to have a smoother interpolation. Requires seedname_centres.xyz to be printed by the previous Wannier90 run. If the file is not found it is automatically switched to .FALSE. and only the distance between the cells is used (see also Wannier90 documentation)"
            },
            "write_hr": {
                "datatype": "boolean",
                "default": ".TRUE.",
                "options": {},
                "summary": "If ",
                "id": "idm6601999696",
                "info": "If .true. the KCW hamiltonain in the Wannier basis and in real spase H(R)_m_n is printed to file. Usefull for furhter post-processing."
            },
            "on_site_only": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm6601997872",
                "info": "If .true. only the on-site and diagonal elements of the KCW hamiltonain are computed (R=0 and n=m)."
            }
        }
    },
    "spectrum": {
        "lr_input": {
            "prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "Sets the prefix for generated and read files",
                "id": "idm539346813536",
                "info": "Sets the prefix for generated and read files. The files generated by the ground state pw.x run should have this same prefix."
            },
            "outdir": {
                "datatype": "string",
                "default": "./",
                "options": {},
                "summary": "The directory that contains the run critical files, which include the files generated by ground state pw",
                "id": "idm539346811696",
                "info": "The directory that contains the run critical files, which include the files generated by ground state pw.x run."
            },
            "verbosity": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "This integer variable controls the amount of information written to standard output",
                "id": "idm539346809904",
                "info": "This integer variable controls the amount of information written to standard output."
            },
            "itermax0": {
                "datatype": "integer",
                "default": "500",
                "options": {},
                "summary": "Number of Lanczos coefficients to be read from the file",
                "id": "idm539346808160",
                "info": "Number of Lanczos coefficients to be read from the file."
            },
            "itermax": {
                "datatype": "integer",
                "default": "500",
                "options": {},
                "summary": "The total number of Lanczos coefficients that will be considered in the calculation of the polarizability/absorption coefficient",
                "id": "idm539346806432",
                "info": "The total number of Lanczos coefficients that will be considered in the calculation of the polarizability/absorption coefficient. If itermax > itermax0, the Lanczos coefficients in between itermax0+1 and itermax will be extrapolated."
            },
            "extrapolation": {
                "datatype": "string",
                "default": "no",
                "options": {
                    "osc": "biconstant extrapolation",
                    "constant": "constant extrapolation",
                    "no": "no extrapolation."
                },
                "summary": "Sets the extrapolation scheme",
                "id": "idm539346804496",
                "info": "Sets the extrapolation scheme."
            },
            "epsil": {
                "datatype": "real",
                "default": "0.02",
                "options": {},
                "summary": "The broadening/damping term",
                "id": "idm539346800336",
                "info": "The broadening/damping term. In Rydberg units if magnons=.false.,     in meV if magnons = .true."
            },
            "units": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "The unit system used for the output and the start, end and increment input parameters",
                "id": "idm539346798576",
                "info": "The unit system used for the output and the start, end and increment input parameters. (only meV used in that case).  0 = Rydbergs, 1 = Electron volts, 2 = Nanometres per electron volts, 3 = milli Electron volts (only for magnons=.true.)"
            },
            "start": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "The polarizability and the absorption coefficient are computed starting from this value",
                "id": "idm539346796672",
                "info": "The polarizability and the absorption coefficient are computed starting from this value. In units set."
            },
            "end": {
                "datatype": "real",
                "default": "2.5",
                "options": {},
                "summary": "The polarizability and the absorption coefficient are computed up to this value",
                "id": "idm539346794896",
                "info": "The polarizability and the absorption coefficient are computed up to this value. In units set."
            },
            "increment": {
                "datatype": "real",
                "default": "0.001",
                "options": {},
                "summary": "Incremental step used to define the mesh between start and end",
                "id": "idm539346793120",
                "info": "Incremental step used to define the mesh between start and end. In units set."
            },
            "ipol": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "An integer variable that determines which element of the dynamical polarizability will be computed",
                "id": "idm539346791360",
                "info": "An integer variable that determines which element of the dynamical polarizability will be computed: 1 -> alpha_xx(omega), 2 -> alpha_yy(omega), and 3 -> alpha_zz(omega). When set to 4, three Lanczos chains are sequentially performed and the full polarizability tensor and the absorption coefficient are computed."
            },
            "eels": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "Must be set to ",
                "id": "idm539346788944",
                "info": "Must be set to .true. for EELS. EELS-specific operations will be performed."
            },
            "magnons": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "Must be set to ",
                "id": "idm539346787184",
                "info": "Must be set to .true. for magnon-calculation post-processing."
            },
            "td": {
                "datatype": "string",
                "default": "lanczos",
                "options": {},
                "summary": "When set to 'lanczos', a calculation of the spectrum is performed using the Lanczos coefficients",
                "id": "idm539346785440",
                "info": "When set to 'lanczos', a calculation of the spectrum is performed using the Lanczos coefficients. When set to 'davidson' or 'david', a calculation of the spectrum is performed using the eigenvalues computed using the Davidson algorithm. See the variable 'eign_file'."
            },
            "eign_file": {
                "datatype": "string",
                "default": "pwscf.eigen",
                "options": {},
                "summary": "The name of the file produced by the turbo_davidson",
                "id": "idm539346783056",
                "info": "The name of the file produced by the turbo_davidson.x code, in which are written the eigenvalues."
            }
        }
    },
    "magnon": {
        "lr_input": {
            "prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "Sets the prefix for generated and read files",
                "id": "idm370414947840",
                "info": "Sets the prefix for generated and read files. The files generated by the ground state pw.x run must have this same prefix."
            },
            "outdir": {
                "datatype": "string",
                "default": "./",
                "options": {},
                "summary": "The directory that contains the run critical files, which include the files generated by ground state pw",
                "id": "idm370414946000",
                "info": "The directory that contains the run critical files, which include the files generated by ground state pw.x run."
            },
            "restart": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When set to ",
                "id": "idm370414944208",
                "info": "When set to .true., turbo_magnons.x will attempt to restart from a previous interrupted calculation. (see restart_step variable). Beware, if set to .false. turbo_magnons.x will OVERWRITE any previous runs."
            },
            "restart_step": {
                "datatype": "integer",
                "default": "itermax",
                "options": {},
                "summary": "The code writes restart files every restart_step iterations",
                "id": "idm370414942320",
                "info": "The code writes restart files every restart_step iterations. Restart files are automatically written at the end of itermax Lanczos steps."
            },
            "lr_verbosity": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "This integer variable controls the amount of information written to standard output",
                "id": "idm370414940496",
                "info": "This integer variable controls the amount of information written to standard output."
            },
            "disk_io": {
                "datatype": "string",
                "default": "default",
                "options": {},
                "summary": "Fine control of disk usage",
                "id": "idm370414938752",
                "info": "Fine control of disk usage. Currently only 'reduced' is supported where no restart files are written, apart from the 'default' mode."
            }
        },
        "lr_control": {
            "itermax": {
                "datatype": "integer",
                "default": "500",
                "options": {},
                "summary": "Number of Lanczos iterations to be performed",
                "id": "idm370414936128",
                "info": "Number of Lanczos iterations to be performed."
            },
            "pseudo_hermitian": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "When set to ",
                "id": "idm370414934480",
                "info": "When set to .true. the pseudo-Hermitian Lanczos algorithm is used. When set to .false. the non-Hermitian Lanczos biorthogonalization algorithm is used (which is two times slower)."
            },
            "approximation": {
                "datatype": "string",
                "default": "TDDFT",
                "options": {},
                "summary": "A string describing a level of theory",
                "id": "idm370414932608",
                "info": "A string describing a level of theory: 'TDDFT'            - Time-Dependent Local Density Approximation or                      Time-Dependent Generalized Gradient Approximation                      (depending on the XC functional), 'IPA'              - Independent Particle Approximation,"
            },
            "ipol": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "An integer variable that determines which element of the dynamical magnetic susceptibility will be computed",
                "id": "idm370414930400",
                "info": "An integer variable that determines which element of the dynamical magnetic susceptibility will be computed: 1 -> chi_xx(omega), 2 -> chi_yy(omega), and 3 -> chi_zz(omega). When set to 4, three Lanczos chains are sequentially performed and the full susceptibility tensor is computed."
            },
            "q1": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "The values of the transferred momentum q = ",
                "id": "idm370414927520",
                "info": "The values of the transferred momentum q = (q1, q2, q3) in Cartesian coordinates in units of 2pi/a, where \"a\" is the lattice parameter."
            },
            "q2": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "The values of the transferred momentum q = ",
                "id": "idm370414926912",
                "info": "The values of the transferred momentum q = (q1, q2, q3) in Cartesian coordinates in units of 2pi/a, where \"a\" is the lattice parameter."
            },
            "q3": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "The values of the transferred momentum q = ",
                "id": "idm370414926272",
                "info": "The values of the transferred momentum q = (q1, q2, q3) in Cartesian coordinates in units of 2pi/a, where \"a\" is the lattice parameter."
            }
        }
    },
    "pwcond": {
        "inputcond": {
            "outdir": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "temporary directory ",
                "id": "idm448833734544",
                "info": "temporary directory (as in PWscf)"
            },
            "prefixt": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "prefix for the file ",
                "id": "idm448833733216",
                "info": "prefix for the file (as in PWscf) containing all the regions (left lead + scatt. reg. + right lead)"
            },
            "prefixl": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "prefix for the file containing only the        left lead",
                "id": "idm448833731856",
                "info": "prefix for the file containing only the        left lead"
            },
            "prefixs": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "prefix for the file containing the scattering region",
                "id": "idm448833730528",
                "info": "prefix for the file containing the scattering region"
            },
            "prefixr": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "prefix for the file containing only the right lead",
                "id": "idm448833729280",
                "info": "prefix for the file containing only the right lead"
            },
            "tran_prefix": {
                "datatype": "string",
                "default": "none",
                "options": {},
                "summary": "if tran_prefix is specified the program will save partial results of a transmission calculation ",
                "id": "idm448833727968",
                "info": "if tran_prefix is specified the program will save partial results of a transmission calculation (ikind .GE. 1) in a specific directory (outdir/tran_prefix.cond_save)"
            },
            "max_seconds": {
                "datatype": "real",
                "default": "1.D+7, or 150 days, i.e. no time limit",
                "options": {},
                "summary": "jobs stops after max_seconds elapsed time ",
                "id": "idm448833725712",
                "info": "jobs stops after max_seconds elapsed time (wallclock time). It can be enabled only if tran_prefix is specified."
            },
            "recover": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "restarts a previously interrupted transmission calculation ",
                "id": "idm448833723472",
                "info": "restarts a previously interrupted transmission calculation (only if tran_prefix was specified). It can also be used to gather partial results from a calculation that was split by using start_e,last_e and/or start_k,last_k (see corresponding keywords)."
            },
            "band_file": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "file on which the complex bands are saved",
                "id": "idm448833721120",
                "info": "file on which the complex bands are saved"
            },
            "tran_file": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "file where the transmission is written",
                "id": "idm448833719808",
                "info": "file where the transmission is written"
            },
            "save_file": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "file where the data necessary for PWCOND are written so that no prefix files of PW are longer needed",
                "id": "idm448833718496",
                "info": "file where the data necessary for PWCOND are written so that no prefix files of PW are longer needed"
            },
            "fil_loc": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "file on/from which the 2D eigenvalue problem data are saved/read",
                "id": "idm448833717136",
                "info": "file on/from which the 2D eigenvalue problem data are saved/read"
            },
            "lwrite_cond": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "if ",
                "id": "idm448833715808",
                "info": "if .t. save the data necessary for PWCOND in save_file"
            },
            "loop_ek": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "if ",
                "id": "idm448833714480",
                "info": "if .t. the energy loop is outside the k-point loop"
            },
            "lread_cond": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "if ",
                "id": "idm448833713168",
                "info": "if .t. read the data necessary for PWCOND from save_file"
            },
            "lwrite_loc": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "if ",
                "id": "idm448833711840",
                "info": "if .t. save 2D eigenvalue problem result in fil_loc"
            },
            "lread_loc": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "if ",
                "id": "idm448833710528",
                "info": "if .t. read 2D eigenvalue problem result from fil_loc"
            },
            "ikind": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "The kind of conductance calculation",
                "id": "idm448833709200",
                "info": "The kind of conductance calculation:  ikind=0  - just complex band structure (CBS) calculation  ikind=1  - conductance calculation with identical            left and right leads  ikind=2  - conductance calculation with different            left and right leads"
            },
            "iofspin": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "spin index for which the calculations are performed",
                "id": "idm448833707680",
                "info": "spin index for which the calculations are performed"
            },
            "tk_plot": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "if > 0, plot T",
                "id": "idm448833706368",
                "info": "if > 0, plot T(kx,ky) at each energy in the region [tk_plot x full BZ]"
            },
            "llocal": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "if ",
                "id": "idm448833704944",
                "info": "if .t. calculations are done with only local part of PP"
            },
            "bdl": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "right boundary of the left lead ",
                "id": "idm448833703616",
                "info": "right boundary of the left lead (left one is supposed to be at 0) (in units of lattice parameter \"alat\" defined in the scf run)"
            },
            "bds": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "right boundary of the scatt",
                "id": "idm448833702176",
                "info": "right boundary of the scatt. reg. (left one is at 0 if prefixs is used and = bdl if prefixt is used) (in units of lattice parameter \"alat\" defined in the scf run)"
            },
            "bdr": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "right boundary of the right lead ",
                "id": "idm448833700672",
                "info": "right boundary of the right lead (left one is at 0 if prefixr is used and = bds if prefixt is used) (in units of lattice parameter \"alat\" defined in the scf run)"
            },
            "nz1": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "the number of subslabs in the slab ",
                "id": "idm448833699168",
                "info": "the number of subslabs in the slab (to calculate integrals)"
            },
            "energy0": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "initial energy",
                "id": "idm448833697856",
                "info": "initial energy"
            },
            "denergy": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "energy step ",
                "id": "idm448833696576",
                "info": "energy step (if denergy=0.0 the energy is read from the list)"
            },
            "nenergy": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "number of energies  WARNING",
                "id": "idm448833670448",
                "info": "number of energies  WARNING: the energy in input file is given in eV taken from Ef,          and denergy should be negative"
            },
            "start_e": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "if start_e > 1, the scattering problem is solved only for those energies with index between start_e and last_e in the energy list",
                "id": "idm448833693856",
                "info": "if start_e > 1, the scattering problem is solved only for those energies with index between start_e and last_e in the energy list.  NOTE: start_e <= last_e and start_e <= nenergy must be satisfied"
            },
            "last_e": {
                "datatype": "integer",
                "default": "nenergy",
                "options": {},
                "summary": "index of the last energy to be computed",
                "id": "idm448833691456",
                "info": "index of the last energy to be computed. If last_e > nenergy, then last_e will be automatically set to nenergy."
            },
            "start_k": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "if start_k > 1, the scattering problem is solved only for those k",
                "id": "idm448833689008",
                "info": "if start_k > 1, the scattering problem is solved only for those k-points with index between start_k and last_k in the k-point list. In order to recover the full transmission (i.e. integrated over the full Brillouin Zone) at the end, perform the partial runs specifying a value for tran_prefix (the restart directory), then put all the partial transmission files 'transmission_k#_e#' inside a unique restart directory and run pwcond.x with recover=.TRUE. (without specifying any value for start_k and last_k).  NOTE: start_k <= last_k must be satisfied and start_k must also    not be greater than the actual number of k-point in the list    (if you compute the grid automatically by specifying the grid    size and shifts, you can use kpoints.x to check that number)."
            },
            "last_k": {
                "datatype": "integer",
                "default": "nenergy",
                "options": {},
                "summary": "index of the last k",
                "id": "idm448833686944",
                "info": "index of the last k-point to be computed. If last_k is bigger than the actual number of points in the list, then it will be set to that number."
            },
            "ecut2d": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "2",
                "id": "idm448833684704",
                "info": "2-D cutoff"
            },
            "ewind": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "the energy window for reduction of 2D plane wave basis set ",
                "id": "idm448833683424",
                "info": "the energy window for reduction of 2D plane wave basis set (in XY)"
            },
            "epsproj": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "accuracy of 2D basis set reduction",
                "id": "idm448833682096",
                "info": "accuracy of 2D basis set reduction"
            },
            "orbj_in": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "the initial orbital for projecting the transmission",
                "id": "idm448833680800",
                "info": "the initial orbital for projecting the transmission"
            },
            "orbj_fin": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "the final orbital for projecting the transmission",
                "id": "idm448833679488",
                "info": "the final orbital for projecting the transmission"
            }
        }
    },
    "pprism": {
        "inputpp": {
            "prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "prefix of files saved by program pw",
                "id": "idm158764056000",
                "info": "prefix of files saved by program pw.x"
            },
            "outdir": {
                "datatype": "string",
                "default": "value of the",
                "options": {},
                "summary": "directory containing the input data, i",
                "id": "idm158764054304",
                "info": "directory containing the input data, i.e. the same as in pw.x"
            },
            "filplot": {
                "datatype": "string",
                "default": "\"prefix\".pprism",
                "options": {},
                "summary": "file \"filplot\" contains solvent's quantities ",
                "id": "idm158764052064",
                "info": "file \"filplot\" contains solvent's quantities (can be saved for further processing)"
            },
            "lpunch": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "punch solvent's quantities to fileplot, or not",
                "id": "idm158764049712",
                "info": "punch solvent's quantities to fileplot, or not"
            }
        },
        "plot": {
            "iflag": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "0 1D plot of the spherical average 1 1D plot 2 2D plot 3 3D plot 4 2D polar plot on a sphere",
                "id": "idm158764046960",
                "info": "0 1D plot of the spherical average 1 1D plot 2 2D plot 3 3D plot 4 2D polar plot on a sphere"
            },
            "output_format": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "",
                "id": "idm158764045184",
                "info": "(ignored on 1D plot)  0  = format suitable for gnuplot   (1D)  1  = obsolete format no longer supported  2  = format suitable for plotrho   (2D)  3  = format suitable for XCRYSDEN  (2D or user-supplied 3D region)  4  = obsolete format no longer supported  5  = format suitable for XCRYSDEN  (3D, using entire FFT grid)  6  = format as gaussian cube file  (3D)      (can be read by many programs)  7  = format suitable for gnuplot   (2D) x, y, f(x,y)"
            },
            "fileout": {
                "datatype": "string",
                "default": "\"prefix\".3drism",
                "options": {},
                "summary": "name of the file to which the plot is written",
                "id": "idm158764043056",
                "info": "name of the file to which the plot is written"
            },
            "interpolation": {
                "datatype": "string",
                "default": "fourier",
                "options": {
                    "fourier": "",
                    "bspline": "(EXPERIMENTAL)"
                },
                "summary": "Type of interpolation",
                "id": "idm158764040896",
                "info": "Type of interpolation:"
            }
        }
    },
    "pp": {
        "inputpp": {
            "prefix": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "prefix of files saved by program pw",
                "id": "idm341342106160",
                "info": "prefix of files saved by program pw.x"
            },
            "outdir": {
                "datatype": "string",
                "default": "value of the",
                "options": {},
                "summary": "directory containing the input data, i",
                "id": "idm341342104880",
                "info": "directory containing the input data, i.e. the same as in pw.x"
            },
            "filplot": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "file \"filplot\" contains the quantity selected by plot_num ",
                "id": "idm341342102640",
                "info": "file \"filplot\" contains the quantity selected by plot_num (can be saved for further processing)"
            },
            "plot_num": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Selects what to save in filplot",
                "id": "idm341342101168",
                "info": "Selects what to save in filplot:     0  = electron (pseudo-)charge density     1  = total potential V_bare + V_H + V_xc     2  = local ionic potential V_bare     3  = local density of states at specific energy or grid of energies         (number of states per volume, in bohr^3, per energy unit, in Ry)     4  = local density of electronic entropy     5  = STM images         Tersoff and Hamann, PRB 31, 805 (1985) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.31.805)     6  = spin polarization (rho(up)-rho(down))     7  = contribution of selected wavefunction(s) to the         (pseudo-)charge density. For norm-conserving PPs,         |psi|^2 (psi=selected wavefunction). Noncollinear case:         contribution of the given state to the charge or         to the magnetization along the direction indicated         by spin_component (0 = charge, 1 = x, 2 = y, 3 = z )     8  = electron localization function (ELF)     9  = charge density minus superposition of atomic densities     10 = integrated local density of states (ILDOS)         from emin to emax (emin, emax in eV)         if emax is not specified, emax=E_fermi     11 = the V_bare + V_H potential     12 = the sawtooth electric field potential (if present)     13 = the noncollinear magnetization.     17 = all-electron valence charge density         can be performed for PAW calculations only         requires a very dense real-space grid!     18 = The exchange and correlation magnetic field in the noncollinear case     19 = Reduced density gradient         ( J. Chem. Theory Comput. 7, 625 (2011), doi:10.1021/ct100641a (https://doi.org/10.1021/ct100641a) )         Set the isosurface between 0.3 and 0.6 to plot the         non-covalent interactions (see also plot_num = 20)     20 = Product of the electron density (charge) and the second         eigenvalue of the electron-density Hessian matrix;         used to colorize the RDG plot (plot_num = 19)     21 = all-electron charge density (valence+core).         For PAW calculations only; requires a very dense real-space grid.     22 = kinetic energy density (for meta-GGA and XDM only)    123 = DORI: density overlap regions indicator         (doi: 10.1021/ct500490b (https://doi.org/10.1021/ct500490b)) Implemented by D. Yang & Q.Liu"
            }
        },
        "plot": {
            "nfile": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "the number of data files to read",
                "id": "idm341342051024",
                "info": "the number of data files to read"
            },
            "filepp": {
                "datatype": "stringarray (nfile)",
                "default": "filepp(1)=filplot",
                "options": {},
                "summary": "nfile = 1 ",
                "id": "idm341342048656",
                "info": "nfile = 1 : file containing the quantity to be plotted nfile > 1 : see weight"
            },
            "weight": {
                "datatype": "realarray (nfile)",
                "default": "weight(1)=1.0",
                "options": {},
                "summary": "weighing factors",
                "id": "idm341342046000",
                "info": "weighing factors: assuming that rho(i) is the quantity read from filepp(i), the quantity that will be plotted is:  weight(1)*rho(1) + weight(2)*rho(2) + weight(3)*rho(3) + ..."
            },
            "iflag": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "0 = 1D plot of the spherical average 1 = 1D plot 2 = 2D plot 3 = 3D plot 4 = 2D polar plot on a sphere",
                "id": "idm341342042576",
                "info": "0 = 1D plot of the spherical average 1 = 1D plot 2 = 2D plot 3 = 3D plot 4 = 2D polar plot on a sphere"
            },
            "output_format": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "",
                "id": "idm341342041200",
                "info": "(ignored on 1D plot)  0  = format suitable for gnuplot   (1D)  1  = obsolete format no longer supported  2  = format suitable for plotrho   (2D)  3  = format suitable for XCRYSDEN  (2D or user-supplied 3D region)  4  = obsolete format no longer supported  5  = format suitable for XCRYSDEN  (3D, using entire FFT grid)  6  = format as gaussian cube file  (3D)      (can be read by many programs)  7  = format suitable for gnuplot   (2D) x, y, f(x,y)"
            },
            "fileout": {
                "datatype": "string",
                "default": "standard output",
                "options": {},
                "summary": "name of the file to which the plot is written",
                "id": "idm341342039488",
                "info": "name of the file to which the plot is written"
            },
            "interpolation": {
                "datatype": "string",
                "default": "fourier",
                "options": {
                    "fourier": "",
                    "bspline": "(EXPERIMENTAL)"
                },
                "summary": "Type of interpolation",
                "id": "idm341342037760",
                "info": "Type of interpolation:"
            }
        }
    },
    "neb": {},
    "q2r": {
        "input": {
            "fildyn": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "Input file name ",
                "id": "idm294776946160",
                "info": "Input file name (must be specified).  \"fildyn\"0 contains information on the q-point grid  \"fildyn\"1-N contain force constants C_n = C(q_n),      where n = 1,...N, where N is the number of      q-points in the irreducible brillouin zone.  Normally this should be the same as specified on input to the phonon code.  In the non collinear/spin-orbit case the files produced by ph.x are in .xml format. In this case fildyn is the same as in the phonon code + the .xml extension."
            },
            "flfrc": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "Output file containing the IFC in real space ",
                "id": "idm294776941920",
                "info": "Output file containing the IFC in real space (must be specified)"
            },
            "zasr": {
                "datatype": "string",
                "default": "no",
                "options": {
                    "no": "no Acoustic Sum Rules imposed (default)",
                    "simple": "previous implementation of the asr used (3 translational asr imposed by correction of  the diagonal elements of the force-constants matrix)",
                    "crystal": "3 translational asr imposed by optimized correction of the IFC (projection)",
                    "one-dim": "3 translational asr + 1 rotational asr imposed by optimized correction of the IFC (the rotation axis is the direction of periodicity; it will work only if this axis considered is one of the cartesian axis).",
                    "zero-dim": "3 translational asr + 3 rotational asr imposed by optimized correction of the IFC."
                },
                "summary": "Indicates the type of Acoustic Sum Rules used for the Born effective charges",
                "id": "idm294776940176",
                "info": "Indicates the type of Acoustic Sum Rules used for the Born effective charges.  Allowed values:"
            },
            "loto_2d": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "set to ",
                "id": "idm294776933504",
                "info": "set to .true. to activate two-dimensional treatment of LO-TO splitting."
            }
        }
    },
    "pw": {
        "control": {
            "calculation": {
                "datatype": "string",
                "default": "scf",
                "options": {
                    "scf": "",
                    "nscf": "",
                    "bands": "",
                    "relax": "",
                    "md": "",
                    "vc-relax": "",
                    "vc-md": ""
                },
                "summary": "A string describing the task to be performed",
                "id": "idm441963447904",
                "info": "A string describing the task to be performed. Options are:"
            },
            "title": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "reprinted on output",
                "id": "idm441963440832",
                "info": "reprinted on output."
            },
            "verbosity": {
                "datatype": "string",
                "default": "low",
                "options": {
                    "high": "",
                    "low": ""
                },
                "summary": "Currently two verbosity levels are implemented",
                "id": "idm441963439136",
                "info": "Currently two verbosity levels are implemented:"
            },
            "restart_mode": {
                "datatype": "string",
                "default": "from_scratch",
                "options": {
                    "from_scratch": "From scratch. This is the normal way to perform a PWscf calculation",
                    "restart": "From previous interrupted run. Use this switch only if you want to continue, using the same number of processors and parallelization, an interrupted calculation. Do not use to start a new one, or to perform a non-scf calculations.  Works only if the calculation was cleanly stopped using variable max_seconds, or by user request with an \"exit file\" (i.e.: create a file \"prefix\".EXIT, in directory \"outdir\"; see variables prefix, outdir). The default for startingwfc and startingpot is set to 'file'."
                },
                "summary": "Available options are",
                "id": "idm441963432928",
                "info": "Available options are:"
            },
            "wf_collect": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "OBSOLETE ",
                "id": "idm441963426832",
                "info": "OBSOLETE - NO LONGER IMPLEMENTED"
            },
            "nstep": {
                "datatype": "integer",
                "default": "1  if calculation == 'scf', 'nscf', 'bands'; 50 for the other cases",
                "options": {},
                "summary": "number of molecular",
                "id": "idm441963425536",
                "info": "number of molecular-dynamics or structural optimization steps performed in this run. If set to 0, the code performs a quick \"dry run\", stopping just after initialization. This is useful to check for input correctness and to have the summary printed. NOTE: in MD calculations, the code will perform \"nstep\" steps even if restarting from a previously interrupted calculation."
            },
            "iprint": {
                "datatype": "integer",
                "default": "write only at convergence",
                "options": {},
                "summary": "band energies are written every",
                "id": "idm441963422464",
                "info": "band energies are written every"
            },
            "tstress": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "calculate stress",
                "id": "idm441963420304",
                "info": "calculate stress. It is set to .TRUE. automatically if calculation == 'vc-md' or 'vc-relax'"
            },
            "tprnfor": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "calculate forces",
                "id": "idm441963418080",
                "info": "calculate forces. It is set to .TRUE. automatically if calculation == 'relax','md','vc-md'"
            },
            "dt": {
                "datatype": "real",
                "default": "20.D0",
                "options": {},
                "summary": "time step for molecular dynamics, in Rydberg atomic units ",
                "id": "idm441963416288",
                "info": "time step for molecular dynamics, in Rydberg atomic units (1 a.u.=4.8378 * 10^-17 s : beware, the CP code uses  Hartree atomic units, half that much!!!)"
            },
            "outdir": {
                "datatype": "string",
                "default": "value of the ESPRESSO_TMPDIR environment variable if set; current directory ('./') otherwise",
                "options": {},
                "summary": "input, temporary, output files are found in this directory, ",
                "id": "idm441963414464",
                "info": "input, temporary, output files are found in this directory, see also wfcdir"
            },
            "wfcdir": {
                "datatype": "string",
                "default": "same as outdir",
                "options": {},
                "summary": "This directory specifies where to store files generated by each processor ",
                "id": "idm441963412192",
                "info": "This directory specifies where to store files generated by each processor (*.wfc{N}, *.igk{N}, etc.). Useful for machines without a parallel file system: set wfcdir to a local file system, while outdir should be a parallel or network file system, visible to all processors. Beware: in order to restart from interrupted runs, or to perform further calculations using the produced data files, you may need to copy files to outdir. Works only for pw.x."
            },
            "prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "prepended to input/output filenames",
                "id": "idm441963408480",
                "info": "prepended to input/output filenames: prefix.wfc, prefix.rho, etc."
            },
            "lkpoint_dir": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "OBSOLETE ",
                "id": "idm441963406736",
                "info": "OBSOLETE - NO LONGER IMPLEMENTED"
            },
            "max_seconds": {
                "datatype": "real",
                "default": "1.D+7, or 150 days, i.e. no time limit",
                "options": {},
                "summary": "Jobs stops after max_seconds CPU time",
                "id": "idm441963405440",
                "info": "Jobs stops after max_seconds CPU time. Use this option in conjunction with option restart_mode if you need to split a job too long to complete into shorter jobs that fit into your batch queues."
            },
            "etot_conv_thr": {
                "datatype": "real",
                "default": "1.0D-4",
                "options": {},
                "summary": "Convergence threshold on total energy ",
                "id": "idm441963402736",
                "info": "Convergence threshold on total energy (a.u) for ionic minimization: the convergence criterion is satisfied when the total energy changes less than etot_conv_thr between two consecutive scf steps. Note that etot_conv_thr is extensive, like the total energy. See also forc_conv_thr - both criteria must be satisfied"
            },
            "forc_conv_thr": {
                "datatype": "real",
                "default": "1.0D-3",
                "options": {},
                "summary": "Convergence threshold on forces ",
                "id": "idm441963399568",
                "info": "Convergence threshold on forces (a.u) for ionic minimization: the convergence criterion is satisfied when all components of all forces are smaller than forc_conv_thr. See also etot_conv_thr - both criteria must be satisfied"
            },
            "disk_io": {
                "datatype": "string",
                "default": "see below",
                "options": {
                    "high": "save charge to disk at each SCF step, keep wavefunctions on disk (in \"distributed\" format), save mixing data as well. Do not use this option unless you have a good reason! It is no longer needed to specify 'high' in order to be able to restart from an interrupted calculation (see restart_mode)",
                    "medium": "save charge to disk at each SCF step, keep wavefunctions on disk only if more than one k-point, per process is present, otherwise keep them in memory; save them to disk only at the end (in \"portable\" format)",
                    "low": "save charge to disk at each SCF step, keep wavefunctions in memory (for all k-points), save them to disk only at the end (in \"portable\" format). Reduces I/O but increases memory wrt the previous cases",
                    "nowf": "save to disk only the xml data file, never save wavefunctions and charge density",
                    "none": "do not save anything to disk"
                },
                "summary": "Specifies the amount of disk I/O activity",
                "id": "idm441963396880",
                "info": "Specifies the amount of disk I/O activity: (only for binary files and xml data file in data directory; other files printed at each molecular dynamics / structural optimization step are not controlled by this option )"
            },
            "pseudo_dir": {
                "datatype": "string",
                "default": "value of the $ESPRESSO_PSEUDO environment variable if set; '$HOME/espresso/pseudo/' otherwise",
                "options": {},
                "summary": "directory containing pseudopotential files",
                "id": "idm441963388000",
                "info": "directory containing pseudopotential files"
            },
            "tefield": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441963386176",
                "info": "If .TRUE. a saw-like potential simulating an electric field is added to the bare ionic potential. See variables edir, eamp, emaxpos, eopreg for the form and size of the added potential."
            },
            "dipfield": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441963382720",
                "info": "If .TRUE. and tefield==.TRUE. a dipole correction is also added to the bare ionic potential - implements the recipe of L. Bengtsson, PRB 59, 12301 (1999) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.59.12301). See variables edir, emaxpos, eopreg for the form of the correction. Must be used ONLY in a slab geometry, for surface calculations, with the discontinuity FALLING IN THE EMPTY SPACE."
            },
            "lelfield": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441963378384",
                "info": "If .TRUE. a homogeneous finite electric field described through the modern theory of the polarization is applied. This is different from tefield == .true. !"
            },
            "nberrycyc": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "In the case of a finite electric field  ",
                "id": "idm441963376144",
                "info": "In the case of a finite electric field  ( lelfield == .TRUE. ) it defines the number of iterations for converging the wavefunctions in the electric field Hamiltonian, for each external iteration on the charge density"
            },
            "lorbm": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441963373856",
                "info": "If .TRUE. perform orbital magnetization calculation. If finite electric field is applied (lelfield==.true.) only Kubo terms are computed [for details see New J. Phys. 12, 053032 (2010), doi:10.1088/1367-2630/12/5/053032 (https://doi.org/10.1088/1367-2630/12/5/053032)].  The type of calculation is 'nscf' and should be performed on an automatically generated uniform grid of k points.  Works ONLY with norm-conserving pseudopotentials."
            },
            "lberry": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441963369904",
                "info": "If .TRUE. perform a Berry phase calculation. See the header of PW/src/bp_c_phase.f90 for documentation."
            },
            "gdir": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "For Berry phase calculation",
                "id": "idm441963368112",
                "info": "For Berry phase calculation: direction of the k-point strings in reciprocal space. Allowed values: 1, 2, 3 1=first, 2=second, 3=third reciprocal lattice vector For calculations with finite electric fields (lelfield==.true.) \"gdir\" is the direction of the field."
            },
            "nppstr": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "For Berry phase calculation",
                "id": "idm441963366112",
                "info": "For Berry phase calculation: number of k-points to be calculated along each symmetry-reduced string. The same for calculation with finite electric fields (lelfield==.true.)."
            },
            "gate": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "In the case of charged cells ",
                "id": "idm441963364272",
                "info": "In the case of charged cells (tot_charge .ne. 0) setting gate = .TRUE. represents the counter charge (i.e. -tot_charge) not by a homogeneous background charge but with a charged plate, which is placed at zgate (see below). Details of the gate potential can be found in T. Brumme, M. Calandra, F. Mauri; PRB 89, 245406 (2014) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.89.245406). Note, that in systems which are not symmetric with respect to the plate, one needs to enable the dipole correction! (dipfield=.true.). Currently, symmetry can be used with gate=.true. but carefully check that no symmetry is included which maps"
            },
            "lfcp": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441963358160",
                "info": "If .TRUE. perform a constant bias potential (constant-mu) calculation for a system with ESM method. See the header of PW/src/fcp_module.f90 for documentation. To perform the calculation, you must set a namelist FCP.  NB: - The total energy displayed in output includes the potentiostat   contribution (-mu*N). - calculation must be 'relax' or 'md'. - assume_isolated = 'esm' and esm_bc = 'bc2' or 'bc3' must be set   in SYSTEM namelist. - ESM-RISM is also supported (assume_isolated = 'esm' and esm_bc = 'bc1'   and trism = .TRUE.). - ignore_wolfe is always .TRUE., for BFGS."
            },
            "trism": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441963352608",
                "info": "If .TRUE. perform a 3D-RISM-SCF calculation [for details see H.Sato et al., JCP 112, 9463 (2000), doi:10.1063/1.481564 (https://doi.org/10.1063/1.481564)]. The solvent's distributions are calculated by 3D-RISM, though solute is treated as SCF. The charge density and the atomic positions are optimized, simultaneously with the solvents. To perform the calculation, you must set a namelist RISM and a card SOLVENTS.  If assume_isolated = 'esm' and esm_bc = 'bc1', Laue-RISM is calculated instead of 3D-RISM and coupled with ESM method (i.e. ESM-RISM). [for details see S.Nishihara and M.Otani, PRB 96, 115429 (2017) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.96.115429)].  The default of mixing_beta is 0.2 for both 3D-RISM and Laue-RISM.  For structural relaxation with BFGS, ignore_wolfe is always .TRUE. ."
            }
        },
        "system": {
            "ibrav": {
                "datatype": "integer",
                "default": "",
                "options": {
                    "0": "Lattice in CELL_PARAMETERS",
                    "1": "Cubic P (sc) lattice",
                    "2": "Cubic F (fcc) lattice",
                    "3": "Cubic I (bcc) lattice",
                    "-3": "Cubic I (bcc) lattice",
                    "4": "Hexagonal and Trigonal P lattice",
                    "5": "Trigonal Rhombohedral lattice, 3-fold axis c",
                    "-5": "Trigonal Rhombohedral lattice, 3-fold axis <111>",
                    "6": "Tetragonal P (st) lattice",
                    "7": "Tetragonal I (bct) lattice",
                    "8": "Orthorhombic P lattice",
                    "9": "Orthorhombic base-centered(bco) lattice",
                    "-9": "Orthorhombic base-centered(bco) lattice",
                    "91": "Orthorhombic one-face base-centered A-type lattice",
                    "10": "Orthorhombic face-centered lattice",
                    "11": "Orthorhombic body-centered lattice",
                    "12": "Monoclinic P, unique axis c lattice",
                    "-12": "Monoclinic P, unique axis b lattice",
                    "13": "Monoclinic base-centered lattice",
                    "-13": "Monoclinic base-centered lattice",
                    "14": "Triclinic lattice"
                },
                "summary": "Bravais lattice choice",
                "id": "idm441963345392",
                "info": "Bravais lattice choice"
            },
            "celldm": {
                "datatype": "realarray (6)",
                "default": "",
                "options": {},
                "summary": "Crystallographic constants ",
                "id": "idm441963335920",
                "info": "Crystallographic constants - see the ibrav variable. Specify either these OR A,B,C,cosAB,cosBC,cosAC NOT both. Only needed values (depending on \"ibrav\") must be specified alat = celldm(1) is the lattice parameter \"a\" (in BOHR) If ibrav==0, only celldm(1) is used if present; cell vectors are read from card CELL_PARAMETERS"
            },
            "A": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "a in ANGSTROM",
                "id": "idm441963328512",
                "info": "a in ANGSTROM"
            },
            "B": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "b in ANGSTROM",
                "id": "idm441963327904",
                "info": "b in ANGSTROM"
            },
            "C": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "c in ANGSTROM",
                "id": "idm441963327296",
                "info": "c in ANGSTROM"
            },
            "cosAB": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "cos angle between a and b ",
                "id": "idm441963326688",
                "info": "cos angle between a and b (gamma)"
            },
            "cosAC": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Traditional crystallographic constants",
                "id": "idm441963326080",
                "info": "Traditional crystallographic constants:    a,b,c in ANGSTROM   cosAB = cosine of the angle between axis a and b (gamma)   cosAC = cosine of the angle between axis a and c (beta)   cosBC = cosine of the angle between axis b and c (alpha)  The axis are chosen according to the value of ibrav. Specify either these OR celldm but NOT both. Only needed values (depending on ibrav) must be specified.  The lattice parameter alat = A (in ANGSTROM ).  If ibrav == 0, only A is used if present, and cell vectors are read from card CELL_PARAMETERS."
            },
            "cosBC": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "cos angle between b and c ",
                "id": "idm441963325472",
                "info": "cos angle between b and c (alpha)"
            },
            "nat": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "number of atoms in the unit cell ",
                "id": "idm441963321408",
                "info": "number of atoms in the unit cell (ALL atoms, except if space_group is set, in which case, INEQUIVALENT atoms)"
            },
            "ntyp": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "number of types of atoms in the unit cell",
                "id": "idm441963319632",
                "info": "number of types of atoms in the unit cell"
            },
            "nbnd": {
                "datatype": "integer",
                "default": "for an insulator, nbnd = number of valence bands (nbnd = # of electrons /2);",
                "options": {},
                "summary": "Number of electronic states ",
                "id": "idm441963317904",
                "info": "Number of electronic states (bands) to be calculated. Note that in spin-polarized calculations the number of k-point, not the number of bands per k-point, is doubled"
            },
            "tot_charge": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "Total charge of the system",
                "id": "idm441963314864",
                "info": "Total charge of the system. Useful for simulations with charged cells. By default the unit cell is assumed to be neutral (tot_charge=0). tot_charge=+1 means one electron missing from the system, tot_charge=-1 means one additional electron, and so on.  In a periodic calculation a compensating jellium background is inserted to remove divergences if the cell is not neutral."
            },
            "starting_charge": {
                "datatype": "realarray (ntyp)",
                "default": "0.0",
                "options": {},
                "summary": "starting charge on atomic type 'i', to create starting potential with startingpot = 'atomic'",
                "id": "idm441963312816",
                "info": "starting charge on atomic type 'i', to create starting potential with startingpot = 'atomic'."
            },
            "tot_magnetization": {
                "datatype": "real",
                "default": "-10000 [unspecified]",
                "options": {},
                "summary": "Total majority spin charge ",
                "id": "idm441963310064",
                "info": "Total majority spin charge - minority spin charge. Used to impose a specific total electronic magnetization. If unspecified then tot_magnetization variable is ignored and the amount of electronic magnetization is determined during the self-consistent cycle."
            },
            "starting_magnetization": {
                "datatype": "realarray (ntyp)",
                "default": "0",
                "options": {},
                "summary": "Starting spin polarization on atomic type 'i' in a spin polarized ",
                "id": "idm441963308112",
                "info": "Starting spin polarization on atomic type 'i' in a spin polarized (LSDA or noncollinear/spin-orbit) calculation. Allowed values range between -1 (all spins down for the valence electrons of atom type 'i') to 1 (all spins up). If you expect a nonzero magnetization in your ground state, you MUST either specify a nonzero value for at least one atomic type, or constrain the magnetization using variable tot_magnetization for LSDA, constrained_magnetization for noncollinear/spin-orbit calculations. If you don't, you will get a nonmagnetic (zero magnetization) state. In order to perform LSDA calculations for an antiferromagnetic state, define two different atomic species corresponding to sublattices of the same atomic type.  NOTE 1: starting_magnetization is ignored in most BUT NOT ALL cases in non-scf calculations: it is safe to keep the same values for the scf and subsequent non-scf calculation.  NOTE 2: If you fix the magnetization with tot_magnetization, do not specify starting_magnetization.  NOTE 3: In the noncollinear/spin-orbit case, starting with zero starting_magnetization on all atoms imposes time reversal symmetry. The magnetization is never calculated and is set to zero (the internal variable domag is set to .FALSE.)."
            },
            "ecutwfc": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "kinetic energy cutoff ",
                "id": "idm441963300992",
                "info": "kinetic energy cutoff (Ry) for wavefunctions"
            },
            "ecutrho": {
                "datatype": "real",
                "default": "4 * ecutwfc",
                "options": {},
                "summary": "Kinetic energy cutoff ",
                "id": "idm441963299264",
                "info": "Kinetic energy cutoff (Ry) for charge density and potential For norm-conserving pseudopotential you should stick to the default value, you can reduce it by a little but it will introduce noise especially on forces and stress. If there are ultrasoft PP, a larger value than the default is often desirable (ecutrho = 8 to 12 times ecutwfc, typically). PAW datasets can often be used at 4*ecutwfc, but it depends on the shape of augmentation charge: testing is mandatory. The use of gradient-corrected functional, especially in cells with vacuum, or for pseudopotential without non-linear core correction, usually requires an higher values of ecutrho to be accurately converged."
            },
            "ecutfock": {
                "datatype": "real",
                "default": "ecutrho",
                "options": {},
                "summary": "Kinetic energy cutoff ",
                "id": "idm441963295712",
                "info": "Kinetic energy cutoff (Ry) for the exact exchange operator in EXX type calculations. By default this is the same as ecutrho but in some EXX calculations, a significant speed-up can be obtained by reducing ecutfock, at the expense of some loss in accuracy. Must be .gt. ecutwfc. Not implemented for stress calculation and for US-PP and PAW pseudopotentials. Use with care, especially in metals where it may give raise to instabilities."
            },
            "nr1": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Three",
                "id": "idm441963292288",
                "info": "Three-dimensional FFT mesh (hard grid) for charge density (and scf potential). If not specified the grid is calculated based on the cutoff for charge density (see also ecutrho) Note: you must specify all three dimensions for this setting to be used."
            },
            "nr2": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Three",
                "id": "idm441963291680",
                "info": "Three-dimensional FFT mesh (hard grid) for charge density (and scf potential). If not specified the grid is calculated based on the cutoff for charge density (see also ecutrho) Note: you must specify all three dimensions for this setting to be used."
            },
            "nr3": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Three",
                "id": "idm441963291072",
                "info": "Three-dimensional FFT mesh (hard grid) for charge density (and scf potential). If not specified the grid is calculated based on the cutoff for charge density (see also ecutrho) Note: you must specify all three dimensions for this setting to be used."
            },
            "nr1s": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Three",
                "id": "idm441963288784",
                "info": "Three-dimensional mesh for wavefunction FFT and for the smooth part of charge density ( smooth grid ). Coincides with nr1, nr2, nr3 if ecutrho = 4 * ecutwfc ( default ) Note: you must specify all three dimensions for this setting to be used."
            },
            "nr2s": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Three",
                "id": "idm441963288160",
                "info": "Three-dimensional mesh for wavefunction FFT and for the smooth part of charge density ( smooth grid ). Coincides with nr1, nr2, nr3 if ecutrho = 4 * ecutwfc ( default ) Note: you must specify all three dimensions for this setting to be used."
            },
            "nr3s": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Three",
                "id": "idm441963287536",
                "info": "Three-dimensional mesh for wavefunction FFT and for the smooth part of charge density ( smooth grid ). Coincides with nr1, nr2, nr3 if ecutrho = 4 * ecutwfc ( default ) Note: you must specify all three dimensions for this setting to be used."
            },
            "nosym": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "if ",
                "id": "idm441963284592",
                "info": "if (.TRUE.) symmetry is not used. Consequences:  - if a list of k points is provided in input, it is used   \"as is\": symmetry-inequivalent k-points are not generated,   and the charge density is not symmetrized;  - if a uniform (Monkhorst-Pack) k-point grid is provided in   input, it is expanded to cover the entire Brillouin Zone,   irrespective of the crystal symmetry.   Time reversal symmetry is assumed so k and -k are considered   as equivalent unless noinv=.true. is specified.  Do not use this option unless you know exactly what you want and what you get. May be useful in the following cases: - in low-symmetry large cells, if you cannot afford a k-point   grid with the correct symmetry - in MD simulations - in calculations for isolated atoms"
            },
            "nosym_evc": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "if ",
                "id": "idm441963282000",
                "info": "if (.TRUE.) symmetry is not used, and k points are forced to have the symmetry of the Bravais lattice; an automatically generated Monkhorst-Pack grid will contain all points of the grid over the entire Brillouin Zone, plus the points rotated by the symmetries of the Bravais lattice which were not in the original grid. The same applies if a k-point list is provided in input instead of a Monkhorst-Pack grid. Time reversal symmetry is assumed so k and -k are equivalent unless noinv=.true. is specified. This option differs from nosym because it forces k-points in all cases to have the full symmetry of the Bravais lattice (not all uniform grids have such property!)"
            },
            "noinv": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "if ",
                "id": "idm441963278864",
                "info": "if (.TRUE.) disable the usage of k => -k symmetry (time reversal) in k-point generation"
            },
            "no_t_rev": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "if ",
                "id": "idm441963276912",
                "info": "if (.TRUE.) disable the usage of magnetic symmetry operations that consist in a rotation + time reversal."
            },
            "force_symmorphic": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "if ",
                "id": "idm441963275120",
                "info": "if (.TRUE.) force the symmetry group to be symmorphic by disabling symmetry operations having an associated fractionary translation"
            },
            "use_all_frac": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "if ",
                "id": "idm441963273296",
                "info": "if (.FALSE.) force real-space FFT grids to be commensurate with fractionary translations of non-symmorphic symmetry operations, if present (e.g.: if a fractional translation (0,0,c/4) exists, the FFT dimension along the c axis must be multiple of 4). if (.TRUE.) do not impose any constraints to FFT grids, even in the presence of non-symmorphic symmetry operations. BEWARE: use_all_frac=.TRUE. may lead to wrong results for hybrid functionals and phonon calculations. Both cases use symmetrization in real space that works for non-symmorphic operations only if the real-space FFT grids are commensurate."
            },
            "occupations": {
                "datatype": "string",
                "default": "",
                "options": {
                    "smearing": "gaussian smearing for metals; see variables smearing and degauss",
                    "tetrahedra": "Tetrahedron method, Bloechl's version: P.E. Bloechl, PRB 49, 16223 (1994) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.49.16223) Requires uniform grid of k-points, to be automatically generated (see card K_POINTS). Well suited for calculation of DOS, less so (because not variational) for force/optimization/dynamics calculations.",
                    "tetrahedra_lin": "Original linear tetrahedron method. To be used only as a reference; the optimized tetrahedron method is more efficient.",
                    "tetrahedra_opt": "Optimized tetrahedron method: see M. Kawamura, PRB 89, 094515 (2014) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.89.094515). Can be used for phonon calculations as well.",
                    "fixed": "for insulators with a gap",
                    "from_input": "The occupation are read from input file, card OCCUPATIONS. Option valid only for a single k-point, requires nbnd to be set in input. Occupations should be consistent with the value of tot_charge."
                },
                "summary": "Available options are",
                "id": "idm441963271008",
                "info": "Available options are:"
            },
            "one_atom_occupations": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "This flag is used for isolated atoms ",
                "id": "idm441963260848",
                "info": "This flag is used for isolated atoms (nat=1) together with occupations='from_input'. If it is .TRUE., the wavefunctions are ordered as the atomic starting wavefunctions, independently from their eigenvalue. The occupations indicate which atomic states are filled.  The order of the states is written inside the UPF pseudopotential file. In the scalar relativistic case: S -> l=0, m=0 P -> l=1, z, x, y D -> l=2, r^2-3z^2, xz, yz, xy, x^2-y^2  In the noncollinear magnetic case (with or without spin-orbit), each group of states is doubled. For instance: P -> l=1, z, x, y for spin up, l=1, z, x, y for spin down. Up and down is relative to the direction of the starting magnetization.  In the case with spin-orbit and time-reversal (starting_magnetization=0.0) the atomic wavefunctions are radial functions multiplied by spin-angle functions. For instance: P -> l=1, j=1/2, m_j=-1/2,1/2. l=1, j=3/2,      m_j=-3/2, -1/2, 1/2, 3/2.  In the magnetic case with spin-orbit the atomic wavefunctions can be forced to be spin-angle functions by setting starting_spin_angle to .TRUE.."
            },
            "starting_spin_angle": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "In the spin",
                "id": "idm441963256592",
                "info": "In the spin-orbit case when domag=.TRUE., by default, the starting wavefunctions are initialized as in scalar relativistic noncollinear case without spin-orbit.  By setting starting_spin_angle=.TRUE. this behaviour can be changed and the initial wavefunctions are radial functions multiplied by spin-angle functions.  When domag=.FALSE. the initial wavefunctions are always radial functions multiplied by spin-angle functions independently from this flag.  When lspinorb is .FALSE. this flag is not used."
            },
            "degauss": {
                "datatype": "real",
                "default": "0.D0 Ry",
                "options": {},
                "summary": "value of the gaussian spreading ",
                "id": "idm441963252832",
                "info": "value of the gaussian spreading (Ry) for brillouin-zone integration in metals."
            },
            "smearing": {
                "datatype": "string",
                "default": "gaussian",
                "options": {
                    "gaussian', 'gauss": "ordinary Gaussian spreading (Default)",
                    "methfessel-paxton', 'm-p', 'mp": "Methfessel-Paxton first-order spreading (see PRB 40, 3616 (1989) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.40.3616)).",
                    "marzari-vanderbilt', 'cold', 'm-v', 'mv": "Marzari-Vanderbilt-DeVita-Payne cold smearing (see PRL 82, 3296 (1999) (https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.82.3296))",
                    "fermi-dirac', 'f-d', 'fd": "smearing with Fermi-Dirac function"
                },
                "summary": "Available options are",
                "id": "idm441963251072",
                "info": "Available options are:"
            },
            "nspin": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "nspin = 1 ",
                "id": "idm441963244688",
                "info": "nspin = 1 :  non-polarized calculation (default)  nspin = 2 :  spin-polarized calculation, LSDA              (magnetization along z axis)  nspin = 4 :  spin-polarized calculation, noncollinear              (magnetization in generic direction)              DO NOT specify nspin in this case;              specify noncolin=.TRUE. instead"
            },
            "noncolin": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "if ",
                "id": "idm441963241872",
                "info": "if .true. the program will perform a noncollinear calculation."
            },
            "ecfixed": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "",
                "id": "idm441963240128",
                "info": ""
            },
            "qcutz": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "",
                "id": "idm441963238448",
                "info": ""
            },
            "q2sigma": {
                "datatype": "real",
                "default": "0.1",
                "options": {},
                "summary": "ecfixed, qcutz, q2sigma",
                "id": "idm441963236768",
                "info": "ecfixed, qcutz, q2sigma:  parameters for modified functional to be used in variable-cell molecular dynamics (or in stress calculation). \"ecfixed\" is the value (in Rydberg) of the constant-cutoff; \"qcutz\" and \"q2sigma\" are the height and the width (in Rydberg) of the energy step for reciprocal vectors whose square modulus is greater than \"ecfixed\". In the kinetic energy, G^2 is replaced by G^2 + qcutz * (1 + erf ( (G^2 - ecfixed)/q2sigma) ) See: M. Bernasconi et al, J. Phys. Chem. Solids 56, 501 (1995), doi:10.1016/0022-3697(94)00228-2 (https://doi.org/10.1016/0022-3697(94)00228-2)"
            },
            "input_dft": {
                "datatype": "string",
                "default": "read from pseudopotential files",
                "options": {},
                "summary": "Exchange",
                "id": "idm441963233616",
                "info": "Exchange-correlation functional: eg 'PBE', 'BLYP' etc See Modules/funct.f90 for allowed values. Overrides the value read from pseudopotential files. Use with care and if you know what you are doing!"
            },
            "ace": {
                "datatype": "boolean",
                "default": "true",
                "options": {},
                "summary": "Use Adaptively Compressed Exchange operator as in Lin Lin, J",
                "id": "idm441963231456",
                "info": "Use Adaptively Compressed Exchange operator as in Lin Lin, J. Chem. Theory Comput. 2016, 12, 2242--2249, doi:10.1021/acs.jctc.6b00092 (https://doi.org/10.1021/acs.jctc.6b00092)  Set to false to use standard Exchange (much slower)"
            },
            "exx_fraction": {
                "datatype": "real",
                "default": "it depends on the specified functional",
                "options": {},
                "summary": "Fraction of EXX for hybrid functional calculations",
                "id": "idm441963228960",
                "info": "Fraction of EXX for hybrid functional calculations. In the case of input_dft='PBE0', the default value is 0.25, while for input_dft='B3LYP' the exx_fraction default value is 0.20."
            },
            "screening_parameter": {
                "datatype": "real",
                "default": "0.106",
                "options": {},
                "summary": "screening_parameter for HSE like hybrid functionals",
                "id": "idm441963225776",
                "info": "screening_parameter for HSE like hybrid functionals. For more information, see: J. Chem. Phys. 118, 8207 (2003), doi:10.1063/1.1564060 (https://doi.org/10.1063/1.1564060) J. Chem. Phys. 124, 219906 (2006), doi:10.1063/1.2204597 (https://doi.org/10.1063/1.2204597)"
            },
            "exxdiv_treatment": {
                "datatype": "string",
                "default": "gygi-baldereschi",
                "options": {
                    "gygi-baldereschi": "appropriate for cubic and quasi-cubic supercells",
                    "vcut_spherical": "appropriate for cubic and quasi-cubic supercells",
                    "vcut_ws": "appropriate for strongly anisotropic supercells, see also ecutvcut.",
                    "none": "sets Coulomb potential at G,q=0 to 0.0 (required for GAU-PBE)"
                },
                "summary": "Specific for EXX",
                "id": "idm441963222544",
                "info": "Specific for EXX. It selects the kind of approach to be used for treating the Coulomb potential divergencies at small q vectors."
            },
            "x_gamma_extrapolation": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "Specific for EXX",
                "id": "idm441963217104",
                "info": "Specific for EXX. If .true., extrapolate the G=0 term of the potential (see README in examples/EXX_example for more) Set this to .false. for GAU-PBE."
            },
            "ecutvcut": {
                "datatype": "real",
                "default": "0.0 Ry",
                "options": {},
                "summary": "Reciprocal space cutoff for correcting Coulomb potential divergencies at small q vectors",
                "id": "idm441963215248",
                "info": "Reciprocal space cutoff for correcting Coulomb potential divergencies at small q vectors."
            },
            "nqx1": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Three",
                "id": "idm441963212560",
                "info": "Three-dimensional mesh for q (k1-k2) sampling of the Fock operator (EXX). Can be smaller than the number of k-points.  Currently this defaults to the size of the k-point mesh used. In QE =< 5.0.2 it defaulted to nqx1=nqx2=nqx3=1."
            },
            "nqx2": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Three",
                "id": "idm441963211936",
                "info": "Three-dimensional mesh for q (k1-k2) sampling of the Fock operator (EXX). Can be smaller than the number of k-points.  Currently this defaults to the size of the k-point mesh used. In QE =< 5.0.2 it defaulted to nqx1=nqx2=nqx3=1."
            },
            "nqx3": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Three",
                "id": "idm441963211312",
                "info": "Three-dimensional mesh for q (k1-k2) sampling of the Fock operator (EXX). Can be smaller than the number of k-points.  Currently this defaults to the size of the k-point mesh used. In QE =< 5.0.2 it defaulted to nqx1=nqx2=nqx3=1."
            },
            "localization_thr": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "Overlap threshold over which the exchange integral over a pair of localized orbitals is included in the evaluation of EXX operator",
                "id": "idm441963209792",
                "info": "Overlap threshold over which the exchange integral over a pair of localized orbitals is included in the evaluation of EXX operator. Any value greater than 0.0 triggers the SCDM localization and the evaluation on EXX using the localized orbitals. Very small value of the threshold should yield the same result as the default EXX evaluation"
            },
            "Hubbard_occ": {
                "datatype": "realarray (ntyp,3)",
                "default": "read from pseudopotentials",
                "options": {},
                "summary": "Hubbard occupations is the number of electrons in the Hubbard manifold",
                "id": "idm441963207744",
                "info": "Hubbard occupations is the number of electrons in the Hubbard manifold. By default they are initialized by reading the occupations from pseudopotentials. If specified from the input, then the values read from the pseudopotentials will be overwritten. The second index of the Hubbard_occ array corresponds to the Hubbard manifold number. It is possible to specify up to three Hubbard manifolds per Hubbard atom. However, if you want to specify three manifolds then the second and the third manifolds will be considered as one effective manifold (see Doc/Hubbard_input.pdf)"
            },
            "Hubbard_alpha": {
                "datatype": "realarray (ntyp)",
                "default": "0.D0 for all species",
                "options": {},
                "summary": "Hubbard_alpha",
                "id": "idm441963204768",
                "info": "Hubbard_alpha(i) is the perturbation (on atom i, in eV) used to compute U (and V) with the linear-response method of Cococcioni and de Gironcoli, PRB 71, 035105 (2005) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.71.035105) (only for lda_plus_u_kind=0 and 2).  Note: Hubbard U and V can be computed using the HP code which is based on density-functional perturbation theory, and it gives exactly the same result as the method of Cococcioni and de Gironcoli."
            },
            "Hubbard_beta": {
                "datatype": "realarray (ntyp)",
                "default": "0.D0 for all species",
                "options": {},
                "summary": "Hubbard_beta",
                "id": "idm441963201344",
                "info": "Hubbard_beta(i) is the perturbation (on atom i, in eV) used to compute J0 with the linear-response method of Cococcioni and de Gironcoli, PRB 71, 035105 (2005) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.71.035105) (only for lda_plus_u_kind=0 and 2). See also PRB 84, 115108 (2011) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.84.115108)."
            },
            "starting_ns_eigenvalue": {
                "datatype": "realarray (2*lmax+1,nspin or npol,ntyp)",
                "default": "-1.d0 that means NOT SET",
                "options": {},
                "summary": "In the first iteration of an DFT+U run it overwrites the m",
                "id": "idm441963197168",
                "info": "In the first iteration of an DFT+U run it overwrites the m-th eigenvalue of the ns occupation matrix for the ispin component of atomic species ityp. For the noncollinear case, the ispin index runs up to npol=2 The value lmax  is given by the maximum angular momentum number to which the Hubbard U is applied. Leave unchanged eigenvalues that are not set. This is useful to suggest the desired orbital occupations when the default choice takes another path."
            },
            "dmft": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If true, nscf calculation will exit in restart mode, scf calculation will restart from there if DMFT updates are provided as hdf5 archive",
                "id": "idm441963194256",
                "info": "If true, nscf calculation will exit in restart mode, scf calculation will restart from there if DMFT updates are provided as hdf5 archive. Scf calculation should be used only with electron_maxstep = 1. K_POINTS have to be identical and given explicitly with nosym."
            },
            "dmft_prefix": {
                "datatype": "string",
                "default": "prefix",
                "options": {},
                "summary": "prepended to hdf5 archive",
                "id": "idm441963190640",
                "info": "prepended to hdf5 archive: dmft_prefix.h5  DMFT update should be provided in group/dataset as: - dft_misc_input/band_window with dimension [1, number of k-points, 2 (real + complex)] - dft_update/delta_N with dimension [number of k-points, number of correlated orbitals, number of correlated orbitals, 2 (real + complex)]"
            },
            "ensemble_energies": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ensemble_energies = ",
                "id": "idm441963188272",
                "info": "If ensemble_energies = .true., an ensemble of xc energies is calculated non-selfconsistently for perturbed exchange-enhancement factors and LDA vs. PBE correlation ratios after each converged electronic ground state calculation.  Ensemble energies can be analyzed with the 'bee' utility included with libbeef.  Requires linking against libbeef. input_dft must be set to a BEEF-type functional (e.g. input_dft = 'BEEF-vdW')"
            },
            "edir": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "The direction of the electric field or dipole correction is parallel to the bg",
                "id": "idm441963185120",
                "info": "The direction of the electric field or dipole correction is parallel to the bg(:,edir) reciprocal lattice vector, so the potential is constant in planes defined by FFT grid points; edir = 1, 2 or 3. Used only if tefield is .TRUE."
            },
            "emaxpos": {
                "datatype": "real",
                "default": "0.5D0",
                "options": {},
                "summary": "Position of the maximum of the saw",
                "id": "idm441963182816",
                "info": "Position of the maximum of the saw-like potential along crystal axis edir, within the  unit cell (see below), 0 < emaxpos < 1 Used only if tefield is .TRUE."
            },
            "eopreg": {
                "datatype": "real",
                "default": "0.1D0",
                "options": {},
                "summary": "Zone in the unit cell where the saw",
                "id": "idm441963180144",
                "info": "Zone in the unit cell where the saw-like potential decreases. ( see below, 0 < eopreg < 1 ). Used only if tefield is .TRUE."
            },
            "eamp": {
                "datatype": "real",
                "default": "0.001 a.u.",
                "options": {},
                "summary": "Amplitude of the electric field, in ***Hartree*** a",
                "id": "idm441963177888",
                "info": "Amplitude of the electric field, in ***Hartree*** a.u.; 1 a.u. = 51.4220632*10^10 V/m. Used only if tefield==.TRUE. The saw-like potential increases with slope eamp in the region from (emaxpos+eopreg-1) to (emaxpos), then decreases to 0 until (emaxpos+eopreg), in units of the crystal vector edir. Important: the change of slope of this potential must be located in the empty region, or else unphysical forces will result."
            },
            "angle1": {
                "datatype": "realarray (ntyp)",
                "default": "",
                "options": {},
                "summary": "The angle expressed in degrees between the initial magnetization and the z",
                "id": "idm441963172576",
                "info": "The angle expressed in degrees between the initial magnetization and the z-axis. For noncollinear calculations only; index i runs over the atom types."
            },
            "angle2": {
                "datatype": "realarray (ntyp)",
                "default": "",
                "options": {},
                "summary": "The angle expressed in degrees between the projection of the initial magnetization on x",
                "id": "idm441963170688",
                "info": "The angle expressed in degrees between the projection of the initial magnetization on x-y plane and the x-axis. For noncollinear calculations only."
            },
            "lforcet": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "When starting a non collinear calculation using an existing density file from a collinear lsda calculation assumes previous density points in",
                "id": "idm441963168816",
                "info": "When starting a non collinear calculation using an existing density file from a collinear lsda calculation assumes previous density points in"
            },
            "constrained_magnetization": {
                "datatype": "string",
                "default": "none",
                "options": {
                    "none": "no constraint",
                    "total": "total magnetization is constrained by adding a penalty functional to the total energy:  LAMBDA * SUM_{i} ( magnetization(i) - fixed_magnetization(i) )**2  where the sum over i runs over the three components of the magnetization. Lambda is a real number (see below). Noncolinear case only. Use tot_magnetization for LSDA",
                    "atomic": "atomic magnetization are constrained to the defined starting magnetization adding a penalty:  LAMBDA * SUM_{i,itype} ( magnetic_moment(i,itype) - mcons(i,itype) )**2  where i runs over the cartesian components (or just z in the collinear case) and itype over the types (1-ntype). mcons(:,:) array is defined from starting_magnetization, (also from angle1, angle2 in the noncollinear case). lambda is a real number",
                    "total direction": "the angle theta of the total magnetization with the z axis (theta = fixed_magnetization(3)) is constrained:  LAMBDA * ( arccos(magnetization(3)/mag_tot) - theta )**2  where mag_tot is the modulus of the total magnetization.",
                    "atomic direction": "not all the components of the atomic magnetic moment are constrained but only the cosine of angle1, and the penalty functional is:  LAMBDA * SUM_{itype} ( mag_mom(3,itype)/mag_mom_tot - cos(angle1(ityp)) )**2"
                },
                "summary": "Used to perform constrained calculations in magnetic systems",
                "id": "idm441963166112",
                "info": "Used to perform constrained calculations in magnetic systems. Currently available choices:"
            },
            "fixed_magnetization": {
                "datatype": "realarray (3)",
                "default": "0.d0",
                "options": {},
                "summary": "total magnetization vector ",
                "id": "idm441963158080",
                "info": "total magnetization vector (x,y,z components) to be kept fixed when constrained_magnetization=='total'"
            },
            "lambda": {
                "datatype": "real",
                "default": "1.d0",
                "options": {},
                "summary": "parameter used for constrained_magnetization calculations N",
                "id": "idm441963155008",
                "info": "parameter used for constrained_magnetization calculations N.B.: if the scf calculation does not converge, try to reduce lambda       to obtain convergence, then restart the run with a larger lambda"
            },
            "report": {
                "datatype": "integer",
                "default": "-1",
                "options": {},
                "summary": "determines when atomic magnetic moments are printed on output",
                "id": "idm441963152704",
                "info": "determines when atomic magnetic moments are printed on output: report = 0  never report =-1  at the beginning of the scf and at convergence report = N  as -1, plus every N scf iterations"
            },
            "lspinorb": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "if ",
                "id": "idm441963149648",
                "info": "if .TRUE. the noncollinear code can use a pseudopotential with spin-orbit."
            },
            "assume_isolated": {
                "datatype": "string",
                "default": "none",
                "options": {
                    "none": "(default): regular periodic calculation w/o any correction.",
                    "makov-payne', 'm-p', 'mp": "the Makov-Payne correction to the total energy is computed. An estimate of the vacuum level is also calculated so that eigenvalues can be properly aligned. ONLY FOR CUBIC SYSTEMS (ibrav=1,2,3). Theory: G.Makov, and M.C.Payne,      \"Periodic boundary conditions in ab initio      calculations\" , PRB 51, 4014 (1995) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.51.4014).",
                    "martyna-tuckerman', 'm-t', 'mt": "Martyna-Tuckerman correction to both total energy and scf potential. Adapted from: G.J. Martyna, and M.E. Tuckerman, \"A reciprocal space based method for treating long range interactions in ab-initio and force-field-based calculation in clusters\", J. Chem. Phys. 110, 2810 (1999), doi:10.1063/1.477923 (https://doi.org/10.1063/1.477923).",
                    "esm": "Effective Screening Medium Method. For polarized or charged slab calculation, embeds the simulation cell within an effective semi- infinite medium in the perpendicular direction (along z). Embedding regions can be vacuum or semi-infinite metal electrodes (use esm_bc to choose boundary conditions). If between two electrodes, an optional electric field (esm_efield) may be applied. Method described in M. Otani and O. Sugino, \"First-principles calculations of charged surfaces and interfaces: A plane-wave nonrepeated slab approach\", PRB 73, 115407 (2006) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.73.115407).  NB:    - Two dimensional (xy plane) average charge density      and electrostatic potentials are printed out to      'prefix.esm1'.     - Requires cell with a_3 lattice vector along z,      normal to the xy plane, with the slab centered      around z=0.     - For bc2 with an electric field and bc3 boundary      conditions, the inversion symmetry along z-direction      is automatically eliminated.     - In case of calculation='vc-relax', use      cell_dofree='2Dxy' or other parameters so that      c-vector along z-axis should not be moved.  See esm_bc, esm_efield, esm_w, esm_nfit.",
                    "2D": "Truncation of the Coulomb interaction in the z direction for structures periodic in the x-y plane. Total energy, forces and stresses are computed in a two-dimensional framework. Linear-response calculations () done on top of a self-consistent calculation with this flag will automatically be performed in the 2D framework as well. Please refer to: Sohier, T., Calandra, M., & Mauri, F. (2017), \"Density functional perturbation theory for gated two-dimensional heterostructures: Theoretical developments and application to flexural phonons in graphene\", PRB, 96, 075448 (2017) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.96.075448).  NB:    - The length of the unit-cell along the z direction should      be larger than twice the thickness of the 2D material      (including electrons). A reasonable estimate for a      layer's thickness could be the interlayer distance in the      corresponding layered bulk material. Otherwise,      the atomic thickness + 10 bohr should be a safe estimate.      There is also a lower limit of 20 bohr imposed by the cutoff      radius used to read pseudopotentials (see read_pseudo.f90 in Modules).     - As for ESM above, only in-plane stresses make sense and one      should use cell_dofree= '2Dxy' in a vc-relax calculation."
                },
                "summary": "Used to perform calculation assuming the system to be isolated ",
                "id": "idm441963148304",
                "info": "Used to perform calculation assuming the system to be isolated (a molecule or a cluster in a 3D supercell).  Currently available choices:"
            },
            "esm_bc": {
                "datatype": "string",
                "default": "pbc",
                "options": {
                    "pbc": "(default): regular periodic calculation (no ESM).",
                    "bc1": "Vacuum-slab-vacuum (open boundary conditions).",
                    "bc2": "Metal-slab-metal (dual electrode configuration). See also esm_efield.",
                    "bc3": "Vacuum-slab-metal"
                },
                "summary": "If assume_isolated = 'esm', determines the boundary conditions used for either side of the slab",
                "id": "idm441963132864",
                "info": "If assume_isolated = 'esm', determines the boundary conditions used for either side of the slab.  Currently available choices:"
            },
            "esm_w": {
                "datatype": "real",
                "default": "0.d0",
                "options": {},
                "summary": "If assume_isolated = 'esm', determines the position offset [in a",
                "id": "idm441963126576",
                "info": "If assume_isolated = 'esm', determines the position offset [in a.u.] of the start of the effective screening region, measured relative to the cell edge. (ESM region begins at z = +/- [L_z/2 + esm_w] )."
            },
            "esm_efield": {
                "datatype": "real",
                "default": "0.d0",
                "options": {},
                "summary": "If assume_isolated = 'esm' and esm_bc = 'bc2', gives the magnitude of the electric field [Ry/a",
                "id": "idm441963123696",
                "info": "If assume_isolated = 'esm' and esm_bc = 'bc2', gives the magnitude of the electric field [Ry/a.u.] to be applied between semi-infinite ESM electrodes."
            },
            "esm_nfit": {
                "datatype": "integer",
                "default": "4",
                "options": {},
                "summary": "If assume_isolated = 'esm', gives the number of z",
                "id": "idm441963120528",
                "info": "If assume_isolated = 'esm', gives the number of z-grid points for the polynomial fit along the cell edge."
            },
            "lgcscf": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441963117840",
                "info": "If .TRUE. perform a constant bias potential (constant-mu) calculation with Grand-Canonical SCF. (JCP 146, 114104 (2017), R.Sundararaman, et al.)  NB: - The total energy displayed in output includes the potentiostat   contribution (-mu*N). - assume_isolated = 'esm' and esm_bc = 'bc2' or 'bc3' must be set   in SYSTEM namelist. - ESM-RISM is also supported (assume_isolated = 'esm' and esm_bc = 'bc1'   and trism = .TRUE.). - mixing_mode has to be 'TF' or 'local-TF', also its default is 'TF.' - The default of mixing_beta is 0.1 with ESM-RISM, 0.2 without ESM-RISM. - The default of diago_thr_init is 1.D-5. - diago_full_acc is always .TRUE. . - diago_rmm_conv is always .TRUE. ."
            },
            "gcscf_mu": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "The target Fermi energy ",
                "id": "idm441963110928",
                "info": "The target Fermi energy (eV) of GC-SCF. One can start with appropriate total charge of the system by giving tot_charge ."
            },
            "gcscf_conv_thr": {
                "datatype": "real",
                "default": "1.D-2",
                "options": {},
                "summary": "Convergence threshold of Fermi energy ",
                "id": "idm441963108736",
                "info": "Convergence threshold of Fermi energy (eV) for GC-SCF."
            },
            "gcscf_beta": {
                "datatype": "real",
                "default": "0.05D0",
                "options": {},
                "summary": "Mixing factor for GC",
                "id": "idm441963106992",
                "info": "Mixing factor for GC-SCF. Larger values are recommended, if systems with small DOS on Fermi surface as graphite."
            },
            "vdw_corr": {
                "datatype": "string",
                "default": "none",
                "options": {
                    "grimme-d2', 'Grimme-D2', 'DFT-D', 'dft-d": "Semiempirical Grimme's DFT-D2. Optional variables: london_s6, london_rcut, london_c6, london_rvdw S. Grimme, J. Comp. Chem. 27, 1787 (2006), doi:10.1002/jcc.20495 (https://doi.org/10.1002/jcc.20495) V. Barone et al., J. Comp. Chem. 30, 934 (2009), doi:10.1002/jcc.21112 (https://doi.org/10.1002/jcc.21112)",
                    "grimme-d3', 'Grimme-D3', 'DFT-D3', 'dft-d3": "Semiempirical Grimme's DFT-D3. Optional variables: dftd3_version, dftd3_threebody S. Grimme et al, J. Chem. Phys 132, 154104 (2010), doi:10.1063/1.3382344 (https://doi.org/10.1063/1.3382344)",
                    "TS', 'ts', 'ts-vdw', 'ts-vdW', 'tkatchenko-scheffler": "Tkatchenko-Scheffler dispersion corrections with first-principle derived C6 coefficients. Optional variables: ts_vdw_econv_thr, ts_vdw_isolated See A. Tkatchenko and M. Scheffler, PRL 102, 073005 (2009) (https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.102.073005).",
                    "MBD', 'mbd', 'many-body-dispersion', 'mbd_vdw": "Many-body dipersion (MBD) correction to long-range interactions. Optional variables: ts_vdw_isolated A. Ambrosetti, A. M. Reilly, R. A. DiStasio, A. Tkatchenko, J. Chem. Phys. 140 18A508 (2014).",
                    "XDM', 'xdm": "Exchange-hole dipole-moment model. Optional variables: xdm_a1, xdm_a2 A. D. Becke et al., J. Chem. Phys. 127, 154108 (2007), doi:10.1063/1.2795701 (https://doi.org/10.1063/1.2795701) A. Otero de la Roza et al., J. Chem. Phys. 136, 174109 (2012), doi:10.1063/1.4705760 (https://doi.org/10.1063/1.4705760)"
                },
                "summary": "Type of Van der Waals correction",
                "id": "idm441963105200",
                "info": "Type of Van der Waals correction. Allowed values:"
            },
            "london": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "",
                "id": "idm441963088768",
                "info": ""
            },
            "london_s6": {
                "datatype": "real",
                "default": "0.75",
                "options": {},
                "summary": "global scaling parameter for DFT",
                "id": "idm441963086640",
                "info": "global scaling parameter for DFT-D. Default is good for PBE."
            },
            "london_c6": {
                "datatype": "realarray (ntyp)",
                "default": "standard Grimme-D2 values",
                "options": {},
                "summary": "atomic C6 coefficient of each atom type  ",
                "id": "idm441963084912",
                "info": "atomic C6 coefficient of each atom type  ( if not specified default values from S. Grimme, J. Comp. Chem. 27, 1787 (2006),   doi:10.1002/jcc.20495 (https://doi.org/10.1002/jcc.20495) are used; see file Modules/mm_dispersion.f90 )"
            },
            "london_rvdw": {
                "datatype": "realarray (ntyp)",
                "default": "standard Grimme-D2 values",
                "options": {},
                "summary": "atomic vdw radii of each atom type  ",
                "id": "idm441963081888",
                "info": "atomic vdw radii of each atom type  ( if not specified default values from S. Grimme, J. Comp. Chem. 27, 1787 (2006),   doi:10.1002/jcc.20495 (https://doi.org/10.1002/jcc.20495) are used; see file Modules/mm_dispersion.f90 )"
            },
            "london_rcut": {
                "datatype": "real",
                "default": "200",
                "options": {},
                "summary": "cutoff radius ",
                "id": "idm441963078864",
                "info": "cutoff radius (a.u.) for dispersion interactions"
            },
            "dftd3_version": {
                "datatype": "integer",
                "default": "3",
                "options": {
                    "dftd3_version = 2": "Original Grimme-D2 parametrization",
                    "dftd3_version = 3": "Grimme-D3 (zero damping)",
                    "dftd3_version = 4": "Grimme-D3 (BJ damping)",
                    "dftd3_version = 5": "Grimme-D3M (zero damping)",
                    "dftd3_version = 6": "Grimme-D3M (BJ damping)"
                },
                "summary": "Version of Grimme implementation of Grimme",
                "id": "idm441963077152",
                "info": "Version of Grimme implementation of Grimme-D3:"
            },
            "dftd3_threebody": {
                "datatype": "boolean",
                "default": "TRUE",
                "options": {},
                "summary": "Turn three",
                "id": "idm441963071152",
                "info": "Turn three-body terms in Grimme-D3 on. If .false. two-body contributions only are computed, using two-body parameters of Grimme-D3. If dftd3_version=2, three-body contribution is always disabled."
            },
            "ts_vdw_econv_thr": {
                "datatype": "real",
                "default": "1.D-6",
                "options": {},
                "summary": "Optional",
                "id": "idm441963069296",
                "info": "Optional: controls the convergence of the vdW energy (and forces). The default value is a safe choice, likely too safe, but you do not gain much in increasing it"
            },
            "ts_vdw_isolated": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "Optional",
                "id": "idm441963067440",
                "info": "Optional: set it to .TRUE. when computing the Tkatchenko-Scheffler vdW energy or the Many-Body dispersion (MBD) energy for an isolated (non-periodic) system."
            },
            "xdm": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "",
                "id": "idm441963065600",
                "info": ""
            },
            "xdm_a1": {
                "datatype": "real",
                "default": "0.6836",
                "options": {},
                "summary": "Damping function parameter a1 ",
                "id": "idm441963063472",
                "info": "Damping function parameter a1 (adimensional). It is NOT necessary to give a value if the functional is one of B86bPBE, PW86PBE, PBE, BLYP. For functionals in this list, the coefficients are given in:"
            },
            "xdm_a2": {
                "datatype": "real",
                "default": "1.5045",
                "options": {},
                "summary": "Damping function parameter a2 ",
                "id": "idm441963060400",
                "info": "Damping function parameter a2 (angstrom). It is NOT necessary to give a value if the functional is one of B86bPBE, PW86PBE, PBE, BLYP. For functionals in this list, the coefficients are given in:"
            },
            "space_group": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "The number of the space group of the crystal, as given in the International Tables of Crystallography A ",
                "id": "idm441963057328",
                "info": "The number of the space group of the crystal, as given in the International Tables of Crystallography A (ITA). This allows to give in input only the inequivalent atomic positions. The positions of all the symmetry equivalent atoms are calculated by the code. Used only when the atomic positions are of type crystal_sg. See also uniqueb, origin_choice, rhombohedral"
            },
            "uniqueb": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "Used only for monoclinic lattices",
                "id": "idm441963054144",
                "info": "Used only for monoclinic lattices. If .TRUE. the b unique ibrav (-12 or -13) are used, and symmetry equivalent positions are chosen assuming that the twofold axis or the mirror normal is parallel to the b axis. If .FALSE. it is parallel to the c axis."
            },
            "origin_choice": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "Used only for space groups that in the ITA allow the use of two different origins",
                "id": "idm441963051808",
                "info": "Used only for space groups that in the ITA allow the use of two different origins. origin_choice=1, means the first origin, while origin_choice=2 is the second origin."
            },
            "rhombohedral": {
                "datatype": "boolean",
                "default": ".TRUE.",
                "options": {},
                "summary": "Used only for rhombohedral space groups",
                "id": "idm441963049168",
                "info": "Used only for rhombohedral space groups. When .TRUE. the coordinates of the inequivalent atoms are given with respect to the rhombohedral axes, when .FALSE. the coordinates of the inequivalent atoms are given with respect to the hexagonal axes. They are converted internally to the rhombohedral axes and ibrav=5 is used in both cases."
            },
            "zgate": {
                "datatype": "real",
                "default": "0.5",
                "options": {},
                "summary": "used only if gate = ",
                "id": "idm441963045632",
                "info": "used only if gate = .TRUE. Specifies the position of the charged plate which represents the counter charge in doped systems (tot_charge .ne. 0). In units of the unit cell length in"
            },
            "relaxz": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "used only if gate = ",
                "id": "idm441963041360",
                "info": "used only if gate = .TRUE. Allows the relaxation of the system towards the charged plate. Use carefully and utilize either a layer of fixed atoms or a potential barrier (block=.TRUE.) to avoid the atoms moving to the position of the plate or the dipole of the dipole correction (dipfield=.TRUE.)."
            },
            "block": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "used only if gate = ",
                "id": "idm441963038176",
                "info": "used only if gate = .TRUE. Adds a potential barrier to the total potential seen by the electrons to mimic a dielectric in field effect configuration and/or to avoid electrons spilling into the vacuum region for electron doping. Potential barrier is from block_1 to block_2 and has a height of block_height. If dipfield = .TRUE. then eopreg is used for a smooth increase and decrease of the potential barrier."
            },
            "block_1": {
                "datatype": "real",
                "default": "0.45",
                "options": {},
                "summary": "used only if gate = ",
                "id": "idm441963034080",
                "info": "used only if gate = .TRUE. and block = .TRUE. lower beginning of the potential barrier, in units of the unit cell size along"
            },
            "block_2": {
                "datatype": "real",
                "default": "0.55",
                "options": {},
                "summary": "used only if gate = ",
                "id": "idm441963030672",
                "info": "used only if gate = .TRUE. and block = .TRUE. upper beginning of the potential barrier, in units of the unit cell size along"
            },
            "block_height": {
                "datatype": "real",
                "default": "0.1",
                "options": {},
                "summary": "used only if gate = ",
                "id": "idm441963027264",
                "info": "used only if gate = .TRUE. and block = .TRUE. Height of the potential barrier in Rydberg."
            }
        },
        "electrons": {
            "electron_maxstep": {
                "datatype": "integer",
                "default": "100",
                "options": {},
                "summary": "maximum number of iterations in a scf step",
                "id": "idm441963023936",
                "info": "maximum number of iterations in a scf step"
            },
            "scf_must_converge": {
                "datatype": "boolean",
                "default": ".TRUE.",
                "options": {},
                "summary": "If ",
                "id": "idm441963022208",
                "info": "If .false. do not stop molecular dynamics or ionic relaxation when electron_maxstep is reached. Use with care."
            },
            "conv_thr": {
                "datatype": "real",
                "default": "1.D-6",
                "options": {},
                "summary": "Convergence threshold for selfconsistency",
                "id": "idm441963020400",
                "info": "Convergence threshold for selfconsistency:    estimated energy error < conv_thr (note that conv_thr is extensive, like the total energy).  For non-self-consistent calculations, conv_thr is used to set the default value of the threshold (ethr) for iterative diagonalization: see diago_thr_init"
            },
            "adaptive_thr": {
                "datatype": "boolean",
                "default": ".FALSE",
                "options": {},
                "summary": "If ",
                "id": "idm441963017632",
                "info": "If .TRUE. this turns on the use of an adaptive conv_thr for the inner scf loops when using EXX."
            },
            "conv_thr_init": {
                "datatype": "real",
                "default": "1.D-3",
                "options": {},
                "summary": "When adaptive_thr = ",
                "id": "idm441963015440",
                "info": "When adaptive_thr = .TRUE. this is the convergence threshold used for the first scf cycle."
            },
            "conv_thr_multi": {
                "datatype": "real",
                "default": "1.D-1",
                "options": {},
                "summary": "When adaptive_thr = ",
                "id": "idm441963013264",
                "info": "When adaptive_thr = .TRUE. the convergence threshold for each scf cycle is given by: max( conv_thr, conv_thr_multi * dexx )"
            },
            "mixing_mode": {
                "datatype": "string",
                "default": "plain",
                "options": {
                    "plain": "charge density Broyden mixing",
                    "TF": "as above, with simple Thomas-Fermi screening (for highly homogeneous systems)",
                    "local-TF": "as above, with local-density-dependent TF screening (for highly inhomogeneous systems)"
                },
                "summary": "Available options are",
                "id": "idm441963010272",
                "info": "Available options are:"
            },
            "mixing_beta": {
                "datatype": "real",
                "default": "0.7D0",
                "options": {},
                "summary": "mixing factor for self",
                "id": "idm441963006048",
                "info": "mixing factor for self-consistency"
            },
            "mixing_ndim": {
                "datatype": "integer",
                "default": "8",
                "options": {},
                "summary": "number of iterations used in mixing scheme",
                "id": "idm441963004336",
                "info": "number of iterations used in mixing scheme. If you are tight with memory, you may reduce it to 4 or so."
            },
            "mixing_fixed_ns": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "For DFT+U ",
                "id": "idm441963002560",
                "info": "For DFT+U : number of iterations with fixed ns ( ns is the atomic density appearing in the Hubbard term )."
            },
            "diagonalization": {
                "datatype": "string",
                "default": "david",
                "options": {
                    "david": "Davidson iterative diagonalization with overlap matrix (default). Fast, may in some rare cases fail.",
                    "cg": "Conjugate-gradient-like band-by-band diagonalization. MUCH slower than 'david' but uses less memory and is (a little bit) more robust.",
                    "ppcg": "PPCG iterative diagonalization",
                    "paro', 'ParO": "ParO iterative diagonalization",
                    "rmm-davidson', 'rmm-paro": "RMM-DIIS iterative diagonalization. To stabilize the SCF loop RMM-DIIS is alternated with calls to Davidson or ParO  solvers depending on the string used. Other variables that can be used to tune the behavior of RMM-DIIS are:  diago_rmm_ndim and diago_rmm_conv"
                },
                "summary": "Available options are",
                "id": "idm441963000784",
                "info": "Available options are:"
            },
            "diago_thr_init": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Convergence threshold ",
                "id": "idm441962993824",
                "info": "Convergence threshold (ethr) for iterative diagonalization (the check is on eigenvalue convergence).  For scf calculations: default is 1.D-2 if starting from a superposition of atomic orbitals; 1.D-5 if starting from a charge density. During self consistency the threshold is automatically reduced (but never below 1.D-13) when approaching convergence.  For non-scf calculations: default is (conv_thr/N elec)/10."
            },
            "diago_cg_maxiter": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "For conjugate gradient diagonalization",
                "id": "idm441962991744",
                "info": "For conjugate gradient diagonalization:  max number of iterations"
            },
            "diago_ppcg_maxiter": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "For ppcg diagonalization",
                "id": "idm441962990400",
                "info": "For ppcg diagonalization:  max number of iterations"
            },
            "diago_david_ndim": {
                "datatype": "integer",
                "default": "2",
                "options": {},
                "summary": "For Davidson diagonalization",
                "id": "idm441962988656",
                "info": "For Davidson diagonalization: dimension of workspace (number of wavefunction packets, at least 2 needed). A larger value may yield a smaller number of iterations in the algorithm but uses more memory and more CPU time in subspace diagonalization (cdiaghg/rdiaghg). You may try diago_david_ndim=4 if you are not tight on memory and if the time spent in subspace diagonalization is small compared to the time spent in h_psi"
            },
            "diago_rmm_ndim": {
                "datatype": "integer",
                "default": "4",
                "options": {},
                "summary": "For RMM",
                "id": "idm441962986144",
                "info": "For RMM-DIIS diagonalization: dimension of workspace (number of wavefunction packets, at least 2 needed)."
            },
            "diago_rmm_conv": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441962984368",
                "info": "If .TRUE., RMM-DIIS is performed up to converge. If .FALSE., RMM-DIIS is performed only once."
            },
            "diago_gs_nblock": {
                "datatype": "integer",
                "default": "16",
                "options": {},
                "summary": "For RMM",
                "id": "idm441962982592",
                "info": "For RMM-DIIS diagonalization: blocking size of Gram-Schmidt orthogonalization"
            },
            "diago_full_acc": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441962980848",
                "info": "If .TRUE. all the empty states are diagonalized at the same level of accuracy of the occupied ones. Otherwise the empty states are diagonalized using a larger threshold (this should not affect total energy, forces, and other ground-state properties)."
            },
            "efield": {
                "datatype": "real",
                "default": "0.D0",
                "options": {},
                "summary": "Amplitude of the finite electric field ",
                "id": "idm441962978912",
                "info": "Amplitude of the finite electric field (in Ry a.u.; 1 a.u. = 36.3609*10^10 V/m). Used only if lelfield==.TRUE. and if k-points (K_POINTS card) are not automatic."
            },
            "efield_cart": {
                "datatype": "realarray (3)",
                "default": "(0.D0, 0.D0, 0.D0)",
                "options": {},
                "summary": "Finite electric field ",
                "id": "idm441962976288",
                "info": "Finite electric field (in Ry a.u.=36.3609*10^10 V/m) in cartesian axis. Used only if lelfield==.TRUE. and if k-points (K_POINTS card) are automatic."
            },
            "efield_phase": {
                "datatype": "string",
                "default": "none",
                "options": {
                    "read": "set the zero of the electronic polarization (with lelfield==.true..) to the result of a previous calculation",
                    "write": "write on disk data on electronic polarization to be read in another calculation",
                    "none": "none of the above points"
                },
                "summary": "Available options are",
                "id": "idm441962973216",
                "info": "Available options are:"
            },
            "startingpot": {
                "datatype": "string",
                "default": "",
                "options": {
                    "atomic": "starting potential from atomic charge superposition (default for scf, *relax, *md)",
                    "file": "start from existing \"charge-density.xml\" file in the directory specified by variables prefix and outdir For nscf and bands calculation this is the default and the only sensible possibility."
                },
                "summary": "Available options are",
                "id": "idm441962968576",
                "info": "Available options are:"
            },
            "startingwfc": {
                "datatype": "string",
                "default": "atomic+random",
                "options": {
                    "atomic": "Start from superposition of atomic orbitals. If not enough atomic orbitals are available, fill with random numbers the remaining wfcs The scf typically starts better with this option, but in some high-symmetry cases one can \"loose\" valence states, ending up in the wrong ground state.",
                    "atomic+random": "As above, plus a superimposed \"randomization\" of atomic orbitals. Prevents the \"loss\" of states mentioned above.",
                    "random": "Start from random wfcs. Slower start of scf but safe. It may also reduce memory usage in conjunction with diagonalization='cg'.",
                    "file": "Start from an existing wavefunction file in the directory specified by variables prefix and outdir."
                },
                "summary": "Available options are",
                "id": "idm441962964416",
                "info": "Available options are:"
            },
            "tqr": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441962957648",
                "info": "If .true., use a real-space algorithm for augmentation charges of ultrasoft pseudopotentials and PAWsets. Faster but numerically less accurate than the default G-space algorithm. Use with care and after testing!"
            },
            "real_space": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441962955776",
                "info": "If .true., exploit real-space localization to compute matrix elements for nonlocal projectors. Faster and in principle better scaling than the default G-space algorithm, but numerically less accurate, may lead to some loss of translational invariance. Use with care and after testing!"
            }
        },
        "ions": {
            "ion_positions": {
                "datatype": "string",
                "default": "default",
                "options": {
                    "default": "if restarting, use atomic positions read from the restart file; in all other cases, use atomic positions from standard input.",
                    "from_input": "read atomic positions from standard input, even if restarting."
                },
                "summary": "Available options are",
                "id": "idm441962951424",
                "info": "Available options are:"
            },
            "ion_velocities": {
                "datatype": "string",
                "default": "default",
                "options": {
                    "default": "start a new simulation from random thermalized distribution of velocities if tempw is set, with zero velocities otherwise; restart from atomic velocities read from the restart file",
                    "from_input": "start or continue the simulation with atomic velocities read from standard input - see card ATOMIC_VELOCITIES"
                },
                "summary": "Initial ionic velocities",
                "id": "idm441962947856",
                "info": "Initial ionic velocities. Available options are:"
            },
            "ion_dynamics": {
                "datatype": "string",
                "default": "",
                "options": {
                    "bfgs": "(default)  use BFGS quasi-newton algorithm; cell_dynamics must be 'bfgs' too",
                    "damp": "use damped (Beeman) dynamics for structural relaxation",
                    "fire": "use the FIRE minimization algorithm employing the semi-implicit Euler integration scheme see:    Bitzek et al.,PRL, 97, 170201, (2006) (https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.97.170201), doi: 10.1103/PhysRevLett.97.170201 (https://doi.org/10.1103/PhysRevLett.97.170201)    Guenole et al.,CMS, 175, 109584, (2020), doi: 10.1016/j.commatsci.2020.109584 (https://doi.org/10.1016/j.commatsci.2020.109584)  Can be used for constrained optimisation: see CONSTRAINTS card",
                    "verlet": "(default)  use Verlet algorithm to integrate Newton's equation. For constrained dynamics, see CONSTRAINTS card",
                    "langevin": "ion dynamics is over-damped Langevin",
                    "langevin-smc": "over-damped Langevin with Smart Monte Carlo: see R.J. Rossky, JCP, 69, 4628 (1978), doi:10.1063/1.436415 (https://doi.org/10.1063/1.436415)",
                    "beeman": "(default)  use Beeman algorithm to integrate Newton's equation"
                },
                "summary": "Specify the type of ionic dynamics",
                "id": "idm441962943392",
                "info": "Specify the type of ionic dynamics.  For different type of calculation different possibilities are allowed and different default values apply:  CASE ( calculation == 'relax' )"
            },
            "pot_extrapolation": {
                "datatype": "string",
                "default": "atomic",
                "options": {
                    "none": "no extrapolation",
                    "atomic": "extrapolate the potential as if it was a sum of atomic-like orbitals",
                    "first_order": "extrapolate the potential with first-order formula",
                    "second_order": "as above, with second order formula"
                },
                "summary": "Used to extrapolate the potential from preceding ionic steps",
                "id": "idm441962924240",
                "info": "Used to extrapolate the potential from preceding ionic steps."
            },
            "wfc_extrapolation": {
                "datatype": "string",
                "default": "none",
                "options": {
                    "none": "no extrapolation",
                    "first_order": "extrapolate the wave-functions with first-order formula.",
                    "second_order": "as above, with second order formula."
                },
                "summary": "Used to extrapolate the wavefunctions from preceding ionic steps",
                "id": "idm441962918656",
                "info": "Used to extrapolate the wavefunctions from preceding ionic steps."
            },
            "remove_rigid_rot": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "This keyword is useful when simulating the dynamics and/or the thermodynamics of an isolated system",
                "id": "idm441962913136",
                "info": "This keyword is useful when simulating the dynamics and/or the thermodynamics of an isolated system. If set to true the total torque of the internal forces is set to zero by adding new forces that compensate the spurious interaction with the periodic images. This allows for the use of smaller supercells.  BEWARE: since the potential energy is no longer consistent with the forces (it still contains the spurious interaction with the repeated images), the total energy is not conserved anymore. However the dynamical and thermodynamical properties should be in closer agreement with those of an isolated system. Also the final energy of a structural relaxation will be higher, but the relaxation itself should be faster."
            },
            "ion_temperature": {
                "datatype": "string",
                "default": "not_controlled",
                "options": {
                    "rescaling": "control ionic temperature via velocity rescaling (first method) see parameters tempw, tolp, and nraise (for VC-MD only). This rescaling method is the only one currently implemented in VC-MD",
                    "rescale-v": "control ionic temperature via velocity rescaling (second method) see parameters tempw and nraise",
                    "rescale-T": "scale temperature of the thermostat every nraise steps by delta_t, starting from tempw. The temperature is controlled via velocitiy rescaling.",
                    "reduce-T": "reduce temperature of the thermostat every nraise steps by the (negative) value delta_t, starting from tempw. If  delta_t is positive, the target temperature is augmented. The temperature is controlled via velocitiy rescaling.",
                    "berendsen": "control ionic temperature using \"soft\" velocity rescaling - see parameters tempw and nraise",
                    "andersen": "control ionic temperature using Andersen thermostat see parameters tempw and nraise",
                    "svr": "control ionic temperature using stochastic-velocity rescaling (Donadio, Bussi, Parrinello, J. Chem. Phys. 126, 014101, 2007), with parameters tempw and nraise.",
                    "initial": "initialize ion velocities to temperature tempw and leave uncontrolled further on",
                    "not_controlled": "(default) ionic temperature is not controlled"
                },
                "summary": "Available options are",
                "id": "idm441962910016",
                "info": "Available options are:"
            },
            "tempw": {
                "datatype": "real",
                "default": "300.D0",
                "options": {},
                "summary": "Starting temperature ",
                "id": "idm441962893200",
                "info": "Starting temperature (Kelvin) in MD runs target temperature for most thermostats."
            },
            "tolp": {
                "datatype": "real",
                "default": "100.D0",
                "options": {},
                "summary": "Tolerance for velocity rescaling",
                "id": "idm441962891440",
                "info": "Tolerance for velocity rescaling. Velocities are rescaled if the run-averaged and target temperature differ more than tolp."
            },
            "delta_t": {
                "datatype": "real",
                "default": "1.D0",
                "options": {},
                "summary": "if ion_temperature == 'rescale",
                "id": "idm441962889632",
                "info": "if ion_temperature == 'rescale-T' :        at each step the instantaneous temperature is multiplied        by delta_t; this is done rescaling all the velocities.  if ion_temperature == 'reduce-T' :        every 'nraise' steps the instantaneous temperature is        reduced by -delta_t (i.e. delta_t < 0 is added to T)  The instantaneous temperature is calculated at the end of every ionic move and BEFORE rescaling. This is the temperature reported in the main output.  For delta_t < 0, the actual average rate of heating or cooling should be roughly C*delta_t/(nraise*dt) (C=1 for an ideal gas, C=0.5 for a harmonic solid, theorem of energy equipartition between all quadratic degrees of freedom)."
            },
            "nraise": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "if ion_temperature == 'reduce",
                "id": "idm441962884528",
                "info": "if ion_temperature == 'reduce-T' :        every nraise steps the instantaneous temperature is        reduced by -delta_t (i.e. delta_t is added to the temperature)  if ion_temperature == 'rescale-v' :        every nraise steps the average temperature, computed from        the last nraise steps, is rescaled to tempw  if ion_temperature == 'rescaling' and calculation == 'vc-md' :        every nraise steps the instantaneous temperature        is rescaled to tempw  if ion_temperature == 'berendsen' :        the \"rise time\" parameter is given in units of the time step:        tau = nraise*dt, so dt/tau = 1/nraise  if ion_temperature == 'andersen' :        the \"collision frequency\" parameter is given as nu=1/tau        defined above, so nu*dt = 1/nraise  if ion_temperature == 'svr' :        the \"characteristic time\" of the thermostat is set to        tau = nraise*dt"
            },
            "refold_pos": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "This keyword applies only in the case of molecular dynamics or damped dynamics",
                "id": "idm441962875408",
                "info": "This keyword applies only in the case of molecular dynamics or damped dynamics. If true the ions are refolded at each step into the supercell."
            },
            "upscale": {
                "datatype": "real",
                "default": "100.D0",
                "options": {},
                "summary": "Max reduction factor for conv_thr during structural optimization conv_thr is automatically reduced when the relaxation approaches convergence so that forces are still accurate, but conv_thr will not be reduced to less that conv_thr / upscale",
                "id": "idm441962872752",
                "info": "Max reduction factor for conv_thr during structural optimization conv_thr is automatically reduced when the relaxation approaches convergence so that forces are still accurate, but conv_thr will not be reduced to less that conv_thr / upscale."
            },
            "bfgs_ndim": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "Number of old forces and displacements vectors used in the PULAY mixing of the residual vectors obtained on the basis of the inverse hessian matrix given by the BFGS algorithm",
                "id": "idm441962868832",
                "info": "Number of old forces and displacements vectors used in the PULAY mixing of the residual vectors obtained on the basis of the inverse hessian matrix given by the BFGS algorithm. When bfgs_ndim = 1, the standard quasi-Newton BFGS method is used. (bfgs only)"
            },
            "trust_radius_max": {
                "datatype": "real",
                "default": "0.8D0",
                "options": {},
                "summary": "Maximum ionic displacement in the structural relaxation",
                "id": "idm441962866512",
                "info": "Maximum ionic displacement in the structural relaxation. (bfgs only)"
            },
            "trust_radius_min": {
                "datatype": "real",
                "default": "1.D-3",
                "options": {},
                "summary": "Minimum ionic displacement in the structural relaxation BFGS is reset when trust_radius < trust_radius_min",
                "id": "idm441962864736",
                "info": "Minimum ionic displacement in the structural relaxation BFGS is reset when trust_radius < trust_radius_min. (bfgs only)"
            },
            "trust_radius_ini": {
                "datatype": "real",
                "default": "0.5D0",
                "options": {},
                "summary": "Initial ionic displacement in the structural relaxation",
                "id": "idm441962862112",
                "info": "Initial ionic displacement in the structural relaxation. (bfgs only)"
            },
            "w_1": {
                "datatype": "real",
                "default": "0.01D0",
                "options": {},
                "summary": "",
                "id": "idm441962860336",
                "info": ""
            },
            "w_2": {
                "datatype": "real",
                "default": "0.5D0",
                "options": {},
                "summary": "Parameters used in line search based on the Wolfe conditions",
                "id": "idm441962858656",
                "info": "Parameters used in line search based on the Wolfe conditions. (bfgs only)"
            },
            "fire_alpha_init": {
                "datatype": "real",
                "default": "0.2D0",
                "options": {},
                "summary": "Initial value of the alpha mixing factor in the FIRE minimization scheme; recommended values are between 0",
                "id": "idm441962856064",
                "info": "Initial value of the alpha mixing factor in the FIRE minimization scheme; recommended values are between 0.1 and 0.3"
            },
            "fire_falpha": {
                "datatype": "real",
                "default": "0.99D0",
                "options": {},
                "summary": "Scaling of the alpha mixing parameter for steps with P > 0;",
                "id": "idm441962854256",
                "info": "Scaling of the alpha mixing parameter for steps with P > 0;"
            },
            "fire_nmin": {
                "datatype": "integer",
                "default": "5",
                "options": {},
                "summary": "Minimum number of steps with P > 0 before increase of dt",
                "id": "idm441962852464",
                "info": "Minimum number of steps with P > 0 before increase of dt"
            },
            "fire_f_inc": {
                "datatype": "real",
                "default": "1.1D0",
                "options": {},
                "summary": "Factor for increasing dt",
                "id": "idm441962850352",
                "info": "Factor for increasing dt"
            },
            "fire_f_dec": {
                "datatype": "real",
                "default": "0.5D0",
                "options": {},
                "summary": "Factor for decreasing dt",
                "id": "idm441962848272",
                "info": "Factor for decreasing dt"
            },
            "fire_dtmax": {
                "datatype": "real",
                "default": "10.D0",
                "options": {},
                "summary": "Determines the maximum value of dt in the FIRE minimization; dtmax = fire_dtmax*dt",
                "id": "idm441962846192",
                "info": "Determines the maximum value of dt in the FIRE minimization; dtmax = fire_dtmax*dt"
            }
        },
        "cell": {
            "cell_dynamics": {
                "datatype": "string",
                "default": "",
                "options": {
                    "none": "no dynamics",
                    "sd": "steepest descent ( not implemented )",
                    "damp-pr": "damped (Beeman) dynamics of the Parrinello-Rahman extended lagrangian",
                    "damp-w": "damped (Beeman) dynamics of the new Wentzcovitch extended lagrangian",
                    "bfgs": "BFGS quasi-newton algorithm (default) ion_dynamics must be 'bfgs' too",
                    "pr": "(Beeman) molecular dynamics of the Parrinello-Rahman extended lagrangian",
                    "w": "(Beeman) molecular dynamics of the new Wentzcovitch extended lagrangian"
                },
                "summary": "Specify the type of dynamics for the cell",
                "id": "idm441962842048",
                "info": "Specify the type of dynamics for the cell. For different type of calculation different possibilities are allowed and different default values apply:  CASE ( calculation == 'vc-relax' )"
            },
            "press": {
                "datatype": "real",
                "default": "0.D0",
                "options": {},
                "summary": "Target pressure [KBar] in a variable",
                "id": "idm441962831392",
                "info": "Target pressure [KBar] in a variable-cell md or relaxation run."
            },
            "wmass": {
                "datatype": "real",
                "default": "0.75*Tot_Mass/pi**2 for Parrinello-Rahman MD; 0.75*Tot_Mass/pi**2/Omega**(2/3) for Wentzcovitch MD",
                "options": {},
                "summary": "Fictitious cell mass [amu] for variable",
                "id": "idm441962829664",
                "info": "Fictitious cell mass [amu] for variable-cell simulations (both 'vc-md' and 'vc-relax')"
            },
            "cell_factor": {
                "datatype": "real",
                "default": "2.0 for variable-cell calculations, 1.0 otherwise",
                "options": {},
                "summary": "Used in the construction of the pseudopotential tables",
                "id": "idm441962827776",
                "info": "Used in the construction of the pseudopotential tables. It should exceed the maximum linear contraction of the cell during a simulation."
            },
            "press_conv_thr": {
                "datatype": "real",
                "default": "0.5D0 Kbar",
                "options": {},
                "summary": "Convergence threshold on the pressure for variable cell relaxation ",
                "id": "idm441962825920",
                "info": "Convergence threshold on the pressure for variable cell relaxation ('vc-relax' : note that the other convergence             thresholds for ionic relaxation apply as well)."
            },
            "cell_dofree": {
                "datatype": "string",
                "default": "all",
                "options": {
                    "all": "all axis and angles are moved",
                    "ibrav": "all axis and angles are moved,                but the lattice remains consistent                with the initial ibrav choice. You can use this option in combination                with any other one by specifying \"ibrav+option\". Please note that some                combinations do not make sense for some crystals and will guarantee that                the relax will never converge. E.g. 'ibrav+2Dxy' is not a problem for                hexagonal cells, but will never converge for cubic ones.",
                    "a": "the x component of axis 1 (v1_x) is fixed",
                    "b": "the y component of axis 2 (v2_y) is fixed",
                    "c": "the z component of axis 3 (v3_z) is fixed",
                    "fixa": "axis 1 (v1_x,v1_y,v1_z) is fixed",
                    "fixb": "axis 2 (v2_x,v2_y,v2_z) is fixed",
                    "fixc": "axis 3 (v3_x,v3_y,v3_z) is fixed",
                    "x": "only the x component of axis 1 (v1_x) is moved",
                    "y": "only the y component of axis 2 (v2_y) is moved",
                    "z": "only the z component of axis 3 (v3_z) is moved",
                    "xy": "only v1_x and v2_y are moved",
                    "xz": "only v1_x and v3_z are moved",
                    "yz": "only v2_y and v3_z are moved",
                    "xyz": "only v1_x, v2_y, v3_z are moved",
                    "shape": "all axis and angles, keeping the volume fixed",
                    "volume": "the volume changes, keeping all angles fixed (i.e. only celldm(1) changes)",
                    "2Dxy": "only x and y components are allowed to change",
                    "2Dshape": "as above, keeping the area in xy plane fixed",
                    "epitaxial_ab": "fix axis 1 and 2 while allowing axis 3 to move",
                    "epitaxial_ac": "fix axis 1 and 3 while allowing axis 2 to move",
                    "epitaxial_bc": "fix axis 2 and 3 while allowing axis 1 to move"
                },
                "summary": "Select which of the cell parameters should be moved",
                "id": "idm441962823760",
                "info": "Select which of the cell parameters should be moved:"
            }
        },
        "fcp": {
            "fcp_mu": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "The target Fermi energy ",
                "id": "idm441962804672",
                "info": "The target Fermi energy (eV). One can start with appropriate total charge of the system by giving tot_charge ."
            },
            "fcp_dynamics": {
                "datatype": "string",
                "default": "",
                "options": {
                    "bfgs": "(default) BFGS quasi-newton algorithm, coupling with ions relaxation ion_dynamics must be 'bfgs' too",
                    "newton": "Newton-Raphson algorithm with DIIS ion_dynamics must be 'damp' too",
                    "damp": "damped (quick-min Verlet) dynamics for FCP relaxation ion_dynamics must be 'damp' too",
                    "lm": "Line-Minimization algorithm for FCP relaxation ion_dynamics must be 'damp' too",
                    "velocity-verlet": "(default) Velocity-Verlet algorithm to integrate Newton's equation. ion_dynamics must be 'verlet' too",
                    "verlet": "Verlet algorithm to integrate Newton's equation. ion_dynamics must be 'verlet' too"
                },
                "summary": "Specify the type of dynamics for the Fictitious Charge Particle ",
                "id": "idm441962802480",
                "info": "Specify the type of dynamics for the Fictitious Charge Particle (FCP).  For different type of calculation different possibilities are allowed and different default values apply:  CASE ( calculation == 'relax' )"
            },
            "fcp_conv_thr": {
                "datatype": "real",
                "default": "1.D-2",
                "options": {},
                "summary": "Convergence threshold on force ",
                "id": "idm441962788096",
                "info": "Convergence threshold on force (eV) for FCP relaxation."
            },
            "fcp_ndiis": {
                "datatype": "integer",
                "default": "4",
                "options": {},
                "summary": "Size of DIIS for FCP relaxation, used only if fcp_dynamics = 'newton'",
                "id": "idm441962786352",
                "info": "Size of DIIS for FCP relaxation, used only if fcp_dynamics = 'newton'."
            },
            "fcp_mass": {
                "datatype": "real",
                "default": "5.D+6 / (xy area) for ESM only; 5.D+4 / (xy area) for ESM-RISM",
                "options": {},
                "summary": "Mass of the FCP",
                "id": "idm441962783536",
                "info": "Mass of the FCP."
            },
            "fcp_velocity": {
                "datatype": "real",
                "default": "determined by fcp_temperature",
                "options": {},
                "summary": "Initial velocity of the FCP",
                "id": "idm441962781792",
                "info": "Initial velocity of the FCP."
            },
            "fcp_temperature": {
                "datatype": "string",
                "default": "ion_temperature",
                "options": {
                    "rescaling": "control FCP's temperature via velocity rescaling (first method) see parameters fpc_tempw and fcp_tolp.",
                    "rescale-v": "control FCP's temperature via velocity rescaling (second method) see parameters fcp_tempw and fcp_nraise",
                    "rescale-T": "control FCP's temperature via velocity rescaling (third method) see parameter fcp_delta_t",
                    "reduce-T": "reduce FCP's temperature every fcp_nraise steps by the (negative) value fcp_delta_t",
                    "berendsen": "control FCP's temperature using \"soft\" velocity rescaling - see parameters fcp_tempw and fcp_nraise",
                    "andersen": "control FCP's temperature using Andersen thermostat see parameters fcp_tempw and fcp_nraise",
                    "initial": "initialize FCP's velocities to temperature fcp_tempw and leave uncontrolled further on",
                    "not_controlled": "(default) FCP's temperature is not controlled"
                },
                "summary": "Available options are",
                "id": "idm441962779696",
                "info": "Available options are:"
            },
            "fcp_tempw": {
                "datatype": "real",
                "default": "tempw",
                "options": {},
                "summary": "Starting temperature ",
                "id": "idm441962765632",
                "info": "Starting temperature (Kelvin) in FCP dynamics runs target temperature for most thermostats."
            },
            "fcp_tolp": {
                "datatype": "real",
                "default": "tolp",
                "options": {},
                "summary": "Tolerance for velocity rescaling",
                "id": "idm441962763488",
                "info": "Tolerance for velocity rescaling. Velocities are rescaled if the run-averaged and target temperature differ more than tolp."
            },
            "fcp_delta_t": {
                "datatype": "real",
                "default": "delta_t",
                "options": {},
                "summary": "if fcp_temperature == 'rescale",
                "id": "idm441962761312",
                "info": "if fcp_temperature == 'rescale-T' :        at each step the instantaneous temperature is multiplied        by fcp_delta_t; this is done rescaling all the velocities.  if fcp_temperature == 'reduce-T' :        every fcp_nraise steps the instantaneous temperature is        reduced by -fcp_delta_t (i.e. fcp_delta_t < 0 is added to T)  The instantaneous temperature is calculated at the end of FCP's move and BEFORE rescaling. This is the temperature reported in the main output.  For fcp_delta_t < 0, the actual average rate of heating or cooling should be roughly C*fcp_delta_t/(fcp_nraise*dt) (C=1 for an ideal gas, C=0.5 for a harmonic solid, theorem of energy equipartition between all quadratic degrees of freedom)."
            },
            "fcp_nraise": {
                "datatype": "integer",
                "default": "nraise",
                "options": {},
                "summary": "if fcp_temperature == 'reduce",
                "id": "idm441962755696",
                "info": "if fcp_temperature == 'reduce-T' :        every fcp_nraise steps the instantaneous temperature is        reduced by -fcp_delta_t (i.e. fcp_delta_t is added to the temperature)  if fcp_temperature == 'rescale-v' :        every fcp_nraise steps the average temperature, computed from        the last fcp_nraise steps, is rescaled to fcp_tempw  if fcp_temperature == 'berendsen' :        the \"rise time\" parameter is given in units of the time step:        tau = fcp_nraise*dt, so dt/tau = 1/fcp_nraise  if fcp_temperature == 'andersen' :        the \"collision frequency\" parameter is given as nu=1/tau        defined above, so nu*dt = 1/fcp_nraise"
            },
            "freeze_all_atoms": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441962748464",
                "info": "If .TRUE., freeze all atoms to perform relaxation or dynamics only with FCP."
            }
        },
        "rism": {
            "nsolv": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "The number of solvents ",
                "id": "idm441962745216",
                "info": "The number of solvents (i.e. molecular species) in the unit cell"
            },
            "closure": {
                "datatype": "string",
                "default": "kh",
                "options": {
                    "kh": "The Kovalenko and Hirata's model. [A.Kovalenko, F.Hirata, JCP 110, 10095 (1999), doi:10.1063/1.478883 (https://doi.org/10.1063/1.478883)]",
                    "hnc": "The HyperNetted-Chain model, which is suitable only for solvents without charge. [J.P.Hansen et al., Theory of simple liquids. Academic Press, London, 1990]"
                },
                "summary": "Specify the type of closure equation",
                "id": "idm441962743472",
                "info": "Specify the type of closure equation:"
            },
            "tempv": {
                "datatype": "real",
                "default": "300.D0",
                "options": {},
                "summary": "Temperature ",
                "id": "idm441962739008",
                "info": "Temperature (Kelvin) of solvents."
            },
            "ecutsolv": {
                "datatype": "real",
                "default": "4 * ecutwfc",
                "options": {},
                "summary": "Kinetic energy cutoff ",
                "id": "idm441962737296",
                "info": "Kinetic energy cutoff (Ry) for solvent's correlation functions. If a solute is an isolated system or slab, you may allowed to use default value. For a frameworked or porous solute (e.g. Zeolite, MOF), it is desirable to apply a larger value. Solvents confined in a framework often have a high frequency."
            },
            "solute_lj": {
                "datatype": "stringarray (ntyp)",
                "default": "uff",
                "options": {
                    "none": "The Lennard-Jones potential is not specified here. you must set solute_epsilon and solute_sigma.",
                    "uff": "Universal Force Field. [A.K.Rappe et al., JACS 144, 10024 (1992), doi:10.1021/ja00051a040 (https://doi.org/10.1021/ja00051a040)]",
                    "clayff": "Clay's Force Field [R.T.Cygan et al., JPC B 108, 1255 (2004), doi:10.1021/jp0363287 (https://doi.org/10.1021/jp0363287)]",
                    "opls-aa": "OPLS-AA (generic parameters for QM/MM)"
                },
                "summary": "Specify the Lennard",
                "id": "idm441962734528",
                "info": "Specify the Lennard-Jones potential of solute on atomic type 'i':"
            },
            "solute_epsilon": {
                "datatype": "realarray (ntyp)",
                "default": "",
                "options": {},
                "summary": "The Lennard",
                "id": "idm441962726768",
                "info": "The Lennard-Jones potential of solute on atomic type 'i'. Here, you can set the parameter 'epsilon' (kcal/mol)."
            },
            "solute_sigma": {
                "datatype": "realarray (ntyp)",
                "default": "",
                "options": {},
                "summary": "The Lennard",
                "id": "idm441962724784",
                "info": "The Lennard-Jones potential of solute on atomic type 'i'. Here, you can set the parameter 'sigma' (Angstrom)."
            },
            "starting1d": {
                "datatype": "string",
                "default": "",
                "options": {
                    "zero": "Starting correlation functions of 1D-RISM from zero. ( default for scf, *relax, *md )",
                    "file": "Start from existing \"1d-rism_csvv_r.xml\" file in the directory specified by variables \"prefix\" and \"outdir\".",
                    "fix": "Read from existing \"1d-rism_csvv_r.xml\" file in the directory specified by variables \"prefix\" and \"outdir\", and never calculate 1D-RISM. For nscf and bands calculation this is the default."
                },
                "summary": "",
                "id": "idm441962722800",
                "info": ""
            },
            "starting3d": {
                "datatype": "string",
                "default": "",
                "options": {
                    "zero": "Starting correlation functions of 3D-RISM from zero. ( default for scf, *relax, *md )",
                    "file": "Start from existing \"3d-rism_csuv_r.dat\" file in the directory specified by variables \"prefix\" and \"outdir\". For nscf and bands calculation this is the default."
                },
                "summary": "",
                "id": "idm441962718816",
                "info": ""
            },
            "smear1d": {
                "datatype": "real",
                "default": "2.D0",
                "options": {},
                "summary": "Coulomb smearing radius ",
                "id": "idm441962716016",
                "info": "Coulomb smearing radius (a.u.) for 1D-RISM."
            },
            "smear3d": {
                "datatype": "real",
                "default": "2.D0",
                "options": {},
                "summary": "Coulomb smearing radius ",
                "id": "idm441962714304",
                "info": "Coulomb smearing radius (a.u.) for 3D-RISM."
            },
            "rism1d_maxstep": {
                "datatype": "integer",
                "default": "50000",
                "options": {},
                "summary": "Maximum number of iterations in a 1D",
                "id": "idm441962712592",
                "info": "Maximum number of iterations in a 1D-RISM step."
            },
            "rism3d_maxstep": {
                "datatype": "integer",
                "default": "5000",
                "options": {},
                "summary": "Maximum number of iterations in a 3D",
                "id": "idm441962710864",
                "info": "Maximum number of iterations in a 3D-RISM step."
            },
            "rism1d_conv_thr": {
                "datatype": "real",
                "default": "1.D-8",
                "options": {},
                "summary": "Convergence threshold for 1D",
                "id": "idm441962709152",
                "info": "Convergence threshold for 1D-RISM."
            },
            "rism3d_conv_thr": {
                "datatype": "real",
                "default": "1.D-5 if lgcscf == .FALSE.; 5.D-6 if lgcscf == .TRUE.",
                "options": {},
                "summary": "Convergence threshold for 3D",
                "id": "idm441962707440",
                "info": "Convergence threshold for 3D-RISM."
            },
            "mdiis1d_size": {
                "datatype": "integer",
                "default": "20",
                "options": {},
                "summary": "Size of Modified DIIS ",
                "id": "idm441962704880",
                "info": "Size of Modified DIIS (MDIIS) for 1D-RISM."
            },
            "mdiis3d_size": {
                "datatype": "integer",
                "default": "10",
                "options": {},
                "summary": "Size of Modified DIIS ",
                "id": "idm441962703168",
                "info": "Size of Modified DIIS (MDIIS) for 3D-RISM."
            },
            "mdiis1d_step": {
                "datatype": "real",
                "default": "0.5D0",
                "options": {},
                "summary": "Step of Modified DIIS ",
                "id": "idm441962701456",
                "info": "Step of Modified DIIS (MDIIS) for 1D-RISM."
            },
            "mdiis3d_step": {
                "datatype": "real",
                "default": "0.8D0",
                "options": {},
                "summary": "Step of Modified DIIS ",
                "id": "idm441962699728",
                "info": "Step of Modified DIIS (MDIIS) for 3D-RISM."
            },
            "rism1d_bond_width": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Gaussian width of bonds to smear intra",
                "id": "idm441962698000",
                "info": "Gaussian width of bonds to smear intra-molecular correlation for 1D-RISM. If 3D-RISM calculation, default is 0. If Laue-RISM calculation, default is 2 / SQRT(ecutwfc)."
            },
            "rism1d_dielectric": {
                "datatype": "real",
                "default": "-1.0D0",
                "options": {},
                "summary": "Dielectric constant for 1D",
                "id": "idm441962696160",
                "info": "Dielectric constant for 1D-RISM. If rism1d_dielectric > 0, dielectrically consistent RISM (DRISM) is performed.  For details of DRISM, see: J.S.Perkyns and B.M.Pettitt, CPL 1992, 190, 626, doi:10.1016/0009-2614(92)85201-K (https://doi.org/10.1016/0009-2614(92)85201-K)"
            },
            "rism1d_molesize": {
                "datatype": "real",
                "default": "2.0D0",
                "options": {},
                "summary": "Size of solvent molecules ",
                "id": "idm441962693024",
                "info": "Size of solvent molecules (a.u.) for 1D-RISM. This is used only if rism1d_dielectric > 0. If you have large molecules, you have to set ~ 20 a.u. ."
            },
            "rism1d_nproc": {
                "datatype": "integer",
                "default": "128",
                "options": {},
                "summary": "Number of processes to calculate 1D",
                "id": "idm441962690704",
                "info": "Number of processes to calculate 1D-RISM."
            },
            "rism3d_conv_level": {
                "datatype": "real",
                "default": "0.1 if laue_both_hands == .FALSE. .AND. lgcscf == .FALSE.; 0.3 if laue_both_hands == .FALSE. .AND. lgcscf == .TRUE.; 0.5 if laue_both_hands == .TRUE.",
                "options": {
                    "0.0": "Convergence level is 'low'. Convergence threshold of 3D-RISM is greater than rism3d_conv_thr, when estimated energy error >> conv_thr . The threshold becomes rism3d_conv_thr, when estimated energy error is enough small.",
                    "0.0<x<1.0": "Convergence level is 'medium'. Convergence threshold of 3D-RISM is intermediate value between 'low' and 'high', where rism3d_conv_level is mixing rate.",
                    "1.0": "Convergence level is 'high'. Convergence threshold of 3D-RISM is always rism3d_conv_thr ."
                },
                "summary": "Convergence level of 3D",
                "id": "idm441962688992",
                "info": "Convergence level of 3D-RISM."
            },
            "rism3d_planar_average": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "If ",
                "id": "idm441962679888",
                "info": "If .TRUE., planar averages of solvent densities and potentials are calculated and written to 'prefix.rism1'. For 3D-RISM, default is .FALSE. For Laue-RISM, default is .TRUE."
            },
            "laue_nfit": {
                "datatype": "integer",
                "default": "4",
                "options": {},
                "summary": "The number of z",
                "id": "idm441962678432",
                "info": "The number of z-grid points for the polynomial fit along the cell edge. This is only for Laue-RISM."
            },
            "laue_expand_right": {
                "datatype": "real",
                "default": "-1.0",
                "options": {},
                "summary": "If positive value, set the ending position offset [in a",
                "id": "idm441962676784",
                "info": "If positive value, set the ending position offset [in a.u.] of the solvent region on right-hand side of the unit cell, measured relative to the unit cell edge. (the solvent region ends at z = + [L_z/2 + laue_expand_right].) This is only for Laue-RISM."
            },
            "laue_expand_left": {
                "datatype": "real",
                "default": "-1.0",
                "options": {},
                "summary": "If positive value, set the ending position offset [in a",
                "id": "idm441962674448",
                "info": "If positive value, set the ending position offset [in a.u.] of the solvent region on left-hand side of the unit cell, measured relative to the unit cell edge. (the solvent region ends at z = - [L_z/2 + laue_expand_left].) This is only for Laue-RISM."
            },
            "laue_starting_right": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "Set the starting position [in a",
                "id": "idm441962672112",
                "info": "Set the starting position [in a.u.] of the solvent region on right-hand side of the unit cell. Then the solvent region is defined as [ laue_starting_right , L_z/2 + laue_expand_right ], where distribution functions are finite. This is only for Laue-RISM."
            },
            "laue_starting_left": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "Set the starting position [in a",
                "id": "idm441962669360",
                "info": "Set the starting position [in a.u.] of the solvent region on left-hand side of the unit cell. Then the solvent region is defined as [ -L_z/2 - laue_expand_left , laue_starting_left ], where distribution functions are finite. This is only for Laue-RISM."
            },
            "laue_buffer_right": {
                "datatype": "real",
                "default": "8.0 if laue_expand_right > 0.0; -1.0 if laue_expand_right <= 0.0",
                "options": {},
                "summary": "If positive value, set the buffering length [in a",
                "id": "idm441962666576",
                "info": "If positive value, set the buffering length [in a.u.] of the solvent region on right-hand side of the unit cell. Then correlation functions are defined inside of [ laue_starting_right - laue_buffer_right , L_z/2 + laue_expand_right ]. This is only for Laue-RISM."
            },
            "laue_buffer_left": {
                "datatype": "real",
                "default": "8.0 if laue_expand_left > 0.0; -1.0 if laue_expand_left <= 0.0",
                "options": {},
                "summary": "If positive value, set the buffering length [in a",
                "id": "idm441962662496",
                "info": "If positive value, set the buffering length [in a.u.] of the solvent region on left-hand side of the unit cell. Then correlation functions are defined inside of [ -L_z/2 - laue_expand_left , laue_starting_left + laue_buffer_left ]. This is only for Laue-RISM."
            },
            "laue_both_hands": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441962658432",
                "info": "If .TRUE., you can set different densities to the solvent regions of right-hand side and left-hand side. See SOLVENTS card."
            },
            "laue_wall": {
                "datatype": "string",
                "default": "auto",
                "options": {
                    "none": "The repulsive wall is not defined.",
                    "auto": "The repulsive wall is defined, whose edge position is set automatically. One does not have to set laue_wall_z (the edge position).",
                    "manual": "The repulsive wall is defined, whose edge position is set manually. One have to set laue_wall_z (the edge position)."
                },
                "summary": "Set the repulsive wall with ",
                "id": "idm441962656224",
                "info": "Set the repulsive wall with (1/r)^12 term of Lennard-Jones potential. This is only for Laue-RISM."
            },
            "laue_wall_z": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "Set the edge position [in a",
                "id": "idm441962651024",
                "info": "Set the edge position [in a.u.] of the repulsive wall. If laue_expand_right > 0.0, the repulsive wall is defined on [ -inf , laue_wall_z ]. If laue_expand_left > 0.0, the repulsive wall is defined on [ laue_wall_z , inf ]. This is only for Laue-RISM and laue_wall == 'manual' ."
            },
            "laue_wall_rho": {
                "datatype": "real",
                "default": "0.01",
                "options": {},
                "summary": "The density ",
                "id": "idm441962646976",
                "info": "The density (1/bohr^3) of the repulsive wall. This is only for Laue-RISM and laue_wall /= 'none' ."
            },
            "laue_wall_epsilon": {
                "datatype": "real",
                "default": "0.1",
                "options": {},
                "summary": "The Lennard",
                "id": "idm441962644800",
                "info": "The Lennard-Jones potential of the repulsive wall. Here, you can set the parameter 'epsilon' (kcal/mol). This is only for Laue-RISM and laue_wall /= 'none' ."
            },
            "laue_wall_sigma": {
                "datatype": "real",
                "default": "4.0",
                "options": {},
                "summary": "The Lennard",
                "id": "idm441962642512",
                "info": "The Lennard-Jones potential of the repulsive wall. Here, you can set the parameter 'sigma' (Angstrom). This is only for Laue-RISM and laue_wall /= 'none' ."
            },
            "laue_wall_lj6": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm441962640240",
                "info": "If .TRUE., the attractive term -(1/r)^6 of Lennard-Jones potential is added. This is only for Laue-RISM and laue_wall /= 'none' ."
            }
        }
    },
    "projwfc": {
        "projwfc": {
            "prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "prefix of input file produced by pw",
                "id": "idm176774397312",
                "info": "prefix of input file produced by pw.x (wavefunctions are needed)"
            },
            "outdir": {
                "datatype": "string",
                "default": "value of the ESPRESSO_TMPDIR environment variable if set; current directory ('./') otherwise",
                "options": {},
                "summary": "directory containing the input data, i",
                "id": "idm176774395088",
                "info": "directory containing the input data, i.e. the same as in pw.x"
            },
            "ngauss": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "Type of gaussian broadening",
                "id": "idm176774392896",
                "info": "Type of gaussian broadening:     0 ... Simple Gaussian (default)     1 ... Methfessel-Paxton of order 1    -1 ... \"cold smearing\" (Marzari-Vanderbilt-DeVita-Payne)   -99 ... Fermi-Dirac function"
            },
            "degauss": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "gaussian broadening, Ry ",
                "id": "idm176774391008",
                "info": "gaussian broadening, Ry (not eV!)"
            },
            "Emin": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "min & max energy ",
                "id": "idm176774388784",
                "info": "min & max energy (eV) for DOS plot"
            },
            "Emax": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "min & max energy ",
                "id": "idm176774388160",
                "info": "min & max energy (eV) for DOS plot"
            },
            "DeltaE": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "energy grid step ",
                "id": "idm176774386496",
                "info": "energy grid step (eV)"
            },
            "lsym": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "if ",
                "id": "idm176774385200",
                "info": "if .true.  the projections are symmetrized,            the partial density of states are computed if .false. the projections are not symmetrized, the partial            DOS can be computed only in the k-resolved case"
            },
            "diag_basis": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "if ",
                "id": "idm176774382496",
                "info": "if .false. the projections of Kohn-Sham states are              done on the orthogonalized atomic orbitals              in the global XYZ coordinate frame. if .true. the projections of Kohn-Sham states are              done on the orthogonalized atomic orbitals              that are rotated to the basis in which the              atomic occupation matrix is diagonal              (i.e. local XYZ coordinate frame)."
            },
            "pawproj": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "if ",
                "id": "idm176774379584",
                "info": "if .true. use PAW projectors and all-electron PAW basis functions to calculate weight factors for the partial densities of states. Following Bloechl, PRB 50, 17953 (1994) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.50.17953), Eq. (4 & 6), the weight factors thus approximate the real charge within the augmentation sphere of each atom. Only for PAW, not implemented in the noncolinear case."
            },
            "filpdos": {
                "datatype": "string",
                "default": "(value of prefix variable)",
                "options": {},
                "summary": "prefix for output files containing PDOS",
                "id": "idm176774376240",
                "info": "prefix for output files containing PDOS(E)"
            },
            "filproj": {
                "datatype": "string",
                "default": "(standard output)",
                "options": {},
                "summary": "file containing the projections",
                "id": "idm176774374096",
                "info": "file containing the projections"
            },
            "lwrite_overlaps": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "if ",
                "id": "idm176774372384",
                "info": "if .true., the overlap matrix of the atomic orbitals prior to orthogonalization is written to \"atomic_proj.xml\". Does not work together with parallel diagonalization: for parallel runs, use \"mpirun -np N projwfc.x -nd 1 ... \""
            },
            "lbinary_data": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "CURRENTLY DISABLED",
                "id": "idm176774369792",
                "info": "CURRENTLY DISABLED. if .true., write atomic projections to a binary file."
            },
            "kresolveddos": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "if ",
                "id": "idm176774367632",
                "info": "if .true. the k-resolved DOS is computed: not summed over all k-points but written as a function of the k-point index. In this case all k-point weights are set to unity"
            },
            "tdosinboxes": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "if ",
                "id": "idm176774365376",
                "info": "if .true. compute the local DOS integrated in volumes  Volumes are defined as boxes with edges parallel to the unit cell, containing the points of the (charge density) FFT grid included within irmin and irmax, in the three dimensions:  from irmin(j,n) to irmax(j,n) for j=1,2,3 (n=1,n_proj_boxes)."
            },
            "n_proj_boxes": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "number of boxes where the local DOS is computed",
                "id": "idm176774360976",
                "info": "number of boxes where the local DOS is computed"
            },
            "irmin(3,n_proj_boxes)": {
                "datatype": "integer",
                "default": "1 for each box",
                "options": {},
                "summary": "first point of the given box  BEWARE",
                "id": "#",
                "info": "first point of the given box  BEWARE: irmin is a 2D array of the form: irmin(3,n_proj_boxes)"
            },
            "irmax(3,n_proj_boxes)": {
                "datatype": "integer",
                "default": "0 for each box",
                "options": {},
                "summary": "last point of the given box; ",
                "id": "#",
                "info": "last point of the given box; ( 0 stands for the last point in the FFT grid )  BEWARE: irmax is a 2D array of the form: irmax(3,n_proj_boxes)"
            },
            "plotboxes": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "if ",
                "id": "idm176774353264",
                "info": "if .true., the boxes are written in output as xsf files with 3D datagrids, valued 1.0 inside the box volume and 0 outside (visualize them as isosurfaces with isovalue 0.5)"
            }
        }
    },
    "ld1": {
        "input": {
            "title": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "A string describing the job",
                "id": "idm411143718480",
                "info": "A string describing the job."
            },
            "zed": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "The nuclear charge ",
                "id": "idm411143716064",
                "info": "The nuclear charge (1 < zed < 100).  IMPORTANT: Specify either zed OR atom, not both!"
            },
            "atom": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "Atomic symbol",
                "id": "idm411143712656",
                "info": "Atomic symbol: atom='H', 'He', 'Be', etc.  IMPORTANT: Specify either atom OR zed, not both!"
            },
            "xmin": {
                "datatype": "real",
                "default": "-7.0 if iswitch>1 or rel=0, -8.0 otherwise",
                "options": {},
                "summary": "Radial grid parameter",
                "id": "idm411143708864",
                "info": "Radial grid parameter."
            },
            "dx": {
                "datatype": "real",
                "default": "0.0125 if iswitch>1, 0.008 otherwise",
                "options": {},
                "summary": "Radial grid parameter",
                "id": "idm411143705888",
                "info": "Radial grid parameter.  The radial grid is: r(i+1) = exp(xmin+i*dx)/zed  a.u."
            },
            "rmax": {
                "datatype": "real",
                "default": "100.0 a.u.",
                "options": {},
                "summary": "Outermost grid point",
                "id": "idm411143703680",
                "info": "Outermost grid point."
            },
            "beta": {
                "datatype": "real",
                "default": "0.2",
                "options": {},
                "summary": "parameter for potential mixing",
                "id": "idm411143701840",
                "info": "parameter for potential mixing"
            },
            "tr2": {
                "datatype": "real",
                "default": "1e-14",
                "options": {},
                "summary": "convergence threshold for scf",
                "id": "idm411143700144",
                "info": "convergence threshold for scf"
            },
            "iswitch": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "1    all",
                "id": "idm411143698448",
                "info": "1    all-electron calculation 2    PP test calculation 3    PP generation 4    LDA-1/2 correction, needs a previously generated PP file"
            },
            "nld": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "the number of logarithmic derivatives to be calculated",
                "id": "idm411143696000",
                "info": "the number of logarithmic derivatives to be calculated"
            },
            "rlderiv": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "radius ",
                "id": "idm411143694688",
                "info": "radius (a.u.) at which logarithmic derivatives are calculated"
            },
            "eminld": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Energy range ",
                "id": "idm411143692832",
                "info": "Energy range (min, max energy, in Ry) at which logarithmic derivatives are calculated."
            },
            "emaxld": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Energy range ",
                "id": "idm411143692208",
                "info": "Energy range (min, max energy, in Ry) at which logarithmic derivatives are calculated."
            },
            "deld": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Delta e ",
                "id": "idm411143690960",
                "info": "Delta e (Ry) of energy for logarithmic derivatives."
            },
            "rpwe": {
                "datatype": "real",
                "default": "rlderiv",
                "options": {},
                "summary": "radius ",
                "id": "idm411143689632",
                "info": "radius (a.u.) at which partial wave expansions are calculated"
            },
            "rel": {
                "datatype": "integer",
                "default": "0 for Z <= 18; 1 for Z >  18",
                "options": {},
                "summary": "0 ",
                "id": "idm411143687248",
                "info": "0 ... non relativistic calculation 1 ... scalar relativistic calculation 2 ... full relativistic calculation with spin-orbit"
            },
            "lsmall": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "if ",
                "id": "idm411143685408",
                "info": "if .true. writes on files the small component"
            },
            "max_out_wfc": {
                "datatype": "integer",
                "default": "7",
                "options": {},
                "summary": "Maximum number of atomic wavefunctions written in the output file",
                "id": "idm411143683680",
                "info": "Maximum number of atomic wavefunctions written in the output file."
            },
            "noscf": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "if ",
                "id": "idm411143681952",
                "info": "if .true. the charge is not computed. The occupations are not used and the eigenvalues and eigenfunctions are those of a hydrogen-like atom."
            },
            "lsd": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "0 ",
                "id": "idm411143680128",
                "info": "0 ... non spin polarized calculation 1 ... spin-polarized calculation  BEWARE: not allowed if iswitch=3 (PP generation) or with full relativistic calculation"
            },
            "dft": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "Exchange",
                "id": "idm411143677504",
                "info": "Exchange-correlation functional.  Examples: 'PZ'    Perdew and Zunger formula for LDA 'PW91'  Perdew and Wang GGA 'BP'    Becke and Perdew GGA 'PBE'   Perdew, Becke and Ernzerhof GGA 'BLYP'  ...  For the complete list, see module \"functionals\" in ../Modules/ The default is 'PZ' for all-electron calculations, it is read from the PP file in a PP calculation."
            },
            "latt": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "0 ",
                "id": "idm411143673392",
                "info": "0 ... no Latter correction 1 ... apply Latter correction"
            },
            "isic": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "0 ",
                "id": "idm411143671664",
                "info": "0 ... no Self-interaction correction 1 ... apply Self-interaction correction"
            },
            "rytoev_fact": {
                "datatype": "real",
                "default": "as specified in file Modules/constants.f90",
                "options": {},
                "summary": "Factor used to convert Ry into eV",
                "id": "idm411143669536",
                "info": "Factor used to convert Ry into eV."
            },
            "cau_fact": {
                "datatype": "real",
                "default": "as specified in file Modules/constants.f90",
                "options": {},
                "summary": "Speed of light in a",
                "id": "idm411143667792",
                "info": "Speed of light in a.u..  (Be careful the default value is always used in the  relativistic exchange.)"
            },
            "vdw": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm411143665968",
                "info": "If .true., the frequency dependent polarizability and van der Waals coefficient C6 will be computed in Thomas-Fermi and von Weizsaecker approximation(only for closed-shell ions)."
            },
            "prefix": {
                "datatype": "string",
                "default": "ld1",
                "options": {},
                "summary": "Prefix for file names ",
                "id": "idm411143663680",
                "info": "Prefix for file names - only for output file names containing the orbitals, logarithmic derivatives, tests See below for file names and the content of the file."
            },
            "verbosity": {
                "datatype": "string",
                "default": "low",
                "options": {},
                "summary": "'low' or 'high'  if 'high' with iswitch=2,3 prints separately core and valence contributions to the energies",
                "id": "idm411143661824",
                "info": "'low' or 'high'  if 'high' with iswitch=2,3 prints separately core and valence contributions to the energies. Print the frozen-core energy."
            },
            "file_charge": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "Name of the file where the code writes the all",
                "id": "idm411143658352",
                "info": "Name of the file where the code writes the all-electron total charge. No charge is written if file_charge=' '."
            },
            "config": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "A string with the electronic configuration",
                "id": "idm411143656464",
                "info": "A string with the electronic configuration.  Example:   '[Ar] 3d10 4s2 4p2.5'  * If lsd=1, spin-up and spin-down state may appear twice   with the respective occupancy: 3p4 3p2 = 4 up,   2 down. Otherwise, the Hund's rule is assumed.  * If rel=2, states with jj=l-1/2 are filled first.   If a state appears twice, the first one has jj=l-1/2,   the second one jj=l+1/2 (except S states)   (Use rel_dist if you want to average the electrons   over all available states.)  * If config='default' the code uses zed to set the ground   state electronic configuration for the atom.  Negative occupancies are used to flag unbound states; they are not actually used."
            },
            "relpert": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm411143652592",
                "info": "If .true. the relativistic corrections to the non-relativistic Kohn-Sham energy levels (rel=0 .and. lsd=0) are computed using first-order perturbation theory in all-electron calculations. The corrections consist of the following terms:    E_vel: velocity (p^4) correction    E_Dar: Darwin term    E_S-O: spin-orbit coupling The spin-orbit term vanishes for s-electron states and gives rise to a splitting of (2*l+1)*E_S-O for the other states. The separate contributions are printed only if verbosity='high'.  Formulas and notation are based on the Herman-Skillman book: F. Herman and S. Skillman, \"Atomic Structure Calculations\", Prentice-Hall, Inc., Englewood Cliffs, New Jersey, 1963"
            },
            "rel_dist": {
                "datatype": "string",
                "default": "energy",
                "options": {},
                "summary": "'energy' or 'average'  * if 'energy' the relativistic l",
                "id": "idm411143649248",
                "info": "'energy' or 'average'  * if 'energy' the relativistic l-1/2 states are filled first.  * if 'average' the electrons are uniformly distributed   among all the states with the given l."
            },
            "write_coulomb": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm411143645760",
                "info": "If .true., a fake pseudo-potential file with name X.UPF, where X is the atomic symbol, is written. It contains the radial grid and the wavefunctions as specified in input, plus the info needed to build the Coulomb potential for an all-electron calculation - for testing only."
            }
        },
        "inputp": {
            "zval": {
                "datatype": "real",
                "default": "(calculated)",
                "options": {},
                "summary": "Valence charge",
                "id": "idm411143623408",
                "info": "Valence charge.  zval is automatically calculated from available data. If the value of zval is provided in input, it will be checked versus the calculated value. The only case in which you need to explicitly provide the value of zval for noninteger zval (i.e. half core-hole pseudo-potentials)."
            },
            "pseudotype": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "1 ",
                "id": "idm411143621488",
                "info": "1 ... norm-conserving, single-projector PP       IMPORTANT: if pseudotype=1 all calculations are done       using the SEMILOCAL form, not the separable nonlocal form  2 ... norm-conserving PP in separable form (obsolescent)       All calculations are done using SEPARABLE non-local form       IMPORTANT: multiple projectors allowed but not properly       implemented, use only if you know what you are doing  3 ... ultrasoft PP or PAW"
            },
            "file_pseudopw": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "File where the generated PP is written",
                "id": "idm411143619056",
                "info": "File where the generated PP is written.  * if the file name ends with \"upf\" or \"UPF\", or in any case for spin-orbit PP (rel=2), the file is written in UPF format;  * if the file name ends with 'psp' it is written in native CPMD format (this is currently an experimental feature); otherwise it is written in the old \"NC\" format if pseudotype=1, or in the old RRKJ format if pseudotype=2 or 3 (no default, must be specified)."
            },
            "file_recon": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "File containing data needed for GIPAW reconstruction of all",
                "id": "idm411143616944",
                "info": "File containing data needed for GIPAW reconstruction of all-electron wavefunctions from PP results. If you want to use additional states to perform the reconstruction, add them at the end of the list of all-electron states."
            },
            "lloc": {
                "datatype": "integer",
                "default": "-1",
                "options": {},
                "summary": "Angular momentum of the local channel",
                "id": "idm411143615104",
                "info": "Angular momentum of the local channel.  * lloc=-1 or lloc=-2 pseudizes the all-electron potential   if lloc=-2 the original recipe of Troullier-Martins   is used (zero first and second derivatives at r=0) * lloc>-1 uses the corresponding channel as local PP  NB: if lloc>-1, the corresponding channel must be the last in the list of wavefunctions appearing after the namelist &inputp In the relativistic case, if lloc > 0 both the j=lloc-1/2 and the j=lloc+1/2 wavefunctions must be at the end of the list."
            },
            "rcloc": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Matching radius ",
                "id": "idm411143613504",
                "info": "Matching radius (a.u.) for local pseudo-potential (no default)."
            },
            "nlcc": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm411143610912",
                "info": "If .true. produce a PP with the nonlinear core correction of Louie, Froyen, and Cohen [PRB 26, 1738 (1982) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.26.1738)]."
            },
            "new_core_ps": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm411143608432",
                "info": "If .true. pseudizes the core charge with bessel functions."
            },
            "rcore": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Matching radius ",
                "id": "idm411143606272",
                "info": "Matching radius (a.u.) for the smoothing of the core charge. If not specified, the matching radius is determined by the condition:  rho_core(rcore) = 2*rho_valence(rcore)"
            },
            "tm": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "* ",
                "id": "idm411143604832",
                "info": "* .true. for Troullier-Martins pseudization [PRB 43, 1993 (1991) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.43.1993)]  * .false. for Rappe-Rabe-Kaxiras-Joannopoulos pseudization   [PRB 41, 1227 (1990) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.41.1227), erratum PRB 44, 13175 (1991) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.44.13175)]"
            },
            "rho0": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "Charge at the origin",
                "id": "idm411143600912",
                "info": "Charge at the origin: when the Rappe-Rabe-Kaxiras-Joannopoulos method with 3 Bessel functions fails, specifying rho0 > 0 may allow to override the problem (using 4 Bessel functions). Typical values are in the order of 0.01-0.02"
            },
            "lpaw": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm411143599024",
                "info": "If .true. produce a PAW dataset, experimental feature only for pseudotype=3"
            },
            "which_augfun": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "If different from 'AE' the augmentation functions are pseudized before rmatch_augfun",
                "id": "idm411143596608",
                "info": "If different from 'AE' the augmentation functions are pseudized before rmatch_augfun. The pseudization options are:  * 'PSQ'        Use Bessel functions to pseudize Q                from the origin to rmatch_augfun.  These features are available only for PAW:  * 'BESSEL'     Use Bessel functions to pseudize the Q. * 'GAUSS'      Use 2 Gaussian functions to pseudize the Q. * 'BG'         Use original Bloechl's recipe with a single gaussian.  Note: if lpaw is true and which_augfun is set to AE real all- electron charge will be used, which will produce extremely hard augmentation."
            },
            "rmatch_augfun": {
                "datatype": "real",
                "default": "0.5 a.u.",
                "options": {},
                "summary": "Pseudization radius for the augmentation functions",
                "id": "idm411143591168",
                "info": "Pseudization radius for the augmentation functions. Presently it has the same value for all L."
            },
            "rmatch_augfun_nc": {
                "datatype": "real",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm411143588912",
                "info": "If .true. the augmentation functions are pseudized from the origin to min(rcut(ns),rcut(ns1)) where ns and ns1 are the two channels for that Q. In this case rmatch_augfun is not used."
            },
            "lsave_wfc": {
                "datatype": "boolean",
                "default": ".false. if .not. lpaw, otherwise .true.",
                "options": {},
                "summary": "Set it to ",
                "id": "idm411143586448",
                "info": "Set it to .true. to save all-electron and pseudo wavefunctions used in the pseudo-potential generation in the UPF file. Only works for UPFv2 format."
            },
            "lgipaw_reconstruction": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "Set it to ",
                "id": "idm411143584592",
                "info": "Set it to .true. to generate pseudo-potentials containing the additional info required for reconstruction of all-electron orbitals, used by GIPAW. You will typically need to specify additional projectors beyond those used in the generation of pseudo-potentials. You should also specify file_recon.  All projectors used in the reconstruction must be listed BOTH in the test configuration after namelist &test AND in the all-electron configuration (variable 'config', namelist &inputp, Use negative occupancies for projectors on unbound states). The core radii in the test configuration should be the same as in the pseudo-potential generation section and will be used as the radius of reconstruction. Projectors not used to generate the pseudo-potential should have zero occupation number."
            },
            "use_paw_as_gipaw": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When generating a PAW dataset, setting this option to ",
                "id": "idm411143582000",
                "info": "When generating a PAW dataset, setting this option to .true. will save the core all-electron wavefunctions to the UPF file. The GIPAW reconstruction to be performed using the PAW data and projectors for the valence wavefunctions.  In the default case, the GIPAW valence wavefunction and projectors are independent from the PAW ones and must be then specified as explained above in lgipaw_reconstruction.  Setting this to .true. always implies lgipaw_reconstruction = .true."
            },
            "author": {
                "datatype": "string",
                "default": "anonymous",
                "options": {},
                "summary": "Name of the author",
                "id": "idm411143579424",
                "info": "Name of the author."
            },
            "file_chi": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "file containing output PP chi functions",
                "id": "idm411143577728",
                "info": "file containing output PP chi functions"
            },
            "file_beta": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "file containing output PP beta functions",
                "id": "idm411143576000",
                "info": "file containing output PP beta functions"
            },
            "file_qvan": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "file containing output PP qvan functions",
                "id": "idm411143574272",
                "info": "file containing output PP qvan functions"
            },
            "file_screen": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "file containing output screening potential",
                "id": "idm411143572544",
                "info": "file containing output screening potential"
            },
            "file_core": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "file containing output total and core charge",
                "id": "idm411143570816",
                "info": "file containing output total and core charge"
            },
            "file_wfcaegen": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "file with the all",
                "id": "idm411143569088",
                "info": "file with the all-electron wfc for generation"
            },
            "file_wfcncgen": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "file with the norm",
                "id": "idm411143567360",
                "info": "file with the norm-conserving wfc for generation"
            },
            "file_wfcusgen": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "file with the ultra",
                "id": "idm411143565632",
                "info": "file with the ultra-soft wfc for generation"
            }
        },
        "test": {
            "nconf": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "the number of configurations to be tested",
                "id": "idm411143534048",
                "info": "the number of configurations to be tested. For iswitch=4 nconf=2"
            },
            "file_pseudo": {
                "datatype": "string",
                "default": " ",
                "options": {},
                "summary": "File containing the PP",
                "id": "idm411143531904",
                "info": "File containing the PP.  * If the file name contains  \".upf\" or \".UPF\", the file is assumed to be in UPF format;  * else if the file name contains \".rrkj3\" or \".RRKJ3\", the old RRKJ format is first tried;  * otherwise, the old NC format is read.  IMPORTANT: in the latter case, all calculations are done using the SEMILOCAL form, not the separable nonlocal form. Use the UPF format if you want to test the separable form!"
            },
            "ecutmin": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Parameters ",
                "id": "idm411143527968",
                "info": "Parameters (Ry) used for test with a basis set of spherical Bessel functions j_l(qr) . The hamiltonian at fixed scf potential is diagonalized for various values of ecut: ecutmin, ecutmin+decut, ecutmin+2*decut ... up to ecutmax. This yields an indication of convergence with the corresponding plane-wave cutoff in solids, and shows in an unambiguous way if there are \"ghost\" states"
            },
            "ecutmax": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Parameters ",
                "id": "idm411143527344",
                "info": "Parameters (Ry) used for test with a basis set of spherical Bessel functions j_l(qr) . The hamiltonian at fixed scf potential is diagonalized for various values of ecut: ecutmin, ecutmin+decut, ecutmin+2*decut ... up to ecutmax. This yields an indication of convergence with the corresponding plane-wave cutoff in solids, and shows in an unambiguous way if there are \"ghost\" states"
            },
            "decut": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Parameters ",
                "id": "idm411143526720",
                "info": "Parameters (Ry) used for test with a basis set of spherical Bessel functions j_l(qr) . The hamiltonian at fixed scf potential is diagonalized for various values of ecut: ecutmin, ecutmin+decut, ecutmin+2*decut ... up to ecutmax. This yields an indication of convergence with the corresponding plane-wave cutoff in solids, and shows in an unambiguous way if there are \"ghost\" states"
            },
            "rm": {
                "datatype": "real",
                "default": "30 a.u.",
                "options": {},
                "summary": "Radius of the box used with spherical Bessel functions",
                "id": "idm411143521008",
                "info": "Radius of the box used with spherical Bessel functions."
            },
            "configts": {
                "datatype": "stringarray (nconf)",
                "default": "",
                "options": {},
                "summary": "A string array containing the test electronic configuration",
                "id": "idm411143519280",
                "info": "A string array containing the test electronic configuration. configts(nc), nc=1,nconf, has the same syntax as for config but only VALENCE states must be included. If configts(i) is not set, the electron configuration is read from the cards following the namelist."
            },
            "lsdts": {
                "datatype": "integerarray (nconf)",
                "default": "1",
                "options": {},
                "summary": "0 or 1",
                "id": "idm411143515696",
                "info": "0 or 1. It is the value of lsd used in the i-th test. Allows to make simultaneously spin-polarized and spin-unpolarized tests."
            },
            "frozen_core": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm411143513040",
                "info": "If .true. only the core wavefunctions of the first configuration are calculated. The eigenvalues, orbitals and energies of the other configurations are calculated with the core of the first configuration. The first configuration must be spin-unpolarized."
            },
            "rcutv": {
                "datatype": "real",
                "default": "-1.0",
                "options": {},
                "summary": "Cutoff distance ",
                "id": "idm411143511104",
                "info": "Cutoff distance (CUT) for the inclusion of LDA-1/2 potential. Needed (mandatory) only if iswitch = 4"
            }
        }
    },
    "lanczos": {
        "lr_input": {
            "prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "Sets the prefix for generated and read files",
                "id": "idm22742778480",
                "info": "Sets the prefix for generated and read files. The files generated by the ground state pw.x run should have this same prefix."
            },
            "outdir": {
                "datatype": "string",
                "default": "./",
                "options": {},
                "summary": "The directory that contains the run critical files, which include the files generated by ground state pw",
                "id": "idm22742776640",
                "info": "The directory that contains the run critical files, which include the files generated by ground state pw.x run."
            },
            "wfcdir": {
                "datatype": "string",
                "default": "./",
                "options": {},
                "summary": "The directory that contains the run critical files, which include the files generated by ground state pw",
                "id": "idm22742774848",
                "info": "The directory that contains the run critical files, which include the files generated by ground state pw.x run."
            },
            "restart": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When set to ",
                "id": "idm22742773056",
                "info": "When set to .true., turbo_lanczos.x will attempt to restart from a previous interrupted calculation. (see restart_step variable).  Beware, if set to .false. turbo_lanczos.x will OVERWRITE any previous runs."
            },
            "restart_step": {
                "datatype": "integer",
                "default": "itermax",
                "options": {},
                "summary": "The code writes restart files every restart_step iterations",
                "id": "idm22742770768",
                "info": "The code writes restart files every restart_step iterations. Restart files are automatically written at the end of itermax Lanczos steps."
            },
            "lr_verbosity": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "This integer variable controls the amount of information written to standard output",
                "id": "idm22742768944",
                "info": "This integer variable controls the amount of information written to standard output."
            },
            "disk_io": {
                "datatype": "string",
                "default": "default",
                "options": {},
                "summary": "Fine control of disk usage",
                "id": "idm22742767200",
                "info": "Fine control of disk usage. Currently only 'reduced' is supported where no restart files are written, apart from the 'default' mode."
            }
        },
        "lr_control": {
            "itermax": {
                "datatype": "integer",
                "default": "500",
                "options": {},
                "summary": "Number of Lanczos iterations to be performed",
                "id": "idm22742764576",
                "info": "Number of Lanczos iterations to be performed."
            },
            "ipol": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "An integer variable that determines which element of the dynamical polarizability will be computed",
                "id": "idm22742762928",
                "info": "An integer variable that determines which element of the dynamical polarizability will be computed: 1 -> alpha_xx(omega), 2 -> alpha_yy(omega), and 3 -> alpha_zz(omega). When set to 4, three Lanczos chains are sequentially performed and the full polarizability tensor and the absorption coefficient are computed."
            },
            "n_ipol": {
                "datatype": "integer",
                "default": "1 if ipol < 4; 3 if ipol=4",
                "options": {},
                "summary": "Determines the number of zeta coefficients to be calculated for a given polarization direction",
                "id": "idm22742760512",
                "info": "Determines the number of zeta coefficients to be calculated for a given polarization direction."
            },
            "ltammd": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When set to ",
                "id": "idm22742758640",
                "info": "When set to .true. the Tamm-Dancoff approximation is used in constructing the Liouvillian."
            },
            "no_hxc": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When set to ",
                "id": "idm22742756864",
                "info": "When set to .true. the change in the internal field (Hartree and exchange-correlation) is ignored in the calculation, resulting in the independent electron approximation."
            },
            "lrpa": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When set to ",
                "id": "idm22742755008",
                "info": "When set to .true. the Random Phase Approximation is used (no exchange and correlation)."
            },
            "scissor": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "Scissor shift ",
                "id": "idm22742753232",
                "info": "Scissor shift (in Rydberg units)."
            },
            "charge_response": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "When set to 1, the code computes the response of the charge density and writes it into a file format determined by the variable plot type",
                "id": "idm22742751536",
                "info": "When set to 1, the code computes the response of the charge density and writes it into a file format determined by the variable plot type. Setting charge response to 1 makes the presence of the card lr post mandatory."
            },
            "pseudo_hermitian": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "When set to ",
                "id": "idm22742749648",
                "info": "When set to .true. the pseudo-Hermitian Lanczos algorithm is used. When set to .false. the non-Hermitian Lanczos biorthogonalization algorithm is used (which is two times slower)."
            },
            "d0psi_rs": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "When set to ",
                "id": "idm22742747776",
                "info": "When set to .true. the dipole is computed in the real space. When set to .false. the dipole is computed in the reciprocal space by computing [H,r]. Note, currently the commutator does not contain a contribution for hybrids [V_EXX,r]. See also the variable lshift_d0psi. Important: Treatment of the dipole in the real space is allowed only if the system is finite."
            },
            "lshift_d0psi": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "This variable is used only when d0psi_rs = ",
                "id": "idm22742745728",
                "info": "This variable is used only when d0psi_rs = .true. a) If a molecule is placed in the corner of the supercell, there is a discontinuity problem for the position operator r, which is not periodic. By setting lshift_d0psi=.true. the discontinuity problem is solved by shifting the position operator r such that it is continuous and well defined. b) If a molecule is placed in the center of the supercell, there is no discontinuity problem for the position operator r, and thus you can set lshift_d0psi=.false. But if you still set it to .true., this will not harm, because the position operator will basically remain as it is, since it is always centered wrt the center of the molecule."
            }
        },
        "lr_post": {
            "omeg": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "The response of the charge density is calculated for this transition energy ",
                "id": "idm22742742336",
                "info": "The response of the charge density is calculated for this transition energy (in Rydberg units)"
            },
            "epsil": {
                "datatype": "real",
                "default": "0.02",
                "options": {},
                "summary": "The broadening/damping term ",
                "id": "idm22742740576",
                "info": "The broadening/damping term (in Rydberg units)."
            },
            "beta_gamma_z_prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "The prefix of the file where the beta gamma zeta coefficients from the first calculation can be set manually using this parameter",
                "id": "idm22742738864",
                "info": "The prefix of the file where the beta gamma zeta coefficients from the first calculation can be set manually using this parameter. The file outdir/beta gamma z prefix.beta gamma z.x (where x=1-3) must exist."
            },
            "w_T_npol": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "Number of polarization directions considered in the previous calculation",
                "id": "idm22742736960",
                "info": "Number of polarization directions considered in the previous calculation. It must be set to 3 if in the previous calculation  ipol=4, it must be set to 1 otherwise."
            },
            "plot_type": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "An integer variable that determines the format of the file containing the charge density response",
                "id": "idm22742735136",
                "info": "An integer variable that determines the format of the file containing the charge density response. 1: A file containing the x y z grid coordinates and the corre- sponding value of the density is produced 2: The density response is written in Xcrysden format 3: The density response is written in the gaussian cube format."
            }
        }
    },
    "hp": {
        "inputhp": {
            "prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "Prepended to input/output filenames; must be the same used in the calculation of unperturbed system",
                "id": "idm70515900992",
                "info": "Prepended to input/output filenames; must be the same used in the calculation of unperturbed system."
            },
            "outdir": {
                "datatype": "string",
                "default": "value of the",
                "options": {},
                "summary": "Directory containing input, output, and scratch files; must be the same as specified in the calculation of the unperturbed system",
                "id": "idm70515899152",
                "info": "Directory containing input, output, and scratch files; must be the same as specified in the calculation of the unperturbed system."
            },
            "iverbosity": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "= 1 ",
                "id": "idm70515896528",
                "info": "= 1 : minimal output = 2 : as above + symmetry matrices, final response       matrices chi0 and chi1 and their inverse matrices,       full U matrix = 3 : as above + various detailed info about the NSCF       calculation at k and k+q = 4 : as above + response occupation matrices at every       iteration and for every q point in the star"
            },
            "max_seconds": {
                "datatype": "real",
                "default": "1.d7",
                "options": {},
                "summary": "Maximum allowed run time before the job stops smoothly",
                "id": "idm70515894528",
                "info": "Maximum allowed run time before the job stops smoothly."
            },
            "nq1": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Parameters of the Monkhorst",
                "id": "idm70515892272",
                "info": "Parameters of the Monkhorst-Pack grid (no offset). Same meaning as for nk1, nk2, nk3 in the input of pw.x."
            },
            "nq2": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Parameters of the Monkhorst",
                "id": "idm70515891664",
                "info": "Parameters of the Monkhorst-Pack grid (no offset). Same meaning as for nk1, nk2, nk3 in the input of pw.x."
            },
            "nq3": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "Parameters of the Monkhorst",
                "id": "idm70515891024",
                "info": "Parameters of the Monkhorst-Pack grid (no offset). Same meaning as for nk1, nk2, nk3 in the input of pw.x."
            },
            "skip_equivalence_q": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm70515889360",
                "info": "If .true. then the HP code will skip the equivalence analysis of q points, and thus the full grid of q points will be used. Otherwise the symmetry is used to determine equivalent q points (star of q), and then perform calculations only for inequivalent q points."
            },
            "determine_num_pert_only": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm70515887392",
                "info": "If .true. determines the number of perturbations (i.e. which atoms will be perturbed) and exits smoothly without performing any calculation. For DFT+U+V, it also determines the indices of inter-site couples."
            },
            "find_atpert": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "Method for searching of atoms which must be perturbed",
                "id": "idm70515885072",
                "info": "Method for searching of atoms which must be perturbed. 1 = Find how many inequivalent Hubbard atoms there are     by analyzing unperturbed occupations. 2 = Find how many Hubbard atoms to perturb based on     how many different Hubbard atomic types there are.     Warning: atoms which have the same type but which     are inequivalent by symmetry or which have different     occupations will not be distinguished in this case     (use option 1 or 3 instead). 3 = Find how many inequivalent Hubbard atoms     there are using symmetry. Atoms which have the     same type but are not equivalent by symmetry will     be distinguished in this case. 4 = Perturb all Hubbard atoms (the most expensive option)"
            },
            "docc_thr": {
                "datatype": "real",
                "default": "5.D-5",
                "options": {},
                "summary": "Threshold for a comparison of unperturbed occupations which is needed for the selection of atoms which must be perturbed",
                "id": "idm70515882704",
                "info": "Threshold for a comparison of unperturbed occupations which is needed for the selection of atoms which must be perturbed. Can be used only when find_atpert = 1."
            },
            "skip_type": {
                "datatype": "booleanarray (ntyp)",
                "default": "skip_type(i) = .false.",
                "options": {},
                "summary": "skip_type",
                "id": "idm70515880400",
                "info": "skip_type(i), where i runs over types of atoms. If skip_type(i)=.true. then no linear-response calculation will be performed for the i-th atomic type: in this case equiv_type(i) must be specified, otherwise the HP code will stop. This option is useful if the system has atoms of the same type but opposite spin pollarizations (anti-ferromagnetic case). This keyword cannot be used when find_atpert = 1."
            },
            "equiv_type": {
                "datatype": "integerarray (ntyp)",
                "default": "equiv_type(i) = 0",
                "options": {},
                "summary": "equiv_type",
                "id": "idm70515875808",
                "info": "equiv_type(i), where i runs over types of atoms. equiv_type(i)=j, will make type i equivalent to type j (useful when nspin=2). Such a merging of types is done only at the post-processing stage. This keyword cannot be used when find_atpert = 1."
            },
            "perturb_only_atom": {
                "datatype": "booleanarray (ntyp)",
                "default": "perturb_only_atom(i) = .false.",
                "options": {},
                "summary": "If perturb_only_atom",
                "id": "idm70515871824",
                "info": "If perturb_only_atom(i)=.true. then only the i-th atom will be perturbed and considered in the run. This variable is useful when one wants to split the whole calculation on parts.  Note: this variable has a higher priority than skip_type."
            },
            "start_q": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "Computes only the q points from start_q to last_q",
                "id": "idm70515867776",
                "info": "Computes only the q points from start_q to last_q.  IMPORTANT: start_q must be smaller or equal to the total number of q points found."
            },
            "last_q": {
                "datatype": "integer",
                "default": "number of q points",
                "options": {},
                "summary": "Computes only the q points from start_q to last_q",
                "id": "idm70515863936",
                "info": "Computes only the q points from start_q to last_q.  IMPORTANT: last_q must be smaller or equal to the total number of q points found."
            },
            "sum_pertq": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If it is set to ",
                "id": "idm70515860112",
                "info": "If it is set to .true. then the HP code will collect pieces of the response occupation matrices for all q points. This variable should be used only when start_q, last_q and perturb_only_atom are used."
            },
            "compute_hp": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If it is set to ",
                "id": "idm70515856560",
                "info": "If it is set to .true. then the HP code will collect pieces of the chi0 and chi matrices (which must have been produced in previous runs) and then compute Hubbard parameters. The HP code will look for files tmp_dir/HP/prefix.chi.i.dat. Note that all files prefix.chi.i.dat (where i runs over all perturbed atoms) must be placed in one folder tmp_dir/HP/. compute_hp=.true. must be used only when the calculation was parallelized over perturbations."
            },
            "conv_thr_chi": {
                "datatype": "real",
                "default": "1.D-5",
                "options": {},
                "summary": "Convergence threshold for the response function chi, which is defined as a trace of the response occupation matrix",
                "id": "idm70515853616",
                "info": "Convergence threshold for the response function chi, which is defined as a trace of the response occupation matrix."
            },
            "thresh_init": {
                "datatype": "real",
                "default": "1.D-14",
                "options": {},
                "summary": "Initial threshold for the solution of the linear system ",
                "id": "idm70515851824",
                "info": "Initial threshold for the solution of the linear system (first iteration). Needed to converge the bare (non-interacting) response function chi0. The specified value will be multiplied by the number of electrons in the system."
            },
            "ethr_nscf": {
                "datatype": "real",
                "default": "1.D-11",
                "options": {},
                "summary": "Threshold for the convergence of eigenvalues during the iterative diagonalization of the Hamiltonian in the non",
                "id": "idm70515849920",
                "info": "Threshold for the convergence of eigenvalues during the iterative diagonalization of the Hamiltonian in the non-self-consistent-field (NSCF) calculation at k and k+q points. Note, this quantity is NOT extensive."
            },
            "niter_max": {
                "datatype": "integer",
                "default": "100",
                "options": {},
                "summary": "Maximum number of iterations in the iterative solution of the linear",
                "id": "idm70515848032",
                "info": "Maximum number of iterations in the iterative solution of the linear-response Kohn-Sham equations."
            },
            "alpha_mix(i)": {
                "datatype": "real",
                "default": "alpha_mix(1)=0.3",
                "options": {},
                "summary": "Mixing parameter ",
                "id": "#",
                "info": "Mixing parameter (for the i-th iteration) for updating the response SCF potential using the modified Broyden method. See: D.D. Johnson, PRB 38, 12807 (1988) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.38.12807)."
            },
            "nmix": {
                "datatype": "integer",
                "default": "4",
                "options": {},
                "summary": "Number of iterations used in potential mixing using the modified Broyden method",
                "id": "idm70515843712",
                "info": "Number of iterations used in potential mixing using the modified Broyden method. See: D.D. Johnson, PRB 38, 12807 (1988) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.38.12807)."
            },
            "num_neigh": {
                "datatype": "integer",
                "default": "6",
                "options": {},
                "summary": "Number of nearest neighbors of every Hubbard atom which will be considered when writting Hubbard V parameters to the file parameters",
                "id": "idm70515841232",
                "info": "Number of nearest neighbors of every Hubbard atom which will be considered when writting Hubbard V parameters to the file parameters.out, which can be used in the subsequent DFT+U+V calculation. This keyword is used only when lda_plus_u_kind = 2 (post-processing stage)."
            },
            "lmin": {
                "datatype": "integer",
                "default": "2",
                "options": {},
                "summary": "Minimum value of the orbital quantum number of the Hubbard atoms starting from which ",
                "id": "idm70515839296",
                "info": "Minimum value of the orbital quantum number of the Hubbard atoms starting from which (and up to the maximum l in the system) Hubbard V will be written to the file parameters.out. lmin refers to the orbital quantum number of the atom corresponding to the first site-index in Hubbard_V(:,:,:). This keyword is used only when lda_plus_u_kind = 2 and only in the post-processing stage. Example: lmin=1 corresponds to writing to file V between e.g. oxygen (with p states) and its neighbors, and including V between transition metals (with d states) and their neighbors. Instead, when lmin=2 only the latter will be written to parameters.out."
            },
            "rmax": {
                "datatype": "real",
                "default": "100.D0",
                "options": {},
                "summary": "Maximum distance ",
                "id": "idm70515835776",
                "info": "Maximum distance (in Bohr) between two atoms to search neighbors (used only at the postprocessing step when lda_plus_u_kind = 2). This keyword is useful when there are e.g. defects in the system."
            },
            "dist_thr": {
                "datatype": "real",
                "default": "6.D-4",
                "options": {},
                "summary": "Threshold ",
                "id": "idm70515833904",
                "info": "Threshold (in Bohr) for comparing inter-atomic distances when reconstructing the missing elements of the response susceptibility in the post-processing step."
            }
        }
    },
    "cp": {
        "control": {
            "calculation": {
                "datatype": "string",
                "default": "cp",
                "options": {},
                "summary": "a string describing the task to be performed",
                "id": "idm298149168320",
                "info": "a string describing the task to be performed:    'cp',    'scf',    'nscf',    'relax',    'vc-relax',    'vc-cp',    'cp-wf',    'vc-cp-wf'     (vc = variable-cell).    (wf = Wannier functions)."
            },
            "title": {
                "datatype": "string",
                "default": "MD Simulation ",
                "options": {},
                "summary": "reprinted on output",
                "id": "idm298149166400",
                "info": "reprinted on output."
            },
            "verbosity": {
                "datatype": "string",
                "default": "low",
                "options": {},
                "summary": "In order of decreasing verbose output",
                "id": "idm298149164688",
                "info": "In order of decreasing verbose output:  'debug' | 'high' | 'medium' | 'low','default' | 'minimal'"
            },
            "isave": {
                "datatype": "integer",
                "default": "100",
                "options": {},
                "summary": "Number of steps between successive savings of information needed to restart the run",
                "id": "idm298149162832",
                "info": "Number of steps between successive savings of information needed to restart the run."
            },
            "restart_mode": {
                "datatype": "string",
                "default": "restart",
                "options": {},
                "summary": "'from_scratch'   ",
                "id": "idm298149160288",
                "info": "'from_scratch'   : from scratch 'restart'        : from previous interrupted run 'reset_counters' : continue a previous simulation,                    performs  \"nstep\" new steps, resetting                    the counter and averages"
            },
            "nstep": {
                "datatype": "integer",
                "default": "50",
                "options": {},
                "summary": "number of Car",
                "id": "idm298149158064",
                "info": "number of Car-Parrinello steps performed in this run"
            },
            "iprint": {
                "datatype": "integer",
                "default": "10",
                "options": {},
                "summary": "Number of steps between successive writings of relevant physical quantities to files named as \"prefix",
                "id": "idm298149156416",
                "info": "Number of steps between successive writings of relevant physical quantities to files named as \"prefix.???\" depending on \"prefix\" parameter. In the standard output relevant quantities are written every 10*iprint steps."
            },
            "tstress": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "Write stress tensor to standard output each \"iprint\" steps",
                "id": "idm298149154176",
                "info": "Write stress tensor to standard output each \"iprint\" steps. It is set to .TRUE. automatically if calculation='vc-relax'"
            },
            "tprnfor": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "print forces",
                "id": "idm298149152208",
                "info": "print forces. Set to .TRUE. when ions are moving."
            },
            "dt": {
                "datatype": "real",
                "default": "1.D0",
                "options": {},
                "summary": "time step for molecular dynamics, in Hartree atomic units ",
                "id": "idm298149150480",
                "info": "time step for molecular dynamics, in Hartree atomic units (1 a.u.=2.4189 * 10^-17 s : beware, PW code use  Rydberg atomic units, twice that much!!!)"
            },
            "outdir": {
                "datatype": "string",
                "default": "value of the ESPRESSO_TMPDIR environment variable if set; current directory ('./') otherwise",
                "options": {},
                "summary": "input, temporary, trajectories and output files are found in this directory",
                "id": "idm298149148688",
                "info": "input, temporary, trajectories and output files are found in this directory."
            },
            "saverho": {
                "datatype": "boolean",
                "default": "",
                "options": {},
                "summary": "This flag controls the saving of charge density in CP codes",
                "id": "idm298149146800",
                "info": "This flag controls the saving of charge density in CP codes: If  .TRUE.        save charge density to restart dir, If .FALSE. do not save charge density."
            },
            "prefix": {
                "datatype": "string",
                "default": "cp",
                "options": {},
                "summary": "prepended to input/output filenames and restart folders",
                "id": "idm298149145376",
                "info": "prepended to input/output filenames and restart folders:   prefix.pos : atomic positions   prefix.vel : atomic velocities   prefix.for : atomic forces   prefix.cel : cell parameters   prefix.str : stress tensors   prefix.evp : energies   prefix.hrs : Hirshfeld effective volumes (ts-vdw)   prefix.eig : eigen values   prefix.nos : Nose-Hoover variables   prefix.spr : spread of Wannier orbitals   prefix.wfc : center of Wannier orbitals   prefix.ncg : number of Poisson CG steps (PBE0)   prefix_ndw.save/ : write restart folder   prefix_ndr.save/ : read restart folder where ndr and ndw are the integers number described below"
            },
            "ndr": {
                "datatype": "integer",
                "default": "50",
                "options": {},
                "summary": "The restart files are read from the folder   outdir/prefix_ndr",
                "id": "idm298149143072",
                "info": "The restart files are read from the folder   outdir/prefix_ndr.save/ where outdir, prefix and ndr are the input variables described in this document"
            },
            "ndw": {
                "datatype": "integer",
                "default": "50",
                "options": {},
                "summary": "The restart files are write in the folder   outdir/prefix_ndw",
                "id": "idm298149141280",
                "info": "The restart files are write in the folder   outdir/prefix_ndw.save/ where outdir, prefix and ndw are the input variables described in this document"
            },
            "tabps": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "",
                "id": "idm298149139488",
                "info": ".true. to compute the volume and/or the surface of an isolated system for finite pressure/finite surface tension calculations (PRL 94, 145501 (2005) (https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.94.145501); JCP 124, 074103 (2006))."
            },
            "max_seconds": {
                "datatype": "real",
                "default": "1.D+7, or 150 days, i.e. no time limit",
                "options": {},
                "summary": "jobs stops after max_seconds CPU time",
                "id": "idm298149136880",
                "info": "jobs stops after max_seconds CPU time. Used to prevent a hard kill from the queuing system."
            },
            "etot_conv_thr": {
                "datatype": "real",
                "default": "1.0D-4",
                "options": {},
                "summary": "convergence threshold on total energy ",
                "id": "idm298149135072",
                "info": "convergence threshold on total energy (a.u) for ionic minimization: the convergence criterion is satisfied when the total energy changes less than etot_conv_thr between two consecutive scf steps. See also forc_conv_thr - both criteria must be satisfied"
            },
            "forc_conv_thr": {
                "datatype": "real",
                "default": "1.0D-3",
                "options": {},
                "summary": "convergence threshold on forces ",
                "id": "idm298149133136",
                "info": "convergence threshold on forces (a.u) for ionic minimization: the convergence criterion is satisfied when all components of all forces are smaller than forc_conv_thr. See also etot_conv_thr - both criteria must be satisfied"
            },
            "ekin_conv_thr": {
                "datatype": "real",
                "default": "1.0D-6",
                "options": {},
                "summary": "convergence criterion for electron minimization",
                "id": "idm298149131232",
                "info": "convergence criterion for electron minimization: convergence is achieved when \"ekin < ekin_conv_thr\". See also etot_conv_thr - both criteria must be satisfied."
            },
            "disk_io": {
                "datatype": "string",
                "default": "default",
                "options": {},
                "summary": "'high'",
                "id": "idm298149128896",
                "info": "'high': CP code will write Kohn-Sham wfc files and additional         information in data-file.xml in order to restart         with a PW calculation or to use postprocessing tools.         If disk_io is not set to 'high', the data file         written by CP will not be readable by PW or PostProc."
            },
            "memory": {
                "datatype": "string",
                "default": "default",
                "options": {},
                "summary": "'small'",
                "id": "idm298149126768",
                "info": "'small': NO LONGER IMPLEMENTED SINCE v.6.3          memory-saving tricks are implemented. Currently:          - the G-vectors are sorted only locally, not globally          - they are not collected and written to file          For large systems, the memory and time gain is sizable          but the resulting data files are not portable - use it          only if you do not need to re-read the data file"
            },
            "pseudo_dir": {
                "datatype": "string",
                "default": "value of the $ESPRESSO_PSEUDO environment variable if set; '$HOME/espresso/pseudo/' otherwise",
                "options": {},
                "summary": "directory containing pseudopotential files",
                "id": "idm298149124240",
                "info": "directory containing pseudopotential files"
            },
            "tefield": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "If ",
                "id": "idm298149122416",
                "info": "If .TRUE. a homogeneous finite electric field described through the modern theory of the polarization is applied."
            }
        },
        "system": {
            "ibrav": {
                "datatype": "integer",
                "default": "",
                "options": {
                    "0": "Lattice in CELL_PARAMETERS",
                    "1": "Cubic P (sc) lattice",
                    "2": "Cubic F (fcc) lattice",
                    "3": "Cubic I (bcc) lattice",
                    "-3": "Cubic I (bcc) lattice",
                    "4": "Hexagonal and Trigonal P lattice",
                    "5": "Trigonal Rhombohedral lattice, 3-fold axis c",
                    "-5": "Trigonal Rhombohedral lattice, 3-fold axis <111>",
                    "6": "Tetragonal P (st) lattice",
                    "7": "Tetragonal I (bct) lattice",
                    "8": "Orthorhombic P lattice",
                    "9": "Orthorhombic base-centered(bco) lattice",
                    "-9": "Orthorhombic base-centered(bco) lattice",
                    "91": "Orthorhombic one-face base-centered A-type lattice",
                    "10": "Orthorhombic face-centered lattice",
                    "11": "Orthorhombic body-centered lattice",
                    "12": "Monoclinic P, unique axis c lattice",
                    "-12": "Monoclinic P, unique axis b lattice",
                    "13": "Monoclinic base-centered lattice",
                    "-13": "Monoclinic base-centered lattice",
                    "14": "Triclinic lattice"
                },
                "summary": "Bravais lattice choice",
                "id": "idm298149120000",
                "info": "Bravais lattice choice"
            },
            "celldm": {
                "datatype": "realarray (6)",
                "default": "",
                "options": {},
                "summary": "Crystallographic constants ",
                "id": "idm298149117600",
                "info": "Crystallographic constants - see the \"ibrav\" variable. Specify either these OR A,B,C,cosAB,cosBC,cosAC NOT both. Only needed values (depending on \"ibrav\") must be specified alat = celldm(1) is the lattice parameter \"a\" (in BOHR) If ibrav=0, only celldm(1) is used if present; cell vectors are read from card CELL_PARAMETERS"
            },
            "A": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "a in ANGSTROM",
                "id": "idm298149114096",
                "info": "a in ANGSTROM"
            },
            "B": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "b in ANGSTROM",
                "id": "idm298149113456",
                "info": "b in ANGSTROM"
            },
            "C": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "c in ANGSTROM",
                "id": "idm298149112816",
                "info": "c in ANGSTROM"
            },
            "cosAB": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "cos angle between a and b ",
                "id": "idm298149112176",
                "info": "cos angle between a and b (gamma)"
            },
            "cosAC": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Traditional crystallographic constants",
                "id": "idm298149111552",
                "info": "Traditional crystallographic constants: a,b,c in ANGSTROM   cosAB = cosine of the angle between axis a and b (gamma)   cosAC = cosine of the angle between axis a and c (beta)   cosBC = cosine of the angle between axis b and c (alpha) The axis are chosen according to the value of \"ibrav\". Specify either these OR \"celldm\" but NOT both. Only needed values (depending on \"ibrav\") must be specified The lattice parameter alat = A (in ANGSTROM ) If ibrav = 0, only A is used if present; cell vectors are read from card CELL_PARAMETERS"
            },
            "cosBC": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "cos angle between b and c ",
                "id": "idm298149110928",
                "info": "cos angle between b and c (alpha)"
            },
            "nat": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "number of atoms in the unit cell",
                "id": "idm298149109088",
                "info": "number of atoms in the unit cell"
            },
            "ntyp": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "number of types of atoms in the unit cell",
                "id": "idm298149107392",
                "info": "number of types of atoms in the unit cell"
            },
            "nbnd": {
                "datatype": "integer",
                "default": "for an insulator, nbnd = number of valence bands (nbnd = # of electrons /2); for a metal, 20% more (minimum 4 more)",
                "options": {},
                "summary": "number of electronic states ",
                "id": "idm298149105664",
                "info": "number of electronic states (bands) to be calculated. Note that in spin-polarized calculations the number of k-point, not the number of bands per k-point, is doubled"
            },
            "tot_charge": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "total charge of the system",
                "id": "idm298149103712",
                "info": "total charge of the system. Useful for simulations with charged cells. By default the unit cell is assumed to be neutral (tot_charge=0). tot_charge=+1 means one electron missing from the system, tot_charge=-1 means one additional electron, and so on.  In a periodic calculation a compensating jellium background is inserted to remove divergences if the cell is not neutral."
            },
            "tot_magnetization": {
                "datatype": "real",
                "default": "-1 [unspecified]",
                "options": {},
                "summary": "total majority spin charge ",
                "id": "idm298149101664",
                "info": "total majority spin charge - minority spin charge. Used to impose a specific total electronic magnetization. If unspecified, the tot_magnetization variable is ignored and the electronic magnetization is determined by the occupation numbers (see card OCCUPATIONS) read from input."
            },
            "ecutwfc": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "kinetic energy cutoff ",
                "id": "idm298149099680",
                "info": "kinetic energy cutoff (Ry) for wavefunctions"
            },
            "ecutrho": {
                "datatype": "real",
                "default": "4 * ecutwfc",
                "options": {},
                "summary": "kinetic energy cutoff ",
                "id": "idm298149097952",
                "info": "kinetic energy cutoff (Ry) for charge density and potential For norm-conserving pseudopotential you should stick to the default value, you can reduce it by a little but it will introduce noise especially on forces and stress. If there are ultrasoft PP, a larger value than the default is often desirable (ecutrho = 8 to 12 times ecutwfc, typically). PAW datasets can often be used at 4*ecutwfc, but it depends on the shape of augmentation charge: testing is mandatory. The use of gradient-corrected functional, especially in cells with vacuum, or for pseudopotential without non-linear core correction, usually requires an higher values of ecutrho to be accurately converged."
            },
            "nr1": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "three",
                "id": "idm298149095344",
                "info": "three-dimensional FFT mesh (hard grid) for charge density (and scf potential). If not specified the grid is calculated based on the cutoff for charge density."
            },
            "nr2": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "three",
                "id": "idm298149094736",
                "info": "three-dimensional FFT mesh (hard grid) for charge density (and scf potential). If not specified the grid is calculated based on the cutoff for charge density."
            },
            "nr3": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "three",
                "id": "idm298149094128",
                "info": "three-dimensional FFT mesh (hard grid) for charge density (and scf potential). If not specified the grid is calculated based on the cutoff for charge density."
            },
            "nr1s": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "three",
                "id": "idm298149092512",
                "info": "three-dimensional mesh for wavefunction FFT and for the smooth part of charge density ( smooth grid ). Coincides with nr1, nr2, nr3 if ecutrho = 4 * ecutwfc ( default )"
            },
            "nr2s": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "three",
                "id": "idm298149091888",
                "info": "three-dimensional mesh for wavefunction FFT and for the smooth part of charge density ( smooth grid ). Coincides with nr1, nr2, nr3 if ecutrho = 4 * ecutwfc ( default )"
            },
            "nr3s": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "three",
                "id": "idm298149091264",
                "info": "three-dimensional mesh for wavefunction FFT and for the smooth part of charge density ( smooth grid ). Coincides with nr1, nr2, nr3 if ecutrho = 4 * ecutwfc ( default )"
            },
            "nr1b": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "dimensions of the \"box\" grid for Ultrasoft pseudopotentials must be specified if Ultrasoft PP are present",
                "id": "idm298149089440",
                "info": "dimensions of the \"box\" grid for Ultrasoft pseudopotentials must be specified if Ultrasoft PP are present"
            },
            "nr2b": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "dimensions of the \"box\" grid for Ultrasoft pseudopotentials must be specified if Ultrasoft PP are present",
                "id": "idm298149088816",
                "info": "dimensions of the \"box\" grid for Ultrasoft pseudopotentials must be specified if Ultrasoft PP are present"
            },
            "nr3b": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "dimensions of the \"box\" grid for Ultrasoft pseudopotentials must be specified if Ultrasoft PP are present",
                "id": "idm298149088192",
                "info": "dimensions of the \"box\" grid for Ultrasoft pseudopotentials must be specified if Ultrasoft PP are present"
            },
            "occupations": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "a string describing the occupation of the electronic states",
                "id": "idm298149086784",
                "info": "a string describing the occupation of the electronic states. In the case of conjugate gradient style of minimization of the electronic states, if occupations is set to 'ensemble', this allows ensemble DFT calculations for metallic systems"
            },
            "degauss": {
                "datatype": "real",
                "default": "0.D0 Ry",
                "options": {},
                "summary": "parameter for the smearing function, only used for ensemble DFT calculations",
                "id": "idm298149085184",
                "info": "parameter for the smearing function, only used for ensemble DFT calculations"
            },
            "smearing": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "a string describing the kind of occupations for electronic states in the case of ensemble DFT ",
                "id": "idm298149083424",
                "info": "a string describing the kind of occupations for electronic states in the case of ensemble DFT (occupations == 'ensemble' ); now only Fermi-Dirac ('fd') case is implemented"
            },
            "nspin": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "nspin = 1 ",
                "id": "idm298149081936",
                "info": "nspin = 1 :  non-polarized calculation (default)  nspin = 2 :  spin-polarized calculation, LSDA              (magnetization along z axis)"
            },
            "ecfixed": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "",
                "id": "idm298149080128",
                "info": ""
            },
            "qcutz": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "",
                "id": "idm298149078448",
                "info": ""
            },
            "q2sigma": {
                "datatype": "real",
                "default": "0.1",
                "options": {},
                "summary": "ecfixed, qcutz, q2sigma",
                "id": "idm298149076768",
                "info": "ecfixed, qcutz, q2sigma:  parameters for modified functional to be used in variable-cell molecular dynamics (or in stress calculation). \"ecfixed\" is the value (in Rydberg) of the constant-cutoff; \"qcutz\" and \"q2sigma\" are the height and the width (in Rydberg) of the energy step for reciprocal vectors whose square modulus is greater than \"ecfixed\". In the kinetic energy, G^2 is replaced by G^2 + qcutz * (1 + erf ( (G^2 - ecfixed)/q2sigma) ) See: M. Bernasconi et al, J. Phys. Chem. Solids 56, 501 (1995)"
            },
            "input_dft": {
                "datatype": "string",
                "default": "read from pseudopotential files",
                "options": {},
                "summary": "Exchange",
                "id": "idm298149074320",
                "info": "Exchange-correlation functional: eg 'PBE', 'BLYP' etc See Modules/funct.f90 for allowed values. Overrides the value read from pseudopotential files. Use with care and if you know what you are doing!  Use 'PBE0' to perform hybrid functional calculation using Wannier functions. Allowed calculation: 'cp-wf' and 'vc-cp-wf' See CP specific user manual for further guidance (or in CPV/Doc/user_guide.tex) and examples in CPV/examples/EXX-wf-example. Also see related keywords starting with exx_."
            },
            "exx_fraction": {
                "datatype": "real",
                "default": "it depends on the specified functional",
                "options": {},
                "summary": "Fraction of EXX for hybrid functional calculations",
                "id": "idm298149072640",
                "info": "Fraction of EXX for hybrid functional calculations. In the case of input_dft='PBE0', the default value is 0.25."
            },
            "lda_plus_u": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "lda_plus_u = ",
                "id": "idm298149070784",
                "info": "lda_plus_u = .TRUE. enables calculation with LDA+U                   (\"rotationally invariant\"). See also Hubbard_U.                   Anisimov, Zaanen, and Andersen, PRB 44, 943 (1991) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.44.943);                   Anisimov et al., PRB 48, 16929 (1993) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.48.16929);                   Liechtenstein, Anisimov, and Zaanen, PRB 52, R5467 (1994) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.52.R5467);                   Cococcioni and de Gironcoli, PRB 71, 035105 (2005) (https://journals.aps.org/prb/abstract/10.1103/PhysRevB.71.035105)."
            },
            "Hubbard_U": {
                "datatype": "realarray (ntyp)",
                "default": "0.D0 for all species",
                "options": {},
                "summary": "Hubbard_U",
                "id": "idm298149065648",
                "info": "Hubbard_U(i): parameter U (in eV) for LDA+U calculations. Currently only the simpler, one-parameter LDA+U is implemented (no \"alpha\" or \"J\" terms)"
            },
            "vdw_corr": {
                "datatype": "string",
                "default": "none",
                "options": {},
                "summary": "Type of Van der Waals correction",
                "id": "idm298149062720",
                "info": "Type of Van der Waals correction. Allowed values:     'grimme-d2', 'Grimme-D2', 'DFT-D', 'dft-d': semiempirical Grimme's DFT-D2.     Optional variables: \"london_s6\", \"london_rcut\"     S. Grimme, J. Comp. Chem. 27, 1787 (2006),     V. Barone et al., J. Comp. Chem. 30, 934 (2009).      'TS', 'ts', 'ts-vdw', 'ts-vdW', 'tkatchenko-scheffler': Tkatchenko-Scheffler      dispersion corrections with first-principle derived C6 coefficients      Optional variables: \"ts_vdw_econv_thr\", \"ts_vdw_isolated\"      See A. Tkatchenko and M. Scheffler, Phys. Rev. Lett. 102, 073005 (2009)      'XDM', 'xdm': Exchange-hole dipole-moment model. Optional variables: \"xdm_a1\", \"xdm_a2\"      (implemented in PW only)      A. D. Becke and E. R. Johnson, J. Chem. Phys. 127, 154108 (2007)       A. Otero de la Roza, E. R. Johnson, J. Chem. Phys. 136, 174109 (2012)  Note that non-local functionals (eg vdw-DF) are NOT specified here but in \"input_dft\""
            },
            "london_s6": {
                "datatype": "real",
                "default": "0.75",
                "options": {},
                "summary": "global scaling parameter for DFT",
                "id": "idm298149061056",
                "info": "global scaling parameter for DFT-D. Default is good for PBE."
            },
            "london_rcut": {
                "datatype": "real",
                "default": "200",
                "options": {},
                "summary": "cutoff radius ",
                "id": "idm298149059312",
                "info": "cutoff radius (a.u.) for dispersion interactions"
            },
            "ts_vdw": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "OBSOLESCENT, same as vdw_corr='TS'",
                "id": "idm298149057616",
                "info": "OBSOLESCENT, same as vdw_corr='TS'"
            },
            "ts_vdw_econv_thr": {
                "datatype": "real",
                "default": "1.D-6",
                "options": {},
                "summary": "Optional",
                "id": "idm298149055872",
                "info": "Optional: controls the convergence of the vdW energy (and forces). The default value is a safe choice, likely too safe, but you do not gain much in increasing it"
            },
            "ts_vdw_isolated": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "Optional",
                "id": "idm298149054016",
                "info": "Optional: set it to .TRUE. when computing the Tkatchenko-Scheffler vdW energy for an isolated (non-periodic) system."
            },
            "assume_isolated": {
                "datatype": "string",
                "default": "none",
                "options": {},
                "summary": "Used to perform calculation assuming the system to be isolated ",
                "id": "idm298149052224",
                "info": "Used to perform calculation assuming the system to be isolated (a molecule of a clustr in a 3D supercell).  Currently available choices:  'none' (default): regular periodic calculation w/o any correction.  'makov-payne', 'm-p', 'mp' : the Makov-Payne correction to the          total energy is computed.          Theory:          G.Makov, and M.C.Payne,          \"Periodic boundary conditions in ab initio          calculations\" , Phys.Rev.B 51, 4014 (1995)"
            }
        },
        "electrons": {
            "electron_maxstep": {
                "datatype": "integer",
                "default": "100",
                "options": {},
                "summary": "maximum number of iterations in a scf step",
                "id": "idm298149049104",
                "info": "maximum number of iterations in a scf step"
            },
            "electron_dynamics": {
                "datatype": "string",
                "default": "none",
                "options": {},
                "summary": "set how electrons should be moved 'none'    ",
                "id": "idm298149047376",
                "info": "set how electrons should be moved 'none'    : electronic degrees of freedom (d.o.f.) are kept fixed 'sd'      : steepest descent algorithm is used to minimize           electronic d.o.f. 'damp'    : damped dynamics is used to propagate electronic d.o.f. 'verlet'  : standard Verlet algorithm is used to propagate           electronic d.o.f. 'cg'      : conjugate gradient is used to converge the           wavefunction at each ionic step. 'cg' can be used           interchangeably with 'verlet' for a couple of ionic           steps in order to \"cool down\" the electrons and           return them back to the Born-Oppenheimer surface.           Then 'verlet' can be restarted again. This procedure           is useful when electronic adiabaticity in CP is lost           yet the ionic velocities need to be preserved."
            },
            "conv_thr": {
                "datatype": "real",
                "default": "1.D-6",
                "options": {},
                "summary": "Convergence threshold for selfconsistency",
                "id": "idm298149045696",
                "info": "Convergence threshold for selfconsistency: estimated energy error < conv_thr"
            },
            "niter_cg_restart": {
                "datatype": "integer",
                "default": "20",
                "options": {},
                "summary": "frequency in iterations for which the conjugate",
                "id": "idm298149043856",
                "info": "frequency in iterations for which the conjugate-gradient algorithm for electronic relaxation is restarted"
            },
            "efield": {
                "datatype": "real",
                "default": "0.D0",
                "options": {},
                "summary": "Amplitude of the finite electric field ",
                "id": "idm298149042096",
                "info": "Amplitude of the finite electric field (in a.u.; 1 a.u. = 51.4220632*10^10 V/m). Used only if tefield=.TRUE."
            },
            "epol": {
                "datatype": "integer",
                "default": "3",
                "options": {},
                "summary": "direction of the finite electric field ",
                "id": "idm298149040320",
                "info": "direction of the finite electric field (only if tefield == .TRUE.) In the case of a PARALLEL calculation only the case epol==3 is implemented"
            },
            "emass": {
                "datatype": "real",
                "default": "400.D0",
                "options": {},
                "summary": "effective electron mass in the CP Lagrangian, in atomic units ",
                "id": "idm298149038512",
                "info": "effective electron mass in the CP Lagrangian, in atomic units ( 1 a.u. of mass = 1/1822.9 a.m.u. = 9.10939 * 10^-31 kg )"
            },
            "emass_cutoff": {
                "datatype": "real",
                "default": "2.5D0",
                "options": {},
                "summary": "mass cut",
                "id": "idm298149036704",
                "info": "mass cut-off (in Rydberg) for the Fourier acceleration effective mass is rescaled for \"G\" vector components with kinetic energy above \"emass_cutoff\""
            },
            "orthogonalization": {
                "datatype": "string",
                "default": "ortho",
                "options": {},
                "summary": "selects the orthonormalization method for electronic wave functions 'ortho'        ",
                "id": "idm298149034848",
                "info": "selects the orthonormalization method for electronic wave functions 'ortho'        : use iterative algorithm - if it doesn't converge,                  reduce the timestep, or use options ortho_max                  and ortho_eps, or use Gram-Schmidt instead just                  to start the simulation 'Gram-Schmidt' : use Gram-Schmidt algorithm - to be used ONLY in                  the first few steps.                  YIELDS INCORRECT ENERGIES AND EIGENVALUES."
            },
            "ortho_eps": {
                "datatype": "real",
                "default": "1.D-8",
                "options": {},
                "summary": "tolerance for iterative orthonormalization meaningful only if orthogonalization = 'ortho'",
                "id": "idm298149032512",
                "info": "tolerance for iterative orthonormalization meaningful only if orthogonalization = 'ortho'"
            },
            "ortho_max": {
                "datatype": "integer",
                "default": "300",
                "options": {},
                "summary": "maximum number of iterations for orthonormalization meaningful only if orthogonalization = 'ortho'",
                "id": "idm298149030672",
                "info": "maximum number of iterations for orthonormalization meaningful only if orthogonalization = 'ortho'"
            },
            "ortho_para": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "",
                "id": "idm298149028832",
                "info": ""
            },
            "electron_damping": {
                "datatype": "real",
                "default": "0.1D0",
                "options": {},
                "summary": "damping frequency times delta t, optimal values could be calculated with the formula ",
                "id": "idm298149026720",
                "info": "damping frequency times delta t, optimal values could be calculated with the formula :          SQRT( 0.5 * LOG( ( E1 - E2 ) / ( E2 - E3 ) ) ) where E1, E2, E3 are successive values of the DFT total energy in a steepest descent simulations. meaningful only if \" electron_dynamics = 'damp' \""
            },
            "electron_velocities": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "zero'      ",
                "id": "idm298149024512",
                "info": "zero'      : restart setting electronic velocities to zero 'default'   : restart using electronic velocities of the             previous run 'change_step' : restart simulation using electronic velocities of the             previous run, with rescaling due to the timestep change.             specify the old step via tolp as in             tolp = 'old_time_step_value' in au.             Note that you may want to specify             ion_velocities = 'change_step"
            },
            "electron_temperature": {
                "datatype": "string",
                "default": "not_controlled",
                "options": {},
                "summary": "'nose'            ",
                "id": "idm298149021168",
                "info": "'nose'            : control electronic temperature using Nose                   thermostat. See also \"fnosee\" and \"ekincw\". 'rescaling'       : control electronic temperature via velocities                   rescaling. 'not_controlled'  : electronic temperature is not controlled."
            },
            "ekincw": {
                "datatype": "real",
                "default": "0.001D0",
                "options": {},
                "summary": "value of the average kinetic energy ",
                "id": "idm298149018976",
                "info": "value of the average kinetic energy (in atomic units) forced by the temperature control meaningful only with \" electron_temperature /= 'not_controlled' \""
            },
            "fnosee": {
                "datatype": "real",
                "default": "1.D0",
                "options": {},
                "summary": "oscillation frequency of the nose thermostat ",
                "id": "idm298149017088",
                "info": "oscillation frequency of the nose thermostat (in terahertz) meaningful only with \" electron_temperature = 'nose' \""
            },
            "startingwfc": {
                "datatype": "string",
                "default": "random",
                "options": {},
                "summary": "'atomic'",
                "id": "idm298149015264",
                "info": "'atomic': start from superposition of atomic orbitals           (not yet implemented)   'random': start from random wfcs. See \"ampre\"."
            },
            "tcg": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "if ",
                "id": "idm298149013392",
                "info": "if .TRUE. perform a conjugate gradient minimization of the electronic states for every ionic step. It requires Gram-Schmidt orthogonalization of the electronic states."
            },
            "maxiter": {
                "datatype": "integer",
                "default": "100",
                "options": {},
                "summary": "maximum number of conjugate gradient iterations for conjugate gradient minimizations of electronic states",
                "id": "idm298149011552",
                "info": "maximum number of conjugate gradient iterations for conjugate gradient minimizations of electronic states"
            },
            "passop": {
                "datatype": "real",
                "default": "0.3D0",
                "options": {},
                "summary": "small step used in the  conjugate gradient minimization of the electronic states",
                "id": "idm298149009776",
                "info": "small step used in the  conjugate gradient minimization of the electronic states."
            },
            "pre_state": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "if ",
                "id": "idm298149008016",
                "info": "if .TRUE. perform the precondition of the CG gradient using the kinetic energy of the state."
            },
            "n_inner": {
                "datatype": "integer",
                "default": "2",
                "options": {},
                "summary": "number of internal cycles for every conjugate gradient iteration only for ensemble DFT",
                "id": "idm298149006240",
                "info": "number of internal cycles for every conjugate gradient iteration only for ensemble DFT"
            },
            "ninter_cold_restart": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "frequency in iterations at which a full inner cycle, only for cold smearing, is performed",
                "id": "idm298149004480",
                "info": "frequency in iterations at which a full inner cycle, only for cold smearing, is performed"
            },
            "lambda_cold": {
                "datatype": "real",
                "default": "0.03D0",
                "options": {},
                "summary": "step for inner cycle with cold smearing, used when a not full cycle is performed",
                "id": "idm298149002704",
                "info": "step for inner cycle with cold smearing, used when a not full cycle is performed"
            },
            "grease": {
                "datatype": "real",
                "default": "1.D0",
                "options": {},
                "summary": "a number <= 1, very close to 1",
                "id": "idm298149000944",
                "info": "a number <= 1, very close to 1: the damping in electronic damped dynamics is multiplied at each time step by \"grease\" (avoids overdamping close to convergence: Obsolete ?) grease = 1 : normal damped dynamics"
            },
            "ampre": {
                "datatype": "real",
                "default": "0.D0",
                "options": {},
                "summary": "amplitude of the randomization ",
                "id": "idm298148999040",
                "info": "amplitude of the randomization ( allowed values: 0.0 - 1.0 ) meaningful only if \" startingwfc = 'random' \""
            }
        },
        "ions": {
            "ion_dynamics": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "Specify the type of ionic dynamics",
                "id": "idm298148996000",
                "info": "Specify the type of ionic dynamics.   For constrained dynamics or constrained optimisations add the  CONSTRAINTS card (when the card is present the SHAKE algorithm is                    automatically used). 'none'    : ions are kept fixed 'sd'      : steepest descent algorithm is used to minimize ionic             configuration 'cg'      : conjugate gradient algorithm is used to minimize ionic             configuration 'damp'    : damped dynamics is used to propagate ions 'verlet'  : standard Verlet algorithm is used to propagate ions"
            },
            "ion_positions": {
                "datatype": "string",
                "default": "default",
                "options": {},
                "summary": "'default '  ",
                "id": "idm298148994752",
                "info": "'default '  : if restarting, use atomic positions read from the               restart file; in all other cases, use atomic               positions from standard input.  'from_input' : restart the simulation with atomic positions read               from standard input, even if restarting."
            },
            "ion_velocities": {
                "datatype": "string",
                "default": "default",
                "options": {},
                "summary": "initial ionic velocities 'default'     ",
                "id": "idm298148992688",
                "info": "initial ionic velocities 'default'     : restart the simulation with atomic velocities read                 from the restart file 'change_step' : restart the simulation with atomic velocities read                 from the restart file, with rescaling due to the                 timestep change, specify the old step via tolp                 as in tolp = 'old_time_step_value' in au.                 Note that you may want to specify                 electron_velocities = 'change_step' 'random'      : start the simulation with random atomic velocities                 (see also variable tempw) 'from_input'  : restart the simulation with atomic velocities read                 from standard input - see card 'ATOMIC_VELOCITIES'                 BEWARE: tested only with electrons_dynamics='cg' 'zero'        : restart the simulation with atomic velocities set                 to zero"
            },
            "ion_damping": {
                "datatype": "real",
                "default": "0.2D0",
                "options": {},
                "summary": "damping frequency times delta t, optimal values could be   calculated with the formula ",
                "id": "idm298148987776",
                "info": "damping frequency times delta t, optimal values could be   calculated with the formula :   SQRT( 0.5 * LOG( ( E1 - E2 ) / ( E2 - E3 ) ) )   where E1, E2, E3 are successive values of the DFT total energy   in a steepest descent simulations.   meaningful only if \" ion_dynamics = 'damp' \""
            },
            "ion_radius": {
                "datatype": "realarray (ntyp)",
                "default": "0.5 a.u. for all species",
                "options": {},
                "summary": "ion_radius",
                "id": "idm298148985584",
                "info": "ion_radius(i): pseudo-atomic radius of the i-th atomic species used in Ewald summation. Typical values: between 0.5 and 2. Results should NOT depend upon such parameters if their values are properly chosen. See also \"iesr\"."
            },
            "iesr": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "The real",
                "id": "idm298148982992",
                "info": "The real-space contribution to the Ewald summation is performed on iesr*iesr*iesr cells. Typically iesr=1 is sufficient to have converged results."
            },
            "ion_nstepe": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "number of electronic steps per ionic step",
                "id": "idm298148981184",
                "info": "number of electronic steps per ionic step."
            },
            "remove_rigid_rot": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "This keyword is useful when simulating the dynamics and/or the thermodynamics of an isolated system",
                "id": "idm298148979472",
                "info": "This keyword is useful when simulating the dynamics and/or the thermodynamics of an isolated system. If set to true the total torque of the internal forces is set to zero by adding new forces that compensate the spurious interaction with the periodic images. This allows for the use of smaller supercells.  BEWARE: since the potential energy is no longer consistent with the forces (it still contains the spurious interaction with the repeated images), the total energy is not conserved anymore. However the dynamical and thermodynamical properties should be in closer agreement with those of an isolated system. Also the final energy of a structural relaxation will be higher, but the relaxation itself should be faster."
            },
            "ion_temperature": {
                "datatype": "string",
                "default": "not_controlled",
                "options": {},
                "summary": "'nose'           ",
                "id": "idm298148977056",
                "info": "'nose'           : control ionic temperature using Nose-Hoover                    thermostat  see parameters \"fnosep\", \"tempw\",                    \"nhpcl\", \"ndega\", \"nhptyp\" 'rescaling'      : control ionic temperature via velocities                    rescaling. see parameter \"tolp\" 'not_controlled' : ionic temperature is not controlled"
            },
            "tempw": {
                "datatype": "real",
                "default": "300.D0",
                "options": {},
                "summary": "value of the ionic temperature ",
                "id": "idm298148974688",
                "info": "value of the ionic temperature (in Kelvin) forced by the temperature control. meaningful only with \" ion_temperature /= 'not_controlled' \" or when the initial velocities are set to 'random' \"ndega\" controls number of degrees of freedom used in temperature calculation"
            },
            "fnosep": {
                "datatype": "real",
                "default": "1.D0",
                "options": {},
                "summary": "oscillation frequency of the nose thermostat ",
                "id": "idm298148972448",
                "info": "oscillation frequency of the nose thermostat (in terahertz) [note that 3 terahertz = 100 cm^-1] meaningful only with \" ion_temperature = 'nose' \" for Nose-Hoover chain one can set frequencies of all thermostats ( fnosep = X Y Z etc. ) If only first is set, the defaults for the others will be same."
            },
            "tolp": {
                "datatype": "real",
                "default": "100.D0",
                "options": {},
                "summary": "tolerance ",
                "id": "idm298148969984",
                "info": "tolerance (in Kelvin) of the rescaling. When ionic temperature differs from \"tempw\" more than \"tolp\" apply rescaling. meaningful only with ion_temperature = 'rescaling' or with ion_velocities='change_step', where it specifies the old timestep"
            },
            "nhpcl": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "number of thermostats in the Nose",
                "id": "idm298148967136",
                "info": "number of thermostats in the Nose-Hoover chain currently maximum allowed is 4"
            },
            "nhptyp": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "type of the \"massive\" Nose",
                "id": "idm298148965392",
                "info": "type of the \"massive\" Nose-Hoover chain thermostat nhptyp=1 uses a NH chain per each atomic type nhptyp=2 uses a NH chain per atom, this one is useful for extremely rapid equipartitioning (equilibration is a different beast) nhptyp=3 together with nhgrp allows fine grained thermostat control NOTE: if using more than 1 thermostat per system there will be a common thermostat added on top of them all, to disable this common thermostat specify nhptyp=-X instead of nhptyp=X"
            },
            "nhgrp": {
                "datatype": "integerarray (ntyp)",
                "default": "0",
                "options": {},
                "summary": "specifies which thermostat group to use for given atomic type when >0 assigns all the atoms in this type to thermostat labeled nhgrp",
                "id": "idm298148962752",
                "info": "specifies which thermostat group to use for given atomic type when >0 assigns all the atoms in this type to thermostat labeled nhgrp(i), when =0 each atom in the type gets its own thermostat. Finally, when <0, then this atomic type will have temperature \"not controlled\". Example: HCOOLi, with types H (1), C(2), O(3), Li(4); setting nhgrp={2 2 0 -1} will add a common thermostat for both H & C, one thermostat per each O (2 in total), and a non-updated thermostat for Li which will effectively make temperature for Li \"not controlled\""
            },
            "fnhscl": {
                "datatype": "realarray (ntyp)",
                "default": "(Nat_{total}-1)/Nat_{total}",
                "options": {},
                "summary": "these are the scaling factors to be used together with nhptyp=3 and nhgrp",
                "id": "idm298148960080",
                "info": "these are the scaling factors to be used together with nhptyp=3 and nhgrp(i) in order to take care of possible reduction in the degrees of freedom due to constraints. Suppose that with the previous example HCOOLi, C-H bond is constrained. Then, these 2 atoms will have 5 degrees of freedom in total instead of 6, and one can set fnhscl={5/6 5/6 1. 1.}. This way the target kinetic energy for H&C will become 6(kT/2)*5/6 = 5(kT/2). This option is to be used for simulations with many constraints, such as rigid water with something else in there"
            },
            "ndega": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "number of degrees of freedom used for temperature calculation ndega <= 0 sets the number of degrees of freedom to [3*nat",
                "id": "idm298148957136",
                "info": "number of degrees of freedom used for temperature calculation ndega <= 0 sets the number of degrees of freedom to [3*nat-abs(ndega)], ndega > 0 is used as the target number"
            },
            "tranp": {
                "datatype": "booleanarray (ntyp)",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm298148955200",
                "info": "If .TRUE. randomize ionic positions for the atomic type corresponding to the index."
            },
            "amprp": {
                "datatype": "realarray (ntyp)",
                "default": "0.D0",
                "options": {},
                "summary": "amplitude of the randomization for the atomic type corresponding to the index i ",
                "id": "idm298148952560",
                "info": "amplitude of the randomization for the atomic type corresponding to the index i ( allowed values: 0.0 - 1.0 ). meaningful only if \" tranp(i) = .TRUE.\"."
            },
            "greasp": {
                "datatype": "real",
                "default": "1.D0",
                "options": {},
                "summary": "same as \"grease\", for ionic damped dynamics",
                "id": "idm298148949760",
                "info": "same as \"grease\", for ionic damped dynamics."
            }
        },
        "cell": {
            "cell_parameters": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "'default'      ",
                "id": "idm298148946880",
                "info": "'default'      : restart the simulation with cell parameters read                from the restart file or \"celldm\" if                \"restart = 'from_scratch'\" 'from_input'   : restart the simulation with cell parameters                from standard input.                ( see the card 'CELL_PARAMETERS' )"
            },
            "cell_dynamics": {
                "datatype": "string",
                "default": "none",
                "options": {},
                "summary": "set how cell should be moved 'none'      ",
                "id": "idm298148944896",
                "info": "set how cell should be moved 'none'      : cell is kept fixed 'sd'        : steepest descent algorithm is used to optimise the               cell 'damp-pr'   : damped dynamics is used to optimise the cell               ( Parrinello-Rahman method ). 'pr'        : standard Verlet algorithm is used to propagate               the cell ( Parrinello-Rahman method )."
            },
            "cell_velocities": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "'zero'      ",
                "id": "idm298148942800",
                "info": "'zero'      : restart setting cell velocity to zero 'default'   : restart using cell velocity of the previous run"
            },
            "cell_damping": {
                "datatype": "real",
                "default": "0.1D0",
                "options": {},
                "summary": "damping frequency times delta t, optimal values could be calculated with the formula ",
                "id": "idm298148941408",
                "info": "damping frequency times delta t, optimal values could be calculated with the formula :          SQRT( 0.5 * LOG( ( E1 - E2 ) / ( E2 - E3 ) ) ) where E1, E2, E3 are successive values of the DFT total energy in a steepest descent simulations. meaningful only if \" cell_dynamics = 'damp' \""
            },
            "press": {
                "datatype": "real",
                "default": "0.D0",
                "options": {},
                "summary": "Target pressure [KBar] in a variable",
                "id": "idm298148939216",
                "info": "Target pressure [KBar] in a variable-cell md or relaxation run."
            },
            "wmass": {
                "datatype": "real",
                "default": "0.75*Tot_Mass/pi**2 for Parrinello-Rahman MD; 0.75*Tot_Mass/pi**2/Omega**(2/3) for Wentzcovitch MD",
                "options": {},
                "summary": "Fictitious cell mass [amu] for variable",
                "id": "idm298148937488",
                "info": "Fictitious cell mass [amu] for variable-cell simulations (both 'vc-md' and 'vc-relax')"
            },
            "cell_factor": {
                "datatype": "real",
                "default": "1.2D0",
                "options": {},
                "summary": "Used in the construction of the pseudopotential tables",
                "id": "idm298148935600",
                "info": "Used in the construction of the pseudopotential tables. It should exceed the maximum linear contraction of the cell during a simulation."
            },
            "cell_temperature": {
                "datatype": "string",
                "default": "not_controlled",
                "options": {},
                "summary": "'nose'            ",
                "id": "idm298148933776",
                "info": "'nose'            : control cell temperature using Nose thermostat                     see parameters \"fnoseh\" and \"temph\". 'rescaling'       : control cell temperature via velocities                     rescaling. 'not_controlled'  : cell temperature is not controlled."
            },
            "temph": {
                "datatype": "real",
                "default": "0.D0",
                "options": {},
                "summary": "value of the cell temperature ",
                "id": "idm298148931600",
                "info": "value of the cell temperature (in ???) forced by the temperature control. meaningful only with \" cell_temperature /= 'not_controlled' \""
            },
            "fnoseh": {
                "datatype": "real",
                "default": "1.D0",
                "options": {},
                "summary": "oscillation frequency of the nose thermostat ",
                "id": "idm298148929744",
                "info": "oscillation frequency of the nose thermostat (in terahertz) meaningful only with \" cell_temperature = 'nose' \""
            },
            "greash": {
                "datatype": "real",
                "default": "1.D0",
                "options": {},
                "summary": "same as \"grease\", for cell damped dynamics",
                "id": "idm298148927920",
                "info": "same as \"grease\", for cell damped dynamics"
            },
            "cell_dofree": {
                "datatype": "string",
                "default": "all",
                "options": {},
                "summary": "Select which of the cell parameters should be moved",
                "id": "idm298148926144",
                "info": "Select which of the cell parameters should be moved:  all     = all axis and angles are moved x       = only the x component of axis 1 (v1_x) is moved y       = only the y component of axis 2 (v2_y) is moved z       = only the z component of axis 3 (v3_z) is moved xy      = only v1_x and v2_y are moved xz      = only v1_x and v3_z are moved yz      = only v2_y and v3_z are moved xyz     = only v1_x, v2_y, v3_z are moved shape   = all axis and angles, keeping the volume fixed 2Dxy    = only x and y components are allowed to change 2Dshape = as above, keeping the area in xy plane fixed volume  = isotropic variations of v1_x, v2_y, v3_z, keeping           the shape fixed. Should be used only with ibrav=1."
            }
        },
        "press_ai": {
            "abivol": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "",
                "id": "idm298148922656",
                "info": ".true. for finite pressure calculations"
            },
            "abisur": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "",
                "id": "idm298148920928",
                "info": ".true. for finite surface tension calculations"
            },
            "P_ext": {
                "datatype": "real",
                "default": "0.D0",
                "options": {},
                "summary": "external pressure in GPa",
                "id": "idm298148919200",
                "info": "external pressure in GPa"
            },
            "pvar": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "",
                "id": "idm298148917504",
                "info": ".true. for variable pressure calculations pressure changes linearly with time: Delta_P = (P_fin - P_in)/nstep"
            },
            "P_in": {
                "datatype": "real",
                "default": "0.D0",
                "options": {},
                "summary": "only if pvar = ",
                "id": "idm298148915712",
                "info": "only if pvar = .true. initial value of the external pressure (GPa)"
            },
            "P_fin": {
                "datatype": "real",
                "default": "0.D0",
                "options": {},
                "summary": "only if pvar = ",
                "id": "idm298148913984",
                "info": "only if pvar = .true. final value of the external pressure (GPa)"
            },
            "Surf_t": {
                "datatype": "real",
                "default": "0.D0",
                "options": {},
                "summary": "Surface tension ",
                "id": "idm298148912256",
                "info": "Surface tension (in a.u.; typical values 1.d-4 - 1.d-3)"
            },
            "rho_thr": {
                "datatype": "real",
                "default": "0.D0",
                "options": {},
                "summary": "threshold parameter which defines the electronic charge density isosurface to compute the 'quantum' volume of the system ",
                "id": "idm298148910528",
                "info": "threshold parameter which defines the electronic charge density isosurface to compute the 'quantum' volume of the system (typical values: 1.d-4 - 1.d-3) (corresponds to alpha in PRL 94 145501 (2005) (https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.94.145501))"
            },
            "dthr": {
                "datatype": "real",
                "default": "0.D0",
                "options": {},
                "summary": "thikness of the external skin of the electronic charge density used to compute the 'quantum' surface ",
                "id": "idm298148907952",
                "info": "thikness of the external skin of the electronic charge density used to compute the 'quantum' surface (typical values: 1.d-4 - 1.d-3; 50% to 100% of rho_thr) (corresponds to Delta in PRL 94 145501 (2005) (https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.94.145501))"
            }
        },
        "wannier": {
            "wf_efield": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If dynamics will be done in the presence of a field",
                "id": "idm298148903584",
                "info": "If dynamics will be done in the presence of a field"
            },
            "wf_switch": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "Whether to turn on the field adiabatically ",
                "id": "idm298148901856",
                "info": "Whether to turn on the field adiabatically (adiabatic switch) if true, then nbeg is set to 0."
            },
            "sw_len": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "No",
                "id": "idm298148900080",
                "info": "No. of iterations over which the field will be turned on to its final value. Starting value is 0.0 If sw_len < 0, then it is set to 1. If you want to just optimize structures on the presence of a field, then you may set this to 1 and run a regular geometry optimization."
            },
            "efx0": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Initial values of the field along x, y, and z directions",
                "id": "idm298148896736",
                "info": "Initial values of the field along x, y, and z directions"
            },
            "efy0": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Initial values of the field along x, y, and z directions",
                "id": "idm298148896112",
                "info": "Initial values of the field along x, y, and z directions"
            },
            "efz0": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Initial values of the field along x, y, and z directions",
                "id": "idm298148895488",
                "info": "Initial values of the field along x, y, and z directions"
            },
            "efx1": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Final values of the field along x, y, and z directions",
                "id": "idm298148893376",
                "info": "Final values of the field along x, y, and z directions"
            },
            "efy1": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Final values of the field along x, y, and z directions",
                "id": "idm298148892752",
                "info": "Final values of the field along x, y, and z directions"
            },
            "efz1": {
                "datatype": "real",
                "default": "",
                "options": {},
                "summary": "Final values of the field along x, y, and z directions",
                "id": "idm298148892128",
                "info": "Final values of the field along x, y, and z directions"
            },
            "wfsd": {
                "datatype": "integer",
                "default": "1",
                "options": {},
                "summary": "Localization algorithm for Wannier function calculation",
                "id": "idm298148890912",
                "info": "Localization algorithm for Wannier function calculation: wfsd=1  Damped Dynamics wfsd=2  Steepest-Descent / Conjugate-Gradient wfsd=3  Jocobi Rotation Remember, this is consistent with all the calwf options as well as the tolw (see below). Not a good idea to Wannier dynamics with this if you are using restart='from_scratch' option, since the spreads converge fast in the beginning and ortho goes bananas."
            },
            "wfdt": {
                "datatype": "real",
                "default": "5.D0",
                "options": {},
                "summary": "The minimum step size to take in the SD/CG direction",
                "id": "idm298148888624",
                "info": "The minimum step size to take in the SD/CG direction"
            },
            "maxwfdt": {
                "datatype": "real",
                "default": "0.3D0",
                "options": {},
                "summary": "The maximum step size to take in the SD/CG direction The code calculates an optimum step size, but that may be either too small ",
                "id": "idm298148886912",
                "info": "The maximum step size to take in the SD/CG direction The code calculates an optimum step size, but that may be either too small (takes forever to converge)  or too large (code goes crazy) . This option keeps the step size between wfdt and maxwfdt. In my experience 0.1 and 0.5 work quite well. (but don't blame me if it doesn't work for you)"
            },
            "nit": {
                "datatype": "integer",
                "default": "10",
                "options": {},
                "summary": "Number of iterations to do for Wannier convergence",
                "id": "idm298148884624",
                "info": "Number of iterations to do for Wannier convergence."
            },
            "nsd": {
                "datatype": "integer",
                "default": "10",
                "options": {},
                "summary": "Out of a total of NIT iterations, NSD will be Steepest",
                "id": "idm298148882928",
                "info": "Out of a total of NIT iterations, NSD will be Steepest-Descent and ( nit - nsd ) will be Conjugate-Gradient."
            },
            "wf_q": {
                "datatype": "real",
                "default": "1500.D0",
                "options": {},
                "summary": "Fictitious mass of the A matrix used for obtaining maximally localized Wannier functions",
                "id": "idm298148881168",
                "info": "Fictitious mass of the A matrix used for obtaining maximally localized Wannier functions. The unitary transformation matrix U is written as exp(A) where A is a anti-hermitian matrix. The Damped-Dynamics is performed in terms of the A matrix, and then U is computed from A. Usually a value between 1500 and 2500 works fine, but should be tested."
            },
            "wf_friction": {
                "datatype": "real",
                "default": "0.3D0",
                "options": {},
                "summary": "Damping coefficient for Damped",
                "id": "idm298148879136",
                "info": "Damping coefficient for Damped-Dynamics."
            },
            "nsteps": {
                "datatype": "integer",
                "default": "20",
                "options": {},
                "summary": "Number of Damped",
                "id": "idm298148877408",
                "info": "Number of Damped-Dynamics steps to be performed per CP iteration."
            },
            "tolw": {
                "datatype": "real",
                "default": "1.D-8",
                "options": {},
                "summary": "Convergence criterion for localization",
                "id": "idm298148875680",
                "info": "Convergence criterion for localization."
            },
            "adapt": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "Whether to adapt the damping parameter dynamically",
                "id": "idm298148873952",
                "info": "Whether to adapt the damping parameter dynamically."
            },
            "calwf": {
                "datatype": "integer",
                "default": "3",
                "options": {},
                "summary": "Wannier Function Options, can be 1,2,3,4,5  1",
                "id": "idm298148872224",
                "info": "Wannier Function Options, can be 1,2,3,4,5  1. Output the Wannier function density, nwf and wffort    are used for this option. see below. 2. Output the Overlap matrix O_i,j=<w_i|exp{iGr}|w_j>. O is    written to unit 38. For details on how O is constructed,    see below. 3. Perform nsteps of Wannier dynamics per CP iteration, the    orbitals are now Wannier Functions, not Kohn-Sham orbitals.    This is a Unitary transformation of the occupied subspace    and does not leave the CP Lagrangian invariant. Expectation    values remain the same. So you will **NOT** have a constant    of motion during the run. Don't freak out, its normal. 4. This option starts for the KS states and does 1 CP iteration    and nsteps of Damped-Dynamics to generate  maximally    localized wannier functions. Its useful when you have the    converged KS groundstate and want to get to the converged    Wannier function groundstate in 1 CP Iteration. 5. This option is similar to calwf 1, except that the output is    the Wannier function/wavefunction, and not the orbital    density. See nwf below."
            },
            "nwf": {
                "datatype": "integer",
                "default": "0",
                "options": {},
                "summary": "This option is used with calwf 1 and calwf 5",
                "id": "idm298148870464",
                "info": "This option is used with calwf 1 and calwf 5. with calwf=1, it tells the code how many Orbital densities are to be output. With calwf=5, set this to 1(i.e calwf=5 only writes one state during one run. so if you want 10 states, you have to run the code 10 times). With calwf=1, you can print many orbital densities in a single run. See also the PLOT_WANNIER card for specifying the states to be printed."
            },
            "wffort": {
                "datatype": "integer",
                "default": "40",
                "options": {},
                "summary": "This tells the code where to dump the orbital densities",
                "id": "idm298148868496",
                "info": "This tells the code where to dump the orbital densities. Used  only with CALWF=1. for e.g. if you want to print 2 orbital  densities, set calwf=1, nwf=2 and wffort to an appropriate  number (e.g. 40) then the first orbital density will be  output to fort.40, the second to fort.41 and so on. Note that  in the current implementation, the following units are used  21,22,24,25,26,27,28,38,39,77,78 and whatever you define as  ndr and ndw. so use number other than these."
            },
            "writev": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "Output the charge density ",
                "id": "idm298148866352",
                "info": "Output the charge density (g-space) and the list of g-vectors This is useful if you want to reconstruct the electrostatic potential using the Poisson equation. If .TRUE. then the code will output the g-space charge density and the list if G-vectors, and STOP. Charge density is written to : CH_DEN_G_PARA.ispin (1 or 2 depending on the number of spin types) or CH_DEN_G_SERL.ispin depending on if the code is being run in parallel or serial G-vectors are written to G_PARA or G_SERL."
            },
            "exx_neigh": {
                "datatype": "integer",
                "default": "60",
                "options": {},
                "summary": "An initial guess on the maximum number of neighboring ",
                "id": "idm298148864192",
                "info": "An initial guess on the maximum number of neighboring (overlapping) MLWFs."
            },
            "exx_dis_cutoff": {
                "datatype": "real",
                "default": "8.0",
                "options": {},
                "summary": "Radial cutoff distance ",
                "id": "idm298148862448",
                "info": "Radial cutoff distance (in bohr) for including overlapping MLWF pairs in EXX calculations. See J. Chem. Theory Comput. 16, 3757\u00e2\u0080\u00933785 (2020)."
            },
            "exx_poisson_eps": {
                "datatype": "real",
                "default": "1.0D-6",
                "options": {},
                "summary": "Poisson solver convergence criterion during computation of the EXX potential",
                "id": "idm298148860480",
                "info": "Poisson solver convergence criterion during computation of the EXX potential."
            },
            "exx_use_cube_domain": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "Use cubic instead of spherical subdomains as local supports during computation of the EXX potential",
                "id": "idm298148858720",
                "info": "Use cubic instead of spherical subdomains as local supports during computation of the EXX potential. If set to .TRUE., the spherical domain radii (exx_ps_rcut_self, exx_ps_rcut_pair, exx_me_rcut_self, exx_me_rcut_pair) will be treated as half of the side length of the cubic subdomain."
            },
            "exx_ps_rcut_self": {
                "datatype": "real",
                "default": "6.0",
                "options": {},
                "summary": "Radial cutoff distance ",
                "id": "idm298148856736",
                "info": "Radial cutoff distance (in bohr) to compute the self EXX energy. This distance determines the radius of the Poisson sphere centered at a given MLWF center, and should be large enough to cover the majority of the MLWF charge density. See J. Chem. Theory Comput. 16, 3757\u00e2\u0080\u00933785 (2020)."
            },
            "exx_ps_rcut_pair": {
                "datatype": "real",
                "default": "5.0",
                "options": {},
                "summary": "Radial cutoff distance ",
                "id": "idm298148854048",
                "info": "Radial cutoff distance (in bohr) to compute the pair EXX energy. This distance determines the radius of the Poisson sphere centered at the midpoint of two overlapping MLWFs, and should be large enough to cover the majority of the MLWF product density. This parameter can generally be chosen as smaller than exx_ps_rcut_self. See J. Chem. Theory Comput. 16, 3757\u00e2\u0080\u00933785 (2020)."
            },
            "exx_me_rcut_self": {
                "datatype": "real",
                "default": "10.0",
                "options": {},
                "summary": "Radial cutoff distance ",
                "id": "idm298148851184",
                "info": "Radial cutoff distance (in bohr) for the multipole-expansion sphere centered at a given MLWF center. The far-field self EXX potential in this sphere is generated with a multipole expansion of the MLWF charge density. This parameter must be larger than exx_ps_rcut_self by at least 3 real-space grid point spacings. See J. Chem. Theory Comput. 16, 3757\u00e2\u0080\u00933785 (2020)."
            },
            "exx_me_rcut_pair": {
                "datatype": "real",
                "default": "7.0",
                "options": {},
                "summary": "Radial cutoff distance ",
                "id": "idm298148848336",
                "info": "Radial cutoff distance (in bohr) for the multipole-expansion sphere centered at the midpoint of two overlapping MLWFs. The far-field pair EXX potential in this sphere is generated with a multipole expansion of the MLWF product density. This parameter must be larger than exx_ps_rcut_pair by at least 3 real-space grid point spacings. Also, this parameter can generally be chosen as smaller than exx_me_rcut_self. See J. Chem. Theory Comput. 16, 3757\u00e2\u0080\u00933785 (2020)."
            }
        }
    },
    "bands": {
        "bands": {
            "prefix": {
                "datatype": "string",
                "default": "pwscf",
                "options": {},
                "summary": "prefix of files saved by program pw",
                "id": "idm27994044880",
                "info": "prefix of files saved by program pw.x"
            },
            "outdir": {
                "datatype": "string",
                "default": "value of the ESPRESSO_TMPDIR environment variable if set; current directory ('./') otherwise",
                "options": {},
                "summary": "directory containing the input data, i",
                "id": "idm27994043088",
                "info": "directory containing the input data, i.e. the same as in pw.x"
            },
            "filband": {
                "datatype": "string",
                "default": "bands.out",
                "options": {},
                "summary": "file name for band output ",
                "id": "idm27994041216",
                "info": "file name for band output (to be read by \"plotband.x\")"
            },
            "spin_component": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "In the lsda case select",
                "id": "idm27994039456",
                "info": "In the lsda case select:     1 = spin-up    2 = spin-down"
            },
            "lsigma": {
                "datatype": "booleanarray (3)",
                "default": "",
                "options": {},
                "summary": "If true computes expectation values of the spin operator on the spinor wave",
                "id": "idm27994038096",
                "info": "If true computes expectation values of the spin operator on the spinor wave-functions (only in the noncollinear case), writes them to a file \"filband\".i, i=1,2,3"
            },
            "lp": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm27994036048",
                "info": "If .true. matrix elements of the momentum operator p between conduction and valence bands are computed and written to file specified in filp. The matrix elements include the contribution from the nonlocal potential, i*m*[V_nl, x]. In other words, the calculated matrix elements are those of the velocity operator i*m*[H, x] times mass, not those of the true momentum operator."
            },
            "filp": {
                "datatype": "string",
                "default": "p_avg.dat",
                "options": {},
                "summary": "If lp is set to ",
                "id": "idm27994033600",
                "info": "If lp is set to .true., file name for matrix elements of p"
            },
            "lsym": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "If ",
                "id": "idm27994031472",
                "info": "If .true. the bands are classified according to the irreducible representations of the small group of k. A file \"filband\".rap with the same format of \"filband\" is written, for usage by \"plotband.x\""
            },
            "no_overlap": {
                "datatype": "boolean",
                "default": ".true.",
                "options": {},
                "summary": "If ",
                "id": "idm27994029568",
                "info": "If .false., and if lsym is .false., writes the eigenvalues in the order that maximises overlap with the neighbor k-points"
            },
            "plot_2d": {
                "datatype": "boolean",
                "default": ".false.",
                "options": {},
                "summary": "If ",
                "id": "idm27994027360",
                "info": "If .true. writes the eigenvalues in the output file in a 2D format readable by gnuplot. Band ordering is not changed. Each band is written in a different file called filband.# with the format:"
            },
            "firstk": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "if lsym=",
                "id": "idm27994024416",
                "info": "if lsym=.true. makes the symmetry analysis only for k points between firstk to lastk"
            },
            "lastk": {
                "datatype": "integer",
                "default": "",
                "options": {},
                "summary": "if lsym=",
                "id": "idm27994023792",
                "info": "if lsym=.true. makes the symmetry analysis only for k points between firstk to lastk"
            }
        }
    },
    "pw2gw": {
        "inputpp": {
            "prefix": {
                "datatype": "string",
                "default": "",
                "options": {},
                "summary": "the first part of the name of all the file written by the code should be equal to the value given in the main calculations",
                "id": "idm406479650480",
                "info": "the first part of the name of all the file written by the code should be equal to the value given in the main calculations."
            },
            "outdir": {
                "datatype": "string",
                "default": "\"./\"",
                "options": {},
                "summary": "the scratch directory where the massive data",
                "id": "idm406479648608",
                "info": "the scratch directory where the massive data-files are written"
            },
            "what": {
                "datatype": "string",
                "default": "\"gw\"",
                "options": {},
                "summary": "\"gw\" ",
                "id": "idm406479646864",
                "info": "\"gw\" : Calculate dipole optical matrix elements (use for norm-conserving pseudopotentials) and imaginary part of the dielectric function.  \"gmaps\": write g-maps for each processor in a file \"fort.'100 + processor number'\""
            },
            "qplda": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "if ",
                "id": "idm406479644912",
                "info": "if .TRUE. write the interface file \"QPLDA\" to GW and BSE codes (chisig, dpforexc)."
            },
            "vxcdiag": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "if ",
                "id": "idm406479642992",
                "info": "if .TRUE. calculates the expectation value of the exchange and correlation potential on all the Kohn-Sham states and write it into the \"vxcdiag.dat\" file."
            },
            "vkb": {
                "datatype": "boolean",
                "default": ".FALSE.",
                "options": {},
                "summary": "if ",
                "id": "idm406479641040",
                "info": "if .TRUE. use Kleyman-Bylander projectors to write additional informatio into fort.15 file (Still in development)"
            },
            "Emin": {
                "datatype": "real",
                "default": "0.0",
                "options": {},
                "summary": "Starting photon energy for which the dielectric function is calculated ",
                "id": "idm406479639248",
                "info": "Starting photon energy for which the dielectric function is calculated (in eV)"
            },
            "Emax": {
                "datatype": "real",
                "default": "30.0",
                "options": {},
                "summary": "Highest photon energy for which the dielectric function is calculated ",
                "id": "idm406479637504",
                "info": "Highest photon energy for which the dielectric function is calculated (in eV)"
            },
            "DeltaE": {
                "datatype": "real",
                "default": "0.05",
                "options": {},
                "summary": "Energy step with which the dielectric function is calculated ",
                "id": "idm406479635760",
                "info": "Energy step with which the dielectric function is calculated (in eV)"
            }
        }
    }
}