{
    "PREC": {
        "Low": "ENCUT=max(ENMIN), NGX=3/2*Gcut, NGXF=3*Gaug, ROPT=-1E-2",
        "Medium": "ENCUT=max(ENMAX), NGX=3/2*Gcut, NGXF=4*Gaug, ROPT=-2E-3",
        "High": "ENCUT=1.3*max(ENMAX), NGX=2*Gcut, NGXF=16/3*Gaug, ROPT=-4E-4",
        "Normal": "ENCUT=max(ENMAX), NGX=3/2*Gcut, NGXF=2*NGX, ROPT=-5E-4",
        "Single": "ENCUT=max(ENMAX), NGX=2*Gcut, NGXF=NGX, ROPT=-5E-4",
        "SingleN": "ENCUT=max(ENMAX), NGX=3/2*Gcut, NGXF=NGX, ROPT=-5E-4",
        "Accurate": "ENCUT=max(ENMAX), NGX=2*Gcut, NGXF=2*NGX, ROPT=-2.5E-4"
    },
    "ICHARG": {
        "0": "Calculate the charge density from initial wave functions",
        "1": "Read the charge density from CHGCAR, extrapolate from old to new positions.",
        "2": "Use a superposition of atomic charge densities",
        "4": "Read the potential from POT file",
        "10": "NSCF calculation, read from CHGCAR",
        "11": "NSCF calculation, read from CHGCAR",
        "12": "NSCF calculation, read from CHGCAR, a la Harris-Foulkes"
    },
    "ISTART": {
        "0": "Start job from scratch",
        "1": "Restart with constant energy cutoff, read from WAVECAR",
        "2": "Restart with constant basis set, read from WAVECAR",
        "3": "Restart with constant energy basis set, read from WAVECAR and TMPCAR"
    },
    "INIWAV": {
        "1": "KS orbitals from 'Jellium' orbitals",
        "0": "KS orbitals from random numbers"
    },
    "ALGO": {
        "Normal": "Blocked Davidson iteration scheme",
        "VeryFast": "RMM-DIIS",
        "Old VeryFast": "RMM-DIIS (VASP 5 version)",
        "ov": "RMM-DIIS (VASP 5 version)",
        "vo": "RMM-DIIS (VASP 5 version)",
        "Fast": "Mixture of Davidson and RMM-DIIS",
        "Old Fast": "Mixture of Davidson and RMM-DIIS (VASP 5 version)",
        "of": "Mixture of Davidson and RMM-DIIS (VASP 5 version)",
        "fo": "Mixture of Davidson and RMM-DIIS (VASP 5 version)",
        "Conjugate": "Conjugate gradient algorithm",
        "All": "Conjugate gradient algorithm",
        "Damped": "Damped velocity friction algorithm",
        "Subrot": "Diagonalization in subspace spanned by orbitals",
        "Eigenval": "Recalculate one-electron energies",
        "Exact": "Exact diagonalization",
        "None": "Recalculate DOS/perform post-processing",
        "Nothing": "Recalculate DOS/perform post-processing",
        "CHI": "Calculate response functions only",
        "G0W0": "Single-shot G0W0 calculation",
        "GW0": "Partially self-consistent GW (update QP energies in G)",
        "EVGW0": "Partially self-consistent GW (update QP energies in G)",
        "GW": "Partially self-consistent GW (update QP energies in G and W)",
        "EVGW": "Partially self-consistent GW (update QP energies in G and W)",
        "scGW0": "Self-consistent GW (update QP energies/one-electron orbitals in G)",
        "QPGW0": "Self-consistent GW (update QP energies/one-electron orbitals in G)",
        "scGW": "Self-consistent GW (update QP energies/one-electron orbitals in G and W)",
        "QPGW": "Self-consistent GW (update QP energies/one-electron orbitals in G and W)",
        "G0W0R": "Single-shot GW, non-interacting G and W from KS system",
        "GW0R": "Partially self-consistent GW, G updated from Dyson equation",
        "GWR": "Self-consistent GW, G and W updated from Dyson equation",
        "CRPA": "Constrained RPA calculations",
        "EVGW0R": "Low scaling partially self-consistent GW, G updated",
        "ACFDT": "RPA total energy calculation",
        "RPA": "RPA total energy calculation",
        "ACFDTR": "Low-scaling RPA total energy calculation",
        "ACFDTRK": "Low-scaling MP2 total energy calculation",
        "RPAR": "Low-scaling RPA total energy calculation",
        "BSE": "BSE calculation (Bethe-Salpeter equation)",
        "TDHF": "TDHF calculation (Casida equations)"
    },
    "IALGO": {
        "-1": "Preformance test, no actual calculation",
        "2": "Keep orbitals and one-electron energies fixed",
        "3": "Keep orbitals fixed",
        "4": "Update orbitals by sub-space rotation",
        "5": "Steepest descent",
        "6": "Conjugate gradient",
        "7": "Preconditioned steepest descent",
        "8": "Preconditioned conjugate gradient",
        "15": "Conjugate gradient after iterative refinement of eigenvectors",
        "16": "Conjugate gradient after iterative refinement of eigenvectors",
        "17": "Conjugate gradient after iterative refinement of eigenvectors",
        "18": "Conjugate gradient after iterative refinement of eigenvectors",
        "28": "Subspace diagonalization before conjugate gradient algorithm",
        "38": "Blocked Davidson algorithm",
        "44": "Steepest descent eigenvalue minimization RMM-DIIS",
        "46": "Residuum minimization + preconditioning RMM-DIIS",
        "48": "Preconditioned residuum minimization RMM-DIIS",
        "53": "Damped MD, damping term from time-step",
        "54": "Damped MD, velocity quenched or quickmin",
        "58": "Preconditioned conjugate gradient",
        "90": "Exact diagonalization"
    },
    "LREAL": {
        ".FALSE.": "Reciprocal space projection",
        "Auto": "Real space projection, automatic optimization",
        "A": "Real space projection, automatic optimization",
        "On": "Real space projections, operators re-optimized",
        "O": "Real space projections, operators re-optimized",
        ".TRUE.": "Real space projections, use projectors from file"
    },
    "GGA": {
        "LIBXC": "Use LibXC, see LIBXC1 and LIBXC2 tags",
        "CA": "Perdew-Zunger (PZ LDA)",
        "PZ": "Perdew-Zunger (PZ LDA)",
        "VW": "Vosko-Wilk-Nusair (VWN5 LDA)",
        "HL": "Hedin-Lundqvist (HL LDA)",
        "WI": "Slater exchange + Wigner Correlation (LDA)",
        "91": "Perdew-Wang (PW91 GGA)",
        "PE": "Perdew-Burke-Ernzerhof (PBE GGA)",
        "RE": "Zhang-Yang revised PBE (revPBE GGA)",
        "RP": "Hammer et al. revised PBE (RPBE GGA)",
        "PS": "Revised PBE for solids (PBEsol GGA)",
        "AM": "Armiento-Mattson (AM05 GGA)",
        "B3": "B3LYP GGA with VWN3 for LDA correlation",
        "B5": "B3LYP GGA with VWN5 for LDA correlation",
        "BF": "BEEF",
        "OR": "optPBE exchange + PBE correlation",
        "BO": "optB88 exchange + PBE correlation",
        "MK": "optB86b exchange + PBE correlation",
        "ML": "PW86R exchange + PBE correlation",
        "CX": "CX (LV-PW86r) exchange + PBE correlation"
    },
    "IMIX": {
        "0": "No mixing",
        "1": "Kerker mixing",
        "2": "Variant of Tchebycheff mixing",
        "4": "Broyden's 2nd method or Pulay mixing"
    },
    "ISPIN": {
        "2": "Spin-polarized calculation",
        "1": "Non-spin polarized calculation"
    },
    "INIMIX": {
        "0": "Initial linear mixing",
        "1": "Initial Kerker mixing",
        "2": "No initial mixing"
    },
    "MIXPRE": {
        "0": "No pre-conditioning of Broyden mixing, metric=1",
        "1": "Inverse Kerker metric, automatic BMIX",
        "2": "Inverse Kerker metric, automatic BMIX",
        "3": "Inverse Kerker metric, BMIX from INCAR"
    },
    "PRECFOCK": {
        "Normal": "FFT grid for exact exchange: 3/2*Gcut (good precision)",
        "Accurate": "FFT grid for exact exchange: 2*Gcut (for phonons)",
        "Fast": "FFT grid for exact exchange: Gcut (some noise in forces)",
        "Medium": "FFT grid for exact exchange: same as std. FFT (outdated)",
        "Single": "FFT grid for exact exchange: same as std. FFT",
        "Low": "FFT grid for exat exchange: Gcut (large noise, outdated)"
    },
    "I_CONSTRAINED_M": {
        "2": "Constrain size and direction of magnetic moments",
        "1": "Constrain direction of magnetic moments"
    },
    "LDAUTYPE": {
        "1": "Rotationally invariant DFT+U (Liechtenstein et al.)",
        "2": "Rotationally invariant DFT+U (Dudarev et al.)",
        "3": "Compute U from linear response(Cococcioni & de Gironcoli)",
        "4": "Rot. invariant DFT+U (Liechtenstein et al.), no exchange splitting"
    },
    "LDAUPRINT": {
        "1": "Print onsite occupancy matrices to OUTCAR",
        "0": "Don't print onsite occupancy matrix to OUTCAR"
    },
    "IPEAD": {
        "1": "First-order finite difference stencil",
        "2": "Second-order finite difference stencil",
        "3": "Third-order finite difference stencil",
        "4": "Fourth-order finite difference stencil"
    },
    "IBRION": {
        "-1": "Don't update atomic positions",
        "0": "Molecular dynamics",
        "1": "Ionic relaxation (RMM-DIIS)",
        "2": "Ionic relaxation (conjugate gradient)",
        "3": "Ionic relaxation (damped molecular dynamics)",
        "5": "Dynamical matrix, hessian, phonon freq via finite differences (no symmetry)",
        "6": "Dynamical matrix, hessian, phonon freq via finite differences (with symmetry)",
        "7": "Dynamical matrix, hessian, phonon freq via DFPT (no symmetry)",
        "8": "Dynamical matrix, hessian, phonon freq via DFPT (with symmetry)",
        "40": "Calculate energy profile along IRC",
        "44": "Improved dimer method"
    },
    "SMASS": {
        "-3": "Micro canonical (NVE) ensemble",
        "-2": "Initial velocities are kept constant",
        "-1": "Velocity scaling each NBLOCK steps",
        "[real] >= 0": "Nose mass in canonical ensemble calculation"
    },
    "ISMEAR": {
        "-5": "Tetrahedron method with Bloechl corrections",
        "-4": "Tetrahedron mehtod",
        "-3": "Loop over SMEARINGS",
        "-2": "Read partial occupancies from WAVECAR or FERWE/FERDO in INCAR",
        "-1": "Fermi-Dirac smearing",
        "0": "Gaussian smearing",
        "[integer]>0": "Methfessel paxton smearing of order N"
    },
    "LORBIT": {
        "0": "Write DOSCAR and PROCAR (see RWIGS)",
        "1": "Write DOSCAR and lm-decomposed PROCAR (see RWIGS)",
        "2": "Write DOSCAR and lm-decomposed PROCAR + phase factors (see RWIGS)",
        "5": "Write DOSCAR and PROOUT (see RWIGS)",
        "10": "Write DOSCAR and PROCAR",
        "11": "Write DOSCAR and lm-decomposed PROCAR",
        "12": "Write DOSCAR and lm-decomposed PROCAR+phase factors",
        "13": "Write DOSCAR and lm-decomposed PROCAR+phase factors, best projector for each band",
        "14": "Write DOSCAR and lm-decomposed PROCAR+phase factors, best projector in EMIN-EMAX"
    },
    "METAGGA": {
        "LIBXC": "Use LibXC, see LIBXC1 and LIBXC2 tags",
        "M06L": "M06L functional",
        "TPSS": "TPSS functional",
        "RTPSS": "revTPSS functional",
        "MS0": "MS0 functional",
        "MS1": "MS1 functional",
        "MS2": "MS2 functional",
        "SCAN": "SCAN functional",
        "RSCAN": "rSCAN (regularized SCAN) functional",
        "R2SCAN": "r2SCAN (regularized-restored SCAN) functional",
        "SCANL": "SCAN-L functional",
        "RSCANL": "rSCAN-L (regularized SCAN-L) functional",
        "R2SCANL": "r2SCAN-L (regularized-restored SCAN-L) functional",
        "OFR2": "OFR2 functional",
        "MBJ": "Modified Becke-Johnson (MBJ) potential (EXC from LDA)",
        "LMBJ": "local modified Becke-Johnson (LMBJ) potential (EXC from LDA)"
    },
    "ICHIBARE": {
        "1": "First-order finite-difference stencil for chi",
        "2": "Second-order finite-difference stencil for chi",
        "3": "Third-order finite-difference stencil for chi"
    },
    "IDIPOL": {
        "1": "Dipole moment in direction of first lattice vector",
        "2": "Dipole moment in direction of second lattice vector",
        "3": "Dipole moment in direction of third lattice vector",
        "4": "Dipole moment in all directions"
    },
    "ISYM": {
        "-1": "Completely switch off symmetry",
        "0": "Don't use symmetry but assume psi_k = psi*_{-k}",
        "1": "Use symmetry",
        "2": "Use symmetry, more efficient algorithm",
        "3": "Construct charge density by applying symops to orbitals in IBZ"
    },
    "ISIF": {
        "0": "Compute: forces. DOF: positions",
        "1": "Compute: forces, trace of stress tensor. DOF: positions",
        "2": "Compute: forces, stress tensor. DOF: positions",
        "3": "Compute: forces, stress tensor. DOF: positions, cell shape and volume",
        "4": "Compute: forces, stress tensor. DOF: positions, cell shape",
        "5": "Compute: forces, stress tensor. DOF: cell shape",
        "6": "Compute: forces, stress tensor. DOF: cell shape and volume",
        "7": "Compute: forces, stress tensor. DOF: cell volume"
    },
    "MDALGO": {
        "0": "Standard molecular dynamics",
        "1": "Andersen thermostat",
        "2": "Nose-Hoover thermostat",
        "3": "Langevin thermostat",
        "4": "Nose-Hoover chains thermostat",
        "13": "Multiple Andersen thermostats",
        "21": "Nose-Hoover thermostat"
    },
    "ANTIRES": {
        "0": "Tamm-Dancoff approximation (TDA)",
        "1": "Exact results at omega=0, same cost as Tam-Dancoff approx (TDA)",
        "2": "Beyond Tam-Dancoff approx (TDA), couple + and - frequencies"
    },
    "IGPAR": {
        "1": "G_parallel along first reciprocal lattice vector",
        "2": "G_parallel along second reciprocal lattice vector",
        "3": "G_parallel along third reciprocal lattice vector"
    },
    "IVDW": {
        "0": "No vdW correction",
        "1": "DFT-D2 (Grimme) vdW correction",
        "10": "DFT-D2 (Grimme) vdW correction",
        "11": "DFT-D3 (Grimme et al.) vdW correction with no damping function)",
        "12": "DFT-D3 (Grimme et al.) vdW correction with Becke-Johnson damping function",
        "13": "DFT-D4 vdW correction",
        "2": "Tkatchenko-Scheffler vdW correction",
        "20": "Tkatchenko-Scheffler vdW correction",
        "21": "Tkatchenko-Scheffler vdW correction w/ iterative Hirshfeld partitioning",
        "202": "Many-body dispersion energy method (MBD@rSC)",
        "263": "Many-body dispersion energy with fractionally ionic model for polarizability method (MBD@rSC/FI)",
        "4": "dDsC dispersion method",
        "3": "DFT-ulg vdW correction"
    },
    "IWAVPR": {
        "0": "Don't extrapolate orobitals/charge densitites between ionic configs",
        "1": "Simple extrapolation of orbitals/charge densities between ionic configs",
        "2": "Second-order extrapolation of orbitals/charge densities between ionic configs",
        "3": "Second-order/simple extrapolation of orbitals/charge densities between ionic configs",
        "10": "Automatic extrapolation of orbitals/charge densities between ionic configs, based on IBRION",
        "11": "Simple extrapolation of orbitals/charge densities between ionic configs",
        "12": "Second-order extrapolation of orbitals/charge densities between ionic configs",
        "13": "Second-order/simple extrapolation of orbitals/charge densities between ionic configs"
    },
    "NWRITE": {
        "0": "Very low verbosity in OUTCAR",
        "1": "Low verbosity in OUTCAR",
        "2": "Medium (default) verbosity in OUTCAR",
        "3": "High verbosity in OUTCAR",
        "4": "Debugging-level verbosity in OUTCAR"
    },
    "VOSKOWN": {
        "0": "Don't use Vosko-Wilk-Nusair interpolation",
        "1": "Use Vosko-Wilk-Nusair interpolation"
    },
    "NMAXFOCKAE": {
        "2": "Very accurate augmentation on plane wave grid.",
        "1": "Default augmentation on plane wave grid."
    },
    "IEPSILON": {
        "1": "E-field applied along x direction",
        "2": "E-field applied along y direction",
        "3": "E-field applied along z direction",
        "4": "E-field applied along x,y,z directions (independently)"
    },
    "STOP_ON": {
        "Alert": "Stop calculations on alerts and errors",
        "Error": "Stop calculations on errors only (default)"
    },
    "ICORELEVEL": {
        "0": "Don't calculate core energy levels",
        "1": "Calculate core energy levels using the initial-state approx",
        "2": "Calculate core energy levels using the final-state approx"
    },
    "FOCKCORR": {
        "1": "Small G Coulomb correction depends on HFALPHA/HFRCUT",
        "2": "Small G Coulomb correction: scale original orbital by convergence corr."
    },
    "CUTOFF_TYPE": {
        "erfc": "Error function cutoff before performing SVD on initial projections",
        "gaussian": "Gaussian cutoff before performing SVD on initial projections",
        "fermi": "Fermi-Dirac cutoff before performing SVD on initial projections"
    },
    "PHON_DOS": {
        "0": "Don't compute phonon DOS",
        "1": "Use Gaussian broadening (PHON_SIGMA) for phonon DOS",
        "2": "Use tetrahedron method for phonon DOS"
    },
    "ML_MODE": {
        "train": "On-the-fly ML force-field training",
        "select": "Train force field by reselecting local reference config from ML_AB file",
        "refit": "Construct force field from existing ML_AB file",
        "refitbayesian": "Construct force field from existing ML_AB file using Bayesian regression",
        "run": "Force-field evaluation",
        "none": "Tag is ignored"
    }
}