"""
Utility functions for codex
"""

import subprocess
import shlex
import logging
import re
import operator

from lxml import etree


import nanoid
from marshmallow import ValidationError

CDX_ID_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"


def generate_cdxid(cdx_type):
    """
    Generates a random cdx id using nanoid
    """
    if cdx_type in ("file", "calc", "project"):
        x = cdx_type[0]
    else:
        raise ValueError(f"Invalid cdx type: {cdx_type}")
    return f"cdx-{x}-{nanoid.generate(CDX_ID_ALPHABET, size=12)}"


def validate_cdxid(cdxid):
    """
    Validates a cdx id. These are of the form cdx-[fcp]-<12 alphanumeric characters>
    The alpha numeric characters can be 0-9, A-Z, or a-z
    """
    if not re.match(r"cdx-[fcp]-[A-Za-z0-9]{12}", cdxid):
        raise ValidationError("Invalid cdxid")


def range_dict_get(tag, range_dict):
    """
    Finds the value corresponding to a key (`tag`) in a dictionary whose keys
    might include ranges. The dictionary keys are either just the `tag` itself
    (for discrete values) or a string describing a range (for continuous values).

    Expects `range_dict` to have string keys and values (i.e., json)

    Realistic Example:
    ```
    options = {'-5': 'Tetrahedron method (Blochl Corrections)'
    '-4': 'Tetrahedron method'
    '-3': 'MP method'
    '-2': 'Partial Occupancies'
    '-1': 'Fermi smearing'
    '0': 'Gaussian smearing'
    '[integer]>0': 'MP method of order {}'
    }
    get_from_range_dict(-5, options) # returns 'Tetrahedron method (Blochl Corrections)'
    get_from_range_dict(2, options) # returns 'MP method of order 2'
    ```

    Convoluted example (move to unit test):

    weather_status = {
        "[integer]<=      -10": "It's freezing! It's {} degrees outside",
        "20": "Weather is okay.",
        "[float]    >+50.0": "It's boiling! It's {} degrees outside.",
    }
    range_dict_get(20, weather_status)    # returns "Weather is okay."
    range_dict_get(21, weather_status)    # returns None
    range_dict_get(50.0, weather_status)  # returns None
    range_dict_get(60.3, weather_status)  # returns "It's boiling! It's 60.3 degrees outside."
    range_dict_get(-20, weather_status)   # returns "It's freezing! It's -20 degrees outside."
    range_dict_get(-30.0, weather_status) # returns "It's freezing! It's -30 degrees outside."
    range_dict_get(-50.2, weather_status) # returns None
    """
    # See if it's one of the discrete values
    val = range_dict.get(str(tag.lower()))
    if val is not None:
        return val

    # If not, see if it's a range
    pattern = r"\[(\w+)\]\s*([><]=?)\s*([+-]?\d+.?\d+)"
    for k in range_dict.keys():
        match = re.match(pattern, k)
        if match:
            # print(f'Matched range: {re.match(pattern, key).groups()}')
            datatype = float if match.group(1).lower() == "float" else int
            limit = datatype(match.group(3))

            comp = {"<": operator.lt, "<=": operator.le, ">": operator.gt, ">=": operator.ge}
            comp = comp[match.group(2)]

            # We don't want strong typing here, so we'll allow some flexibility
            # Integer value matches float range (e.g., 50 will match [FLOAT] <= 50)
            # Float value matches integer range if it's actually an integer
            # (e.g., 50.0 will match [INTEGER] <= 50)
            if (
                isinstance(tag, datatype)
                or (isinstance(tag, int) and datatype == float)
                or (isinstance(tag, float) and datatype == int and tag.is_integer())
            ):
                if comp(tag, limit):
                    return range_dict[k].format(datatype(tag))

    return None


def remove_html_tags(text):
    """Remove html tags from a string"""
    if text:
        parser = etree.HTMLParser()
        tree = etree.fromstring(text, parser)
        string = etree.tostring(tree, encoding="unicode", method="text")
        return string.strip()
    return text


def tidy_dict(d):
    """
    Tidy dicts common in helpdoc's xml output.
    Calls tidy_str on both keys and values.
    """
    tidy_d = {}
    for k, v in d.items():
        if isinstance(k, str):
            k = tidy_str(k)
        if v and isinstance(v, str):
            v = tidy_str(v)
        tidy_d[k] = v
    return tidy_d


def tidy_str(s):
    """
    Tidy strings common in helpdoc's xml output.
    Remove newlines, strip whitespace, remove single quotes.
    """
    s = s.replace("\n", " ").strip()
    if s and s[0] == "'" and s[-1] == "'":
        s = s[1:-1]
    return s


def wipe_style(html):
    """
    Remove style, align, valign, and width attributes from a lxml.html.HtmlElement
    Used for cleaning styles from the html generated by QE's helpdoc.
    """
    to_delete = ["style", "align", "valign", "width"]
    for attr in to_delete:
        if attr in html.attrib:
            del html.attrib[attr]


def run_command(command):
    """
    Run a command and return the result. If the command fails, raise an exception.
    """
    logging.info(f"Command: {command}")
    command = shlex.split(command)

    try:
        result = subprocess.run(command, capture_output=True, check=True)
    except subprocess.CalledProcessError as exc:
        logging.error(
            f"Status : FAIL (return code {exc.returncode}),\n"
            f"stdout:\n {exc.stdout},\n"
            f"stderr:\n {exc.stderr}"
        )
        return exc.returncode
    if result.stdout:
        logging.debug(f"Command stdout: {result.stdout.decode('utf-8')}")
    if result.stderr:
        logging.debug(f"Command stderr: {result.stderr.decode('utf-8')}")

    return result.returncode
